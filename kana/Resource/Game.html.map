{"version":3,"file":"../../Bin/Game.html","sources":["../Game.c","../DuckEngine/DuckEngine.c","../DuckEngine/DuckFile.c","../DuckEngine/DuckFont.c","../DuckEngine/DuckFontString.c","../DuckEngine/DuckGui.c","../DuckEngine/DuckInput.c","../DuckEngine/DuckMatrix.c","../DuckEngine/DuckMemory.c","../DuckEngine/DuckShader.c","../DuckEngine/DuckSprite.c","../DuckEngine/DuckSpriteSheet.c","../DuckEngine/DuckString.c","../DuckEngine/DuckTexture.c","../DuckEngine/lodepng/lodepng.c","../DuckEngine/stb_truetype/stb_truetype.h","../DuckEngine/utf8proc/utf8proc.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;;;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;ACvGA;;;;;AAIA;AAAA;;AAAA;AAAA;;AACA;;;;;;;;AAIA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;AAIA;AAAA;AAAA;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AA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AA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6WA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;AAAA;;AAwBA;;AAtBA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;AACA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxTA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;;AA5BA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqHA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAMA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;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AAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3OA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;AAAA;;;;AA6EA;;AA1EA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AACA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;AACA;AAAA;;;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtNA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAoCA;AAAA;;AAnCA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AA;AACA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AArBA;;;AA0BA;AAAA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAIA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;;;AAIA;AAAA;;AAAA;;;AAGA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAMA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAEA;A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AAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAeA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAeA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAQA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAOA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAVA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;;;AAxCA;AAAA;AAAA;;AAkDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;;;;;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AAjDA;AAAA;;;AAqCA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAqBA;AAAA;;;;;;AATA;AAAA;AAAA;;AAEA;AAAA;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAxQA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAMA;AAAA;;AAJA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAvBA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAYA;AAAA;;AAXA;AAAA;AAAA;AAAA;;AAAA;AAWA;AAAA;;AATA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;AAAA;;;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AALA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAhEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAkSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;AAHA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;AA8CA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsSA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;;AAAA;AAqDA;AAAA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AACA;AA+CA;AAAA;;AA3CA;;AAAA;AAAA;;;;;AACA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AACA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAVA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AArBA;AAAA;AAAA;;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjCA;AAAA;AAAA;;;AAoCA;AAAA;AAOA;AAAA;;AALA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;;;;;;;;;;;;;;AA9FA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAQA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;AAAA;AAAA;;AAAA;;;AAAA;;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAKA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5JA;AAAA;;AAAA;AAAA;;;AAAA;;;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAiCA;;AAhCA;AAEA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAfA;AAAA;AAAA;AAAA;;AAJA;AAAA;AAAA;;AAwBA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoKA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAGA;AAAA;AACA;;AAJA;AAAA;AAAA;;AAGA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;AA7OA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1GA;AACA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAMA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAnEA;AAAA;AAAA;;AAqEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AA3DA;AAAA;;;AA8DA;AAAA;;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AAEA;;AADA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAjKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAYA;AAAA;;AAVA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;;AAEA;AAAA;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;;;;AAOA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;ACh0CA;AACA;AAAA;AACA;AAAA;;AAAA;AA+BA;AAAA;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AA6BA;AAAA;;AA5BA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AA4BA;AAAA;;;AA3BA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AACA;AA0BA;AAAA;;AAxBA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AAAA;AAAA;;;;;;AAAA;;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;;;AAVA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;AAcA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAHA;AAGA;AAAA","sourcesContent":["\n\t#include \"DuckEngine/DuckEngine.h\"\n\t\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\t#include <time.h>\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n\t\n\tduck_sprite_sheet* s_spriteSheet = NULL;\n\tduck_font* s_font = NULL;\n\tfloat s_angle = 0.0f;\n\n\tuint32_t s_timer = 0;\n\tint score = 0;\n\t//duck_string* question = NULL;\n\t//duck_string* answer = NULL;\n\tduck_string* input = NULL;\n\t//int winTimer = 1;\n\n\t#define MODE_INPUT 0\n\t#define MODE_ATTACK_IN 1\n\t#define MODE_ATTACK_OUT 2\n\t#define MODE_DEFEND_IN 3\n\t#define MODE_DEFEND_OUT 4\n\t\n\tstatic int s_mode = MODE_INPUT;\n\t\n\t#define FLOOR 210.0f\n\t\n\t#define MONSTER_X 80.0f\n\t#define PLAYER_X 210.0f\n\t\n\t#define GRAVITY 9.0f\n\t\n\t#define JUMP_IN_VELOCITY_X 15.0f\n\t#define JUMP_IN_VELOCITY_Y -30.0f\n\t\n\t#define JUMP_OUT_VELOCITY_X -20.0f\n\t#define JUMP_OUT_VELOCITY_Y -15.0f\n\n\n\tstatic float s_playerX = PLAYER_X;\n\tstatic float s_playerY = FLOOR;\n\tstatic float s_playerVelocityX = 0.0f;\n\tstatic float s_playerVelocityY = 0.0f;\n\t\n\tstatic float s_monsterX = MONSTER_X;\n\tstatic float s_monsterY = FLOOR;\n\tstatic float s_monsterVelocityX = 0.0f;\n\tstatic float s_monsterVelocityY = 0.0f;\n\n\tstatic const char* hiragana[] =\n\t{\n\t\t\"あ\", \"A\",\n\t\t\"い\", \"I\",\n\t\t\"う\", \"U\",\n\t\t\"え\", \"E\",\n\t\t\"お\", \"O\",\n\t\t\n\t\t\"か\", \"KA\",\n\t\t\"き\", \"KI\",\n\t\t\"く\", \"KU\",\n\t\t\"け\", \"KE\",\n\t\t\"こ\", \"KO\",\n\t\n\t\t\"さ\", \"SA\",\n\t\t\"し\", \"SHI\",\n\t\t\"す\", \"SU\",\n\t\t\"せ\", \"SE\",\n\t\t\"そ\", \"SO\",\n\t\n\t\t\"た\", \"TA\",\n\t\t\"ち\", \"CHI\",\n\t\t\"つ\", \"TSU\",\n\t\t\"て\", \"TE\",\n\t\t\"と\", \"TO\",\n\t\t\n\t\t\"な\", \"NA\",\n\t\t\"に\", \"NI\",\n\t\t\"ぬ\", \"NU\",\n\t\t\"ね\", \"NE\",\n\t\t\"の\", \"NO\",\n\t\t\n\t\t\"は\", \"HA\",\n\t\t\"ひ\", \"HI\",\n\t\t\"ふ\", \"FU\",\n\t\t\"へ\", \"HE\",\n\t\t\"ほ\", \"HO\",\n\t\t\n\t\t\"ま\", \"MA\",\n\t\t\"み\", \"MI\",\n\t\t\"む\", \"MU\",\n\t\t\"め\", \"ME\",\n\t\t\"も\", \"MO\",\n\t\t\n\t\t\"や\", \"YA\",\n\t\t\"ゆ\", \"YU\",\n\t\t\"よ\", \"YO\",\n\t\t\n\t\t\n\t\t\"ら\", \"RA\",\n\t\t\"り\", \"RI\",\n\t\t\"る\", \"RU\",\n\t\t\"れ\", \"RE\",\n\t\t\"ろ\", \"RO\",\n\t\t\n\t\t\"わ\", \"WA\",\n\t\t\"を\", \"WO\",\n\t\t\n\t\t\"ん\", \"N\",\n\t};\n\t\n\tstatic uint32_t numQuestion;\n\tstatic duck_string** questionArray;\n\tstatic duck_string** answerArray;\n\tstatic uint32_t questionOffset;\n\t\n\n\tvoid Shuffle(int32_t nOffset)\n\t{\n\t\tuint32_t i;\n\t\tfor (i = nOffset; i < numQuestion; i++)\n\t\t{\n\t\t\tuint32_t random = rand() % (numQuestion-i) + i;\n\t\t\t\n\t\t\tduck_string* tempQuestion = questionArray[random];\n\t\t\tduck_string* tempAnswer = answerArray[random];\n\t\t\t\n\t\t\tquestionArray[random] = questionArray[i];\n\t\t\tanswerArray[random] = answerArray[i];\n\t\t\t\n\t\t\tquestionArray[i] = tempQuestion;\n\t\t\tanswerArray[i] = tempAnswer;\n\t\t}\n\t}\n\n\tvoid NextQuestion()\n\t{\n\t\tquestionOffset++;\n\t\tif (questionOffset >= numQuestion)\n\t\t{\n\t\t\tquestionOffset = 0;\n\t\t\tShuffle(0);\n\t\t}\n\t\t\n\t\tDuckString_Set(input, \"\");\n\t\tDuckInput_ClearUnicodeInput();\n\t\tDuckInput_GetKeyPressed(DUCK_KEY_ENTER);\n\t}\n\t\n\tvoid RetryQuestion()\n\t{\n\t\tShuffle(questionOffset);\n\t\t\n\t\tDuckString_Set(input, \"\");\n\t\tDuckInput_ClearUnicodeInput();\n\t\tDuckInput_GetKeyPressed(DUCK_KEY_ENTER);\n\t}\n\n\tvoid GameUpdate(duck_gui* self, float parentX, float parentY)\n\t{\n\t\ts_timer++;\n\t\ts_angle += 0.011;\n\n\n\t\tif (s_playerY < FLOOR)\n\t\t\ts_playerVelocityY += GRAVITY;\n\t\t\n\t\ts_playerX += s_playerVelocityX;\n\t\ts_playerY += s_playerVelocityY;\n\t\t\n\t\tif (s_playerY > FLOOR)\n\t\t{\n\t\t\ts_playerY = FLOOR;\n\t\t\ts_playerVelocityY = 0.0f;\n\t\t}\n\t\t\n\t\t\n\t\tif (s_monsterY < FLOOR)\n\t\t\ts_monsterVelocityY += GRAVITY;\n\t\t\n\t\ts_monsterX += s_monsterVelocityX;\n\t\ts_monsterY += s_monsterVelocityY;\n\t\t\n\t\tif (s_monsterY > FLOOR)\n\t\t{\n\t\t\ts_monsterY = FLOOR;\n\t\t\ts_monsterVelocityY = 0.0f;\n\t\t}\n\n\n\n\t\tswitch (s_mode)\n\t\t{\n\t\t\tcase MODE_INPUT:\n\t\t\t{\n\t\t\t\tuint32_t unicode = DuckInput_GetUnicodeInput();\n\t\t\t\tif (unicode > 0)\n\t\t\t\t\tDuckString_AppendChar(input, (char)unicode);\n\t\t\t\t\n\t\t\t\tif (DuckInput_GetKeyPressed(DUCK_KEY_ENTER))\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(DuckString_GetCString(answerArray[questionOffset]), DuckString_GetCString(input)) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ts_mode = MODE_ATTACK_IN;\n\t\t\t\t\t\ts_playerVelocityX = -JUMP_IN_VELOCITY_X;\n\t\t\t\t\t\ts_playerVelocityY = JUMP_IN_VELOCITY_Y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ts_mode = MODE_DEFEND_IN;\n\t\t\t\t\t\ts_monsterVelocityX = JUMP_IN_VELOCITY_X;\n\t\t\t\t\t\ts_monsterVelocityY = JUMP_IN_VELOCITY_Y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase MODE_ATTACK_IN:\n\t\t\t{\n\t\t\t\tif (s_playerX < MONSTER_X)\n\t\t\t\t{\n\t\t\t\t\ts_playerX = MONSTER_X;\n\t\t\t\t\ts_playerY = FLOOR;\n\t\t\t\t\ts_mode = MODE_ATTACK_OUT;\n\t\t\t\t\ts_playerVelocityX = -JUMP_OUT_VELOCITY_X;\n\t\t\t\t\ts_playerVelocityY = JUMP_OUT_VELOCITY_Y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase MODE_DEFEND_IN:\n\t\t\t{\n\t\t\t\tif (s_monsterX > PLAYER_X)\n\t\t\t\t{\n\t\t\t\t\ts_monsterX = PLAYER_X;\n\t\t\t\t\ts_monsterY = FLOOR;\n\t\t\t\t\ts_mode = MODE_DEFEND_OUT;\n\t\t\t\t\ts_monsterVelocityX = JUMP_OUT_VELOCITY_X;\n\t\t\t\t\ts_monsterVelocityY = JUMP_OUT_VELOCITY_Y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase MODE_ATTACK_OUT:\n\t\t\t{\n\t\t\t\tif (s_playerX > PLAYER_X)\n\t\t\t\t{\n\t\t\t\t\ts_playerX = PLAYER_X;\n\t\t\t\t\ts_playerY = FLOOR;\n\t\t\t\t\ts_mode = MODE_INPUT;\n\t\t\t\t\ts_playerVelocityX = 0.0f;\n\t\t\t\t\ts_playerVelocityY = 0.0f;\n\t\t\t\t\t\n\t\t\t\t\tNextQuestion();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase MODE_DEFEND_OUT:\n\t\t\t{\n\t\t\t\tif (s_monsterX < MONSTER_X)\n\t\t\t\t{\n\t\t\t\t\ts_monsterX = MONSTER_X;\n\t\t\t\t\ts_monsterY = FLOOR;\n\t\t\t\t\ts_mode = MODE_INPUT;\n\t\t\t\t\ts_monsterVelocityX = 0.0f;\n\t\t\t\t\ts_monsterVelocityY = 0.0f;\n\t\t\t\t\t\n\t\t\t\t\tRetryQuestion();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t}\n\t\t\n\t\tDuckGui_DefaultUpdate(self, parentX, parentY);\n\t}\n\t\n\tvoid GameRender(duck_gui* self, float parentX, float parentY)\n\t{\n\t\tif (DuckSpriteSheet_Loaded(s_spriteSheet) && DuckFont_Loaded(s_font))\n\t\t{\n\t\t\tduck_sprite* sprite;\n\t\t\tfloat renderX;\n\t\t\tfloat renderY;\n\t\t\t\n\t\t\tsprite = DuckSprite_Get(\"Background\");\n\t\t\t\trenderX = floor((Duck_GetScreenWidth() - DuckSprite_GetWidth(sprite)) / 2);\n\t\t\t\trenderY = floor((Duck_GetScreenHeight() - DuckSprite_GetHeight(sprite)) / 2);\n\t\t\t\tDuckSprite_Render(sprite, renderX, renderY, false, 0.0f);\n\t\t\t\n\t\t\tuint32_t frame = s_timer / 10 % 3;\n\t\t\tswitch (frame)\n\t\t\t{\n\t\t\t\tcase 0: sprite = DuckSprite_Get(\"Chrono0\"); break;\n\t\t\t\tcase 1: sprite = DuckSprite_Get(\"Chrono1\"); break;\n\t\t\t\tcase 2: sprite = DuckSprite_Get(\"Chrono2\"); break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t\t\t\n\t\t\t\trenderX = s_playerX - floor(DuckSprite_GetWidth(sprite) / 2);\n\t\t\t\trenderY = s_playerY - floor(DuckSprite_GetHeight(sprite) / 2);\n\t\t\t\tDuckSprite_Render(sprite, renderX, renderY, false, 0.0f);\n\t\t\n\n\n\t\t\tframe = s_timer / 10 % 3;\n\t\t\tswitch (frame)\n\t\t\t{\n\t\t\t\tcase 0: sprite = DuckSprite_Get(\"Skeleton0\"); break;\n\t\t\t\tcase 1: sprite = DuckSprite_Get(\"Skeleton1\"); break;\n\t\t\t\tcase 2: sprite = DuckSprite_Get(\"Skeleton2\"); break;\n\t\t\t\tdefault: assert(false);\n\t\t\t}\n\t\t\t\t\n\t\t\t\trenderX = s_monsterX - floor(DuckSprite_GetWidth(sprite) / 2);\n\t\t\t\trenderY = s_monsterY - floor(DuckSprite_GetHeight(sprite) / 2);\n\t\t\t\tDuckSprite_Render(sprite, renderX, renderY, true, 0.0f);\n\t\t\n\t\t\n\t\t\tfloat r;\n\t\t\tfloat g;\n\t\t\tfloat b;\n\t\t\tswitch (s_mode)\n\t\t\t{\n\t\t\t\tcase MODE_INPUT:\n\t\t\t\t{\n\t\t\t\t\tr = 0.2f;\n\t\t\t\t\tg = 0.2f;\n\t\t\t\t\tb = 1.0f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tcase MODE_ATTACK_IN:\n\t\t\t\tcase MODE_ATTACK_OUT:\n\t\t\t\t{\n\t\t\t\t\tr = 0.0f;\n\t\t\t\t\tg = 1.0f;\n\t\t\t\t\tb = 0.0f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcase MODE_DEFEND_IN:\n\t\t\t\tcase MODE_DEFEND_OUT:\n\t\t\t\t{\n\t\t\t\t\tr = 1.0f;\n\t\t\t\t\tg = 0.0f;\n\t\t\t\t\tb = 0.0f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tassert(false);\n\t\t\t}\n\t\t\n\t\t\tduck_font_string* fontString = DuckFontString_Create(s_font, DuckString_GetCString(questionArray[questionOffset]), 90, 0.0f, 0.0f, 0.0f);\n\t\t\t\trenderX = floor((Duck_GetScreenWidth() - DuckFontString_GetWidth(fontString)) / 2);\n\t\t\t\trenderY = 100.0f;\n\t\t\t\tDuckFontString_Render(fontString, renderX+2.0f, renderY+2.0f, false, 0.0f, 0.0f, 0.0f, 0.0f);\n\t\t\t\tDuckFontString_Render(fontString, renderX, renderY, false, 0.0f, r, g, b);\n\t\t\tDuckFontString_Destroy(fontString);\n\n\t\t\tif (s_mode == MODE_DEFEND_IN || s_mode == MODE_DEFEND_OUT)\n\t\t\t\tfontString = DuckFontString_Create(s_font, DuckString_GetCString(answerArray[questionOffset]), 40, 0.0f, 0.0f, 0.0f);\n\t\t\telse\n\t\t\t\tfontString = DuckFontString_Create(s_font, DuckString_GetCString(input), 40, 0.0f, 0.0f, 0.0f);\n\t\t\trenderX = floor((Duck_GetScreenWidth() - DuckFontString_GetWidth(fontString)) / 2);\n\t\t\trenderY = 200.0f;\n\t\t\tDuckFontString_Render(fontString, renderX+2.0f, renderY+2.0f, false, 0.0f, 0.0f, 0.0f, 0.0f);\n\t\t\tDuckFontString_Render(fontString, renderX, renderY, false, 0.0f, r, g, b);\n\t\t\tDuckFontString_Destroy(fontString);\n\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tDuckGui_DefaultRender(self, parentX, parentY);\n\t}\n\n\n\tint main(int argc, const char* argv[])\n\t{\n\t\tDuck_Startup(); // always call this first\n\t\n\n\t\t// here we create a gui that will be the base for our game\n\t\tduck_gui* game = DuckGui_Create(DuckGui_GetRootGui());\n\t\t\tgame->update = &GameUpdate;\n\t\t\tgame->render = &GameRender;\n\t\t\t\n\t\t//const duck_file* file = DuckFile_Open(\"Resource/sheet.txt\");\n\t\t\n\t\tsrand(time(NULL));\n\t\t\n\t\ts_spriteSheet = DuckSpriteSheet_Create(\"sheet\");\n\t\ts_font = DuckFont_Create(\"nukamiso_2004_beta08\"); // nukamiso_2004_beta08.ttf\n\t\tinput = DuckString_Create(\"\");\n\t\t\n\t\t\n\t\tnumQuestion = sizeof(hiragana)/sizeof(char*)/2;\n\t\tquestionArray = (duck_string**)Duck_Malloc(sizeof(duck_string*)*numQuestion);\n\t\tanswerArray = (duck_string**)Duck_Malloc(sizeof(duck_string*)*numQuestion);\n\t\tuint32_t i;\n\t\tfor (i = 0; i < numQuestion; i++)\n\t\t{\n\t\t\tquestionArray[i] = DuckString_Create(hiragana[i*2]);\n\t\t\tanswerArray[i] = DuckString_Create(hiragana[i*2+1]);\n\t\t}\n\t\n\t\tquestionOffset = 0;\n\t\tShuffle(0);\n\t\t\n\t\t// start the main game loop, this will run continuously\n\t\t// untill we call duck_end();\n\t\tDuck_Begin();\n\t\t\n\t\t// duck_end() has been called, time to clean everything up\n\t//\tDuckGui_Destroy(game);\n\t\t\n\t\t//DuckFile_Close(file);\n\t\t\n\t\tfor (i = 0; i < numQuestion; i++)\n\t\t{\n\t\t\tDuckString_Destroy(questionArray[i]);\n\t\t\tDuckString_Destroy(answerArray[i]);\n\t\t}\n\t\t\n\t\tDuck_Free(questionArray);\n\t\tDuck_Free(answerArray);\n\t\t\n\t\tDuckString_Destroy(input);\n\n\t\tDuckFont_Destroy(s_font);\n\t\tDuckSpriteSheet_Destroy(s_spriteSheet);\n\t\t\n\t\t\n\t\t\n\t\tDuck_Shutdown(); // always call this last\n\t\treturn 0;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n//#include <OpenGL/glu.h> // mac\n\n/*#ifdef _WIN64\n   //define something for Windows (64-bit)\n#elif _WIN32\n   //define something for Windows (32-bit)\n#elif __APPLE__\n    #include \"TargetConditionals.h\"\n    #if TARGET_IPHONE_SIMULATOR\n         // iOS Simulator\n    #elif TARGET_OS_IPHONE\n        // iOS device\n    #elif TARGET_OS_MAC\n        // Other kinds of Mac OS\n    #else\n        // Unsupported platform\n    #endif\n#elif __linux\n    // linux\n#elif __unix // all unices not caught above\n    // Unix\n#elif __posix\n    // POSIX\n#endif*/\n\n\nstatic int s_lastTime = 0;\nstatic int s_deltaCount = 0;\nstatic int s_deltaSum = 0;\nstatic int s_frameDeltaBuffer = 0;\nstatic bool s_screenDirty = true;\n\n\nstatic float s_screenWidth = 320.0f; // 960\nstatic float s_screenHeight = 480.0f; // 480\n\nstatic const int FRAME_TIME = 33;\n\n\nstatic SDL_Window* s_window;\n\n\n\n\nint Duck_Startup()\n{\n\tDuckMemory_Startup();\n\t\n\t/*int result = glfwInit();\n\tassert(result);\n\n\t//glfwOpenWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\t//glfwOpenWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MAJOR, 2);\n\tglfwOpenWindowHint(GLFW_OPENGL_VERSION_MINOR, 0);\n\t\t\n\tresult = glfwOpenWindow(s_screenWidth, s_screenHeight, 8, 8, 8, 0, 0, 0, GLFW_WINDOW);\n\tassert(result); // you are probably running an intel card that cannot do opengl 3\n\t\n\tglewExperimental = GL_TRUE;\n\tGLenum glResult = glewInit();\n\tassert(glResult == GLEW_OK);*/\n\n\t\t\n\tint result = SDL_Init(SDL_INIT_VIDEO);\n\t//printf(\"SDL could not initialize! SDL Error: %d %s\\n\", result, SDL_GetError());\n\tassert(!result);\n\t\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n\tSDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);\n\t\n\ts_window = SDL_CreateWindow(\"Hello World!\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, s_screenWidth, s_screenHeight, SDL_WINDOW_OPENGL);\n\tassert(s_window);\n\t\n\t\n\t\n\tSDL_GLContext context = SDL_GL_CreateContext(s_window);\n\tassert(context);\n\t\n\tresult = SDL_GL_SetSwapInterval(1); // vsync\n\tassert(!result);\n\t\n\tglewExperimental = GL_TRUE;\n\tGLenum err = glewInit();\n\tassert(err == GLEW_OK);\n\t\t\n\t\t\n//\tglClearColor(0.0f, 0.0f, 0.4f, 0.0f);\n\n//\tglEnable(GL_BLEND);\n//\tglBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);\n\t\n\t\n\tglClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\t\t// Re-clear the screen for real rendering\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\tglDepthMask(GL_FALSE);\n\t\tglEnable(GL_BLEND);\n\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n\t\n\t\n\n\t// Enable depth test\n\tglDisable(GL_DEPTH_TEST);\n\t// Accept fragment if it closer to the camera than the former one\n\t//glDepthFunc(GL_LESS); \n\t\t\n\n\n//\tprintf(\"Version: %s\\n\", glGetString(GL_VERSION));\n\t\n\t//printf(\"Version: %s\\n\", glGetString(GL_SHADING_LANGUAGE_VERSION));\n//\t\n\n\tDuckFile_Startup();\n\tDuckTexture_Startup();\n\t//DuckMatrix_Startup();\n\tDuckSprite_Startup();\n\tDuckSpriteSheet_Startup();\n\tDuckFont_Startup();\n\tDuckFontString_Startup();\n\tDuckInput_Startup();\n\tDuckGui_Startup();\n\n\treturn 1;\n}\n\nvoid Duck_MainLoop()\n{\n\t//glfwPollEvents();\n\t//int nCurrentTime = (int)(glfwGetTime() * 1000);\n\n\tunsigned int currentTime = SDL_GetTicks();\n\t\n\t\n\tint nDelta = currentTime - s_lastTime;\n\n\t//Update(nDelta);\n\ts_deltaCount++;\n\ts_deltaSum += nDelta;\n\n\tif (s_deltaSum > 30000)\n\t{\n\t\tprintf(\"nDt: %f\\n\", (float)(s_deltaSum) / (float)(s_deltaCount));\n\t\ts_deltaCount = 0;\n\t\ts_deltaSum = 0;\n\t}\n\n\n\tSDL_Event event;\n\twhile(SDL_PollEvent(&event) != 0)\n\t{\n\t\tDuckInput_Event(&event);\n\t\tif (event.type == SDL_WINDOWEVENT)\n\t\t\tif (event.window.event == SDL_WINDOWEVENT_CLOSE)\n\t\t\t\treturn;\n\t}\n\n\ts_frameDeltaBuffer += nDelta;\n\tif (s_frameDeltaBuffer > 2000)\n\t\ts_frameDeltaBuffer = 2000;\n\twhile (s_frameDeltaBuffer > FRAME_TIME)\n\t{\n\t\tDuckFile_Update();\n\t\tDuckTexture_Update();\n\t\tDuckSpriteSheet_Update();\n\t\tDuckFont_Update();\n\t\tDuckGui_Update();\n\n//\t\tm_pGuiManager->Update();\n\t\ts_frameDeltaBuffer -= FRAME_TIME;\n\t\ts_screenDirty = true;\n\n//\t\tInputManager::Update();\n\t}\n\n\ts_lastTime = currentTime;\n\t\n\tif (s_screenDirty)\n\t{\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t\tDuckGui_Render();\n//\t\tm_pGuiManager->Render();\n\t\ts_screenDirty = false;\n\t\t//glfwSwapBuffers();\n\t\tSDL_GL_SwapWindow(s_window);\n\t}\n}\n\nvoid Duck_Begin()\n{\n\t//int lastTime = int(glfwGetTime() * 1000);\n\n\t#ifdef EMSCRIPTEN\n\t\temscripten_set_main_loop(Duck_MainLoop, 0, true);\n\t#else\n\t\twhile (true)\n\t\t{\n\t\t\t\n\t\t\t//if (!glfwGetWindowParam(GLFW_OPENED))\n\t\t\t//\tbreak;\n\t\t\tDuck_MainLoop();\n\t\t}\n\t#endif\n}\n\nvoid Duck_End()\n{\n}\n\nvoid Duck_Shutdown()\n{\n\tDuckGui_Shutdown();\n\tDuckInput_Shutdown();\n\tDuckFontString_Shutdown();\n\tDuckFont_Shutdown();\n\tDuckSpriteSheet_Shutdown();\n\tDuckSprite_Shutdown();\n\t//DuckMatrix_Shutdown();\n\tDuckTexture_Shutdown();\n\tDuckFile_Shutdown();\n\t\n\t//xglfwTerminate();\n\t\n    SDL_Quit();\n    \n    DuckMemory_Shutdown();\n}\n\n\nfloat Duck_GetScreenWidth()\n{\n\treturn s_screenWidth;\n}\n\nfloat Duck_GetScreenHeight()\n{\n\treturn s_screenHeight;\n}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\tstruct duck_file\n\t{\n\t\tduck_file* previous;\n\t\tduck_file* next;\n\t\t\n\t\tduck_string* fileName;\n\t\tFILE* fileStream;\n\t\t\n\t\tbool loaded;\n\t\tunsigned long size;\n\t\tvoid* data;\n\t};\n\n\tstatic duck_file* s_fileList = NULL;\n\t\n\tvoid DuckFile_Startup()\n\t{\n\t}\n\t\n\tvoid DuckFile_Shutdown()\n\t{\n\t\tassert(!s_fileList); // you have not closed all open files\n\t}\n\t\n\tvoid DuckFile_Update()\n\t{\n\t\t#if !defined(EMSCRIPTEN)\n\t\t\tduck_file* file = s_fileList;\n\t\t\twhile (file)\n\t\t\t{\n\t\t\t\tif (!file->loaded)\n\t\t\t\t{\n\t\t\t\t\t// do cool things\n\t\t\t\t\tfile->fileStream = fopen(DuckString_GetCString(file->fileName), \"rb\");\n\t\t\t\t\tif (file->fileStream)\n\t\t\t\t\t{\n\t\t\t\t\t\tfseek(file->fileStream, 0, SEEK_END);\n\t\t\t\t\t\tfile->size = ftell(file->fileStream);\n\t\t\t\t\t\tfseek(file->fileStream, 0, SEEK_SET);\n\t\t\t\t\t\tfile->data = Duck_Malloc(file->size);\n\n\t\t\t\t\t\tfread(file->data, file->size, 1, file->fileStream);\n\n\t\t\t\t\t\tfclose(file->fileStream);\n\t\t\t\t\t}\n\t\t\t\t\tfile->loaded = true;\n\t\t\t\t}\n\t\t\t\tfile = file->next;\n\t\t\t}\n\t\t#endif\n\t}\n\n\n\t#if defined(EMSCRIPTEN)\n\t\tvoid OnComplete(void* userPointer, void* data, int dataSize)\n\t\t{\n\t\t\t//printf(\"FILE LOAD\\n\");\n\t\t\tduck_file* file = (duck_file*)userPointer;\n\n\t\t\tfile->size = dataSize;\n\t\t\tfile->data = Duck_Malloc(file->size);\n\t\t\tmemcpy(file->data, data, file->size);\n\n\t\t\tfile->loaded = true;\n\t\t}\n\n\t\tvoid OnError(void* userPointer)\n\t\t{\n\t\t\tduck_file* file = (duck_file*)userPointer;\n\t\t\tprintf(\"FILE LOAD ERROR! %s\\n\", DuckString_GetCString(file->fileName));\n\n\t\t\tfile->loaded = true;\n\t\t}\n\t#endif\n\n\n/* Public Functionality */\n\tduck_file* DuckFile_Open(const char* fileName)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_file, s_fileList, file);\n\t\t\n\t\t//temp->file = (duck_file*)Duck_Malloc(sizeof(duck_file));\n\t\t//temp->file->data = NULL;\n\t\tfile->fileName = DuckString_Create(fileName);\n\t\t//temp->fileStream = NULL;\n\n\t\t#if defined(EMSCRIPTEN)\n\t\t\tduck_string* temp = DuckString_Create(\"\"); //\"http://localhost:8082/Resource/\");\n\t\t\tDuckString_AppendString(temp, file->fileName);\n\t\t\temscripten_async_wget_data(DuckString_GetCString(temp), file, OnComplete, OnError);\n\t\t\tDuckString_Destroy(temp);\n\t\t#endif\n\t\t\n\t\treturn file;\n\t}\n\t\n\tvoid DuckFile_Close(duck_file* file)\n\t{\t\n\t\t//DUCK_LINKED_LIST_FIND(duck_file, s_fileList, file, temp);\n\t\t//assert(temp); // tried to close non existant file\n\t\t\n\t\tDuck_Free(file->data);\n\t\tDuckString_Destroy(file->fileName);\n\t\t\n\t\tDUCK_LINKED_LIST_FREE2(s_fileList, file);\n\t}\n\t\n\tbool DuckFile_Loaded(duck_file* file)\n\t{\n\t\treturn file->loaded;\n\t}\n\t\n\tunsigned long DuckFile_GetSize(duck_file* file)\n\t{\n\t\treturn file->size;\n\t}\n\t\n\tconst void* DuckFile_GetData(duck_file* file)\n\t{\n\t\treturn file->data;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n\n\n/* Secret Squirrel Stuff */\n\tstruct duck_font\n\t{\n\t\tduck_font* previous;\n\t\tduck_font* next;\n\n\t\tbool loaded;\n\t\tduck_file* file;\n\t\tstbtt_fontinfo fontInfo;\n\t};\n\t\n\tstatic duck_font* s_fontList = NULL;\n\t\n\tvoid DuckFont_Startup()\n\t{\n\t}\n\t\n\tvoid DuckFont_Shutdown()\n\t{\n\t\tassert(!s_fontList); // you have not unloaded all fonts!\n\t}\n\t\n\tvoid DuckFont_Update()\n\t{\n\t\tduck_font* font = s_fontList;\n\t\twhile (font)\n\t\t{\n\t\t\tif (!font->loaded)\n\t\t\t{\n\t\t\t\tif (DuckFile_Loaded(font->file))\n\t\t\t\t{\n\t\t\t\t\tstbtt_InitFont(&font->fontInfo, DuckFile_GetData(font->file), 0);\n\t\t\t\t\tfont->loaded = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfont = font->next;\n\t\t}\n\t}\n\t\n\tstbtt_fontinfo* DuckFont_GetFontInfo(duck_font* font)\n\t{\n\t\treturn &font->fontInfo;\n\t}\n\t\n\t\n\t\t\n/* Public Functionality */\n\tduck_font* DuckFont_Create(const char* name)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_font, s_fontList, font);\n\t\t\n\t\tfont->loaded = false;\n\t\t\n\t\tduck_string* path = DuckString_Create(\"../Resource/\");\n\t\tDuckString_AppendCString(path, name);\n\t\tDuckString_AppendCString(path, \".ttf\");\n\t\t\tfont->file = DuckFile_Open(DuckString_GetCString(path));\n\t\tDuckString_Destroy(path);\n\t\t\n\t\treturn font;\n\t}\n\n\tvoid DuckFont_Destroy(duck_font* font)\n\t{\n\t\t//DUCK_LINKED_LIST_FIND2(duck_font, s_fontList, font, found);\n\t\t//assert(found);\n\n\t\tDuckFile_Close(font->file);\n\t\t\n\t\tDUCK_LINKED_LIST_FREE2(s_fontList, font);\n\t}\n\t\n\tbool DuckFont_Loaded(duck_font* font)\n\t{\n\t\treturn font->loaded;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n#include \"utf8proc/utf8proc.h\"\n\n/* Secret Squirrel Stuff */\n\tstruct duck_font_string\n\t{\n\t\tduck_font_string* previous;\n\t\tduck_font_string* next;\n\t\t\n\t\tduck_texture* texture;\n\t\tduck_sprite* sprite;\n\t};\n\t\n\tstatic duck_font_string* s_fontStringList = NULL;\n\t\n\t\n\tstatic GLuint s_program;\n\tstatic GLuint s_matrixUniform;\n\tstatic GLuint s_textureUniform;\n\tstatic GLuint s_colourUniform;\n\t\n\t\n\tstatic GLuint s_vertexArray;\n \tstatic GLuint s_textureArray;\n\t\n\tvoid DuckFontString_Startup()\n\t{\n\t\tconst char* vertexSource =\n\t\t\t#if defined(EMSCRIPTEN)\n\t\t\t\t\"#version 100\\n\"\n\t\t\t\t\"precision mediump float;\\n\"\n\t\t\t#endif\n\t\t\t\"attribute vec3 vertexPosition_modelspace;\\n\"\n\t\t\t\"attribute vec2 vertexUV;\\n\"\n\t\t\t\"varying vec2 UV;\\n\"\n\t\t\t\"uniform mat4 MVP;\\n\"\n\t\t\t\"void main()\\n\"\n\t\t\t\"{\\n\"\n\t\t\t\"\tgl_Position =  MVP * vec4(vertexPosition_modelspace,1);\\n\"\n\t\t\t\"\tUV = vertexUV;\\n\"\n\t\t\t\"}\";\n\n\t\tconst char* fragmentSource =\n\t\t\t#if defined(EMSCRIPTEN)\n\t\t\t\t\"#version 100\\n\"\n\t\t\t\t\"precision mediump float;\\n\"\n\t\t\t#endif\n\t\t\t\"varying  vec2 UV;\\n\"\n\t\t\t\"uniform sampler2D myTextureSampler;\\n\"\n\t\t\t\"uniform vec3 xColour;\\n\"\n\t\t\t\"void main()\\n\"\n\t\t\t\"{\\n\"\n\t\t\t\"\tgl_FragColor.rgb = xColour.rgb;\\n\"\n\t\t\t\"\tgl_FragColor.a = texture2D(myTextureSampler, UV).a;\\n\"\n\t\t\t\"}\";\n\t\t\t\n\t\ts_program = DuckShader_LoadProgram(vertexSource, fragmentSource);\n\t\ts_matrixUniform = glGetUniformLocation(s_program, \"MVP\");\n\t\ts_textureUniform = glGetUniformLocation(s_program, \"myTextureSampler\");\n\t\ts_colourUniform = glGetUniformLocation(s_program, \"xColour\");\n\t\t\n\t\ts_vertexArray = glGetAttribLocation(s_program, \"vertexPosition_modelspace\");\n \t\ts_textureArray = glGetAttribLocation(s_program, \"vertexUV\");\n\t}\n\t\n\tvoid DuckFontString_Shutdown()\n\t{\n\t\tassert(!s_fontStringList);\n\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tint NextPowerOf2(int n)\n{\n\tif (n == 0)\n\t\treturn 32;\n\tif ((n & (n - 1)) != 0)\n\t{\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 1);\n\t\t++n;\n\t}\n\treturn n;\n}\n\t\t\n\t\t\n\t\t\n/* Public Functionality */\n\tduck_font_string* DuckFontString_Create(duck_font* font, const char* string, float fontHeight, float indent, float wrapWidth, float maxHeight)\n\t{\n\t\tassert(DuckFont_Loaded(font));\n\t\t\n\t\tDUCK_LINKED_LIST_ADD2(duck_font_string, s_fontStringList, fontString);\n\t\t\n\t\t\n\t\t\n\t\t// things\n\t\tint nAscent,baseline=0;\n\n\t\tint nDescent = 0;\n\t\tint nLineGap = 0;\n\n\t\tfloat scale;\n\t\tfloat xpos = indent;\n\t\tfloat ypos = 0.0f;\n\n\t\tscale = stbtt_ScaleForPixelHeight(DuckFont_GetFontInfo(font), fontHeight);\n\t\tstbtt_GetFontVMetrics(DuckFont_GetFontInfo(font), &nAscent, &nDescent, &nLineGap);\n\t\tbaseline = (int) (nAscent*scale);\n\n\t\tfloat fLineHeight = (nAscent - nDescent + nLineGap)*scale;\n\n\t\t//int *ascent, int *descent, int *lineGap\n\n\t\ttypedef struct Glyph Glyph;\n\t\tstruct Glyph\n\t\t{\n\t\t\tint nGlyphIndex;\n\t\t\tint nAdvanceWidth;\n\t\t\tint nLeftSideBearing;\n\t\t\tfloat fShiftX;\n\t\t\tfloat fX;\n\t\t\tfloat fY;\n\t\t\tint x0,y0,x1,y1;\n\n\t\t\tint32_t codePoint;\n\t\t};\n\t\t\n\n\t\tint numGlyph = 0;\n\t\tssize_t byteLength = strlen(string);\n\t\tssize_t byteOffset = 0;\n\n\t\tfloat fMaxX = 0.0f;\n\t\tGlyph* pGlyphArray = (Glyph*)Duck_Malloc(sizeof(Glyph) * strlen(string));\n\t\tGlyph* p = pGlyphArray;\n\t\t\n\t\tfloat fWordWidth = 0.0f;\n\t\tint wordWidthIndex = 0;\n\t\tfloat fWordWidthArray[100];\n\t\t\n\t\twhile (byteOffset < byteLength)\n\t\t{\n\t\t\tssize_t readSize = utf8proc_iterate((const uint8_t*)string + byteOffset, byteLength, &p->codePoint);\n\t\t\tif (readSize <= 0)\n\t\t\t\tbreak;\n\n\t\t\tbyteOffset += readSize;\n\t\t\tnumGlyph++;\n\n\t\t\tp->nGlyphIndex = stbtt_FindGlyphIndex(DuckFont_GetFontInfo(font), p->codePoint);\n\t\t\tstbtt_GetGlyphHMetrics(DuckFont_GetFontInfo(font), p->nGlyphIndex, &p->nAdvanceWidth, &p->nLeftSideBearing);\n\t\t\tp->fShiftX = xpos - (float) floor(xpos);\n\t\t\tstbtt_GetGlyphBitmapBoxSubpixel(DuckFont_GetFontInfo(font), p->nGlyphIndex, scale, scale, p->fShiftX, 0, &p->x0, &p->y0, &p->x1, &p->y1);\n\n\t\t\tif (p->x0 == p->x1 || p->y0 == p->y1)\n\t\t\t{\n\t\t\t\tfWordWidthArray[wordWidthIndex] = fWordWidth;\n\t\t\t\twordWidthIndex++;\n\t\t\t\tassert(wordWidthIndex < 100);\n\t\t\t\t\n\t\t\t\tfWordWidth = 0.0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfWordWidth += p->nAdvanceWidth * scale;\n\t\t\t}\n\n\t\t\txpos += (p->nAdvanceWidth * scale);\n\t\t\tp++;\n\n\t\t}\n\n\t\tfWordWidthArray[wordWidthIndex] = fWordWidth;\n\t\twordWidthIndex++;\n\t\tassert(wordWidthIndex < 100);\n\n\t\tint nWordIndex = 0;\n\t\txpos = indent;\n\t\tp = pGlyphArray;\n\t\t\n\t\tint i;\n\t\tfor (i = 0; i < numGlyph; i++)\n\t\t{\n\t\t\tif (wrapWidth > 0.0f)\n\t\t\t{\n\t\t\t\tif (p->x0 == p->x1 || p->y0 == p->y1)\n\t\t\t\t{\n\t\t\t\t\tnWordIndex++;\n\t\t\t\t\tif (xpos > 0.0f && xpos + fWordWidthArray[nWordIndex] > wrapWidth)\n\t\t\t\t\t{\n\t\t\t\t\t\txpos = 0.0f;\n\t\t\t\t\t\typos += (float)fLineHeight;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp->fX = xpos;\n\t\t\tp->fY = ypos;// + baseline;\n\t\t\txpos += (p->nAdvanceWidth * scale);\n\n\t\t\tif (xpos > fMaxX)\n\t\t\t\tfMaxX = xpos;\n\t\t\tp++;\n\t\t}\n\n\t\tif (xpos > fMaxX)\n\t\t\tfMaxX = xpos;\n\t\typos += fLineHeight;\n\n\t\t/*\n\t\tstruct duck_font_string\n\t\t\t{\n\t\t\t\tduck_font_string* previous;\n\t\t\t\tduck_font_string* next;\n\t\t\t\t\n\t\t\t\tduck_texture* texture;\n\t\t\t\tfloat width;\n\t\t\t\tfloat height;\n\t\t\t};\n\t\t\t*/\n\n\n\t\tfloat width = ceil(fMaxX);\n\t\tfloat height = ceil(ypos);\n\n\t\t//Uint32 nWidth = int(ceil(fMaxX));\n\t\t//Uint32 nHeight = int(ceil(ypos));\n\n\t\tint nBufferWidth = NextPowerOf2((int)width);\n\t\tint nBufferHeight = NextPowerOf2((int)height);\n\t\t\n//\t\tprintf(\"%f x %f - %d x %d\\n\", width, height, nBufferWidth, nBufferHeight);\n\n//\t\tpCachedString->pMesh = Video::MeshCreateQuad(0.0f, 0.0f, pCachedString->fWidth, pCachedString->fHeight, float(nBufferWidth), float(nBufferHeight), 0.0f, 0.0f, pCachedString->fWidth, pCachedString->fHeight);\n\n\t\tunsigned char* imageData = (unsigned char*)Duck_Malloc(nBufferWidth*nBufferHeight);\n\t\tmemset(imageData, 0, nBufferWidth*nBufferHeight);\n\n\t\tp = pGlyphArray;\n\t\tfor (i = 0; i < numGlyph; i++)\n\t\t{\n\t\t\tstbtt_MakeGlyphBitmapSubpixel(DuckFont_GetFontInfo(font), (imageData + (Uint32)(baseline + p->fY + p->y0)*nBufferWidth + (Uint32)(p->fX + p->x0)), p->x1-p->x0, p->y1-p->y0, nBufferWidth, scale, scale, p->fShiftX, 0, p->nGlyphIndex);\n\t\t\t// todo: render to a 2nd buffer then blend into full texture\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tDuck_Free(pGlyphArray);\n\n\n\t\t/*glGenTextures(1, &pCachedString->nTexture);\n\t\tglBindTexture(GL_TEXTURE_2D, pCachedString->nTexture);\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, nBufferWidth, nBufferHeight, 0, GL_ALPHA, GL_UNSIGNED_BYTE, imageData);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);*/\n\t\t\n\t\tfontString->texture = DuckTexture_CreateFromMemory(nBufferWidth, nBufferHeight, GL_ALPHA, imageData);\n\t\t\n\t\tfontString->sprite = DuckSprite_Create(fontString->texture, \"\", 0.0f, 0.0f, width, height, 0.0f, 0.0f, width, height);\n\t\t\n\t\tDuck_Free(imageData);\n\n\t\t\n\t\t\n\t\t\n\t\treturn fontString;\n\t}\n\t\n\tvoid DuckFontString_Destroy(duck_font_string* fontString)\n\t{\n\t\tDuckSprite_Destroy(fontString->sprite);\n\t\tDuckTexture_Destroy(fontString->texture);\n\t\t\n\t\tDUCK_LINKED_LIST_FREE2(s_fontStringList, fontString);\n\t}\n\t\n\tvoid DuckFontString_Render(duck_font_string* fontString, float x, float y, bool flipped, float angle, float red, float green, float blue)\n\t{\n\t\tassert(fontString);\n\t\t\n\t\tfloat matrix[16];\n\t\tDuckSprite_PrepareMatrix(fontString->sprite, matrix, x, y, flipped, angle);\n\t\t\n\t\tglUseProgram(s_program);\n\t\tglUniformMatrix4fv(s_matrixUniform, 1, GL_FALSE, matrix);\n\t\t\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D, DuckSprite_GetTextureId(fontString->sprite));\n\t\tglUniform1i(s_textureUniform, 0);\n\t\t\n\t\tglUniform3f(s_colourUniform, red, green, blue);\n\n\t\tglEnableVertexAttribArray(s_vertexArray);\n\t\tglBindBuffer(GL_ARRAY_BUFFER,  DuckSprite_GetVertexBufferId(fontString->sprite));\n\t\tglVertexAttribPointer(s_vertexArray, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n\n\t\tglEnableVertexAttribArray(s_textureArray);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, DuckSprite_GetUvBufferId(fontString->sprite));\n\t\tglVertexAttribPointer(s_textureArray, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);\n\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, DuckSprite_GetIndexBufferId(fontString->sprite));\n\t\tglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)0);\n\t\t\n\t\tglDisableVertexAttribArray(s_textureArray);\n\t\tglDisableVertexAttribArray(s_vertexArray);\n\t\tglUseProgram(0);\n\t}\n\t\n\t\n\tfloat DuckFontString_GetWidth(duck_font_string* fontString)\n\t{\n\t\treturn DuckSprite_GetWidth(fontString->sprite);\n\t}\n\t\n\tfloat DuckFontString_GetHeight(duck_font_string* fontString)\n\t{\n\t\treturn DuckSprite_GetHeight(fontString->sprite);\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\tstatic duck_gui* s_rootGui = NULL;\n\tstatic duck_gui* s_focusGui = NULL;\n\t\n\tvoid DuckGui_Startup()\n\t{\n\t\ts_rootGui = DuckGui_Create(NULL);\n\t}\n\t\n\tvoid DuckGui_Shutdown()\n\t{\n\t\tDuckGui_Destroy(s_rootGui);\n\t}\n\t\n\tvoid DuckGui_Update()\n\t{\n\t\ts_rootGui->update(s_rootGui, 0.0f, 0.0f);\n\t}\n\t\n\tvoid DuckGui_Render()\n\t{\n\t\ts_rootGui->render(s_rootGui, 0.0f, 0.0f);\n\t}\n\t\n\n\n\n/* Functions */\n\tduck_gui* DuckGui_Create(duck_gui* parent)\n\t{\n\t\tduck_gui* gui = (duck_gui*)Duck_Malloc(sizeof(duck_gui));\n\t\t\tmemset(gui, 0, sizeof(duck_gui));\n\t\t\tgui->update = &DuckGui_DefaultUpdate;\n\t\t\tgui->render = &DuckGui_DefaultRender;\n\t\t\tgui->addChild = &DuckGui_DefaultAddChild;\n\t\t\tgui->removeChild = &DuckGui_DefaultRemoveChild;\n\t\t\n\t\tif (parent)\n\t\t\tparent->addChild(parent, gui);\n\t\t\n\t\treturn gui;\n\t}\n\n\tvoid DuckGui_Destroy(duck_gui* gui)\n\t{\n\t\tduck_gui_child* child = gui->childList;\n\t\twhile (child)\n\t\t{\n\t\t\tduck_gui_child* temp = child;\n\t\t\tchild = child->next;\n\t\t\tDuckGui_Destroy(temp->child);\n\t\t\tDUCK_LINKED_LIST_FREE(temp);\n\t\t}\n\t\tgui->childList = NULL;\n\t\t\n\t\tDuck_Free(gui);\n\t}\n\n\n\tduck_gui* DuckGui_GetRootGui()\n\t{\n\t\treturn s_rootGui;\n\t}\n\t\n\tduck_gui* DuckGui_GetFocusGui()\n\t{\n\t\treturn s_focusGui;\n\t}\n\t\n\tvoid DuckGui_SetFocusGui(duck_gui* focusGui)\n\t{\n\t\ts_focusGui = focusGui;\n\t}\n\n\t\n\n// Default Functions\n\tvoid DuckGui_DefaultUpdate(duck_gui* self, float x, float y)\n\t{\n\t\tduck_gui_child* child = self->childList;\n\t\twhile (child)\n\t\t{\n\t\t\tchild->child->update(child->child, x + self->x, y + self->y);\n\t\t\tchild = child->next;\n\t\t}\n\t}\n\n\tvoid DuckGui_DefaultRender(duck_gui* self, float x, float y)\n\t{\n\t\tduck_gui_child* child = self->childList;\n\t\twhile (child)\n\t\t{\n\t\t\tchild->child->render(child->child, x + self->x, y + self->y);\n\t\t\tchild = child->next;\n\t\t}\n\t}\n\t\n\tvoid DuckGui_DefaultAddChild(duck_gui* self, duck_gui* child)\n\t{\n\t\tDUCK_LINKED_LIST_ADD(duck_gui_child, self->childList, temp);\n\t\ttemp->child = child;\n\t}\n\t\n\tvoid DuckGui_DefaultRemoveChild(duck_gui* self, duck_gui* child)\n\t{\n\t\tDUCK_LINKED_LIST_FIND(duck_gui_child, self->childList, child, temp);\n\t\tassert(temp); // tried to remove non existant child\n\t\t\n\t\tDUCK_LINKED_LIST_FREE(temp);\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\ttypedef struct duck_key_state duck_key_state;\n\tstruct duck_key_state\n\t{\n\t\tbool down;\n\t\tbool up;\n\t};\n\n\tstatic duck_key_state s_keyState[DUCK_NUM_KEY];\n\t\n\tstatic uint32_t* s_unicodeInputBuffer;\n\tstatic uint32_t s_unicodeInputBufferSize;\n\tstatic uint32_t s_numUnicodeInput;\n\t\n\tstatic float s_mouseX;\n\tstatic float s_mouseY;\n\t\n\t\n\t\n\tvoid DuckInput_Startup()\n\t{\n\t\ts_unicodeInputBufferSize = 128;\n\t\ts_unicodeInputBuffer = Duck_Malloc(sizeof(uint32_t)*s_unicodeInputBufferSize);\n\t\ts_numUnicodeInput = 0;\n\t\t\n\t\ts_mouseX = 0.0f;\n\t\ts_mouseY = 0.0f;\n\t\t\n\t\tuint32_t i;\n\t\tfor (i = 0; i < DUCK_NUM_KEY; i++)\n\t\t{\n\t\t\ts_keyState[i].down = false;\n\t\t\ts_keyState[i].up = true;\n\t\t}\n\t}\n\t\n\tvoid DuckInput_Shutdown()\n\t{\n\t\tDuck_Free(s_unicodeInputBuffer);\n\t}\n\t\n\tvoid DuckInput_Event(SDL_Event* event)\n\t{\n\t\tif(event->type == SDL_KEYDOWN)\n\t\t{\n\t\t\t// TODO: not unicodes!\n\t\t\tconst char* temp = SDL_GetScancodeName(event->key.keysym.sym); //SDL_GetKeyName(event->key.keysym.sym);\n\t\t\t//printf(\"%s\\n\", temp);\n\t\t\tif (temp[0] >= 'A' && temp[0] <= 'Z' && temp[1] == '\\0')\n\t\t\t{\n\t\t\t\tassert(s_numUnicodeInput < s_unicodeInputBufferSize);\n\t\t\t\ts_unicodeInputBuffer[s_numUnicodeInput] = (uint32_t)temp[0];\n\t\t\t\ts_numUnicodeInput++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (event->key.keysym.sym)\n\t\t\t\t{\n\t\t\t\t\tcase SDL_SCANCODE_RETURN:\n\t\t\t\t\tcase SDL_SCANCODE_RETURN2:\n\t\t\t\t\t\ts_keyState[DUCK_KEY_ENTER].down = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(event->type == SDL_KEYUP)\n\t\t{\n\t\t\tswitch (event->key.keysym.sym)\n\t\t\t{\n\t\t\t\tcase SDL_SCANCODE_RETURN:\n\t\t\t\tcase SDL_SCANCODE_RETURN2:\n\t\t\t\t\ts_keyState[DUCK_KEY_ENTER].up = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n/* pubs */\n\tbool DuckInput_GetKeyDown(uint32_t key)\n\t{\n\t\tassert(key < DUCK_NUM_KEY);\n\t\treturn s_keyState[key].down;\n\t}\n\n\tbool DuckInput_GetKeyPressed(uint32_t key)\n\t{\n\t\tassert(key < DUCK_NUM_KEY);\n\t\tif (s_keyState[key].up && s_keyState[key].down)\n\t\t{\n\t\t\ts_keyState[key].up = false;\n\t\t\ts_keyState[key].down = false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tuint32_t DuckInput_GetUnicodeInput()\n\t{\n\t\tuint32_t returnable = 0;\n\t\tif (s_numUnicodeInput > 0)\n\t\t{\n\t\t\treturnable = s_unicodeInputBuffer[0];\n\t\t\ts_numUnicodeInput--;\n\t\t\tmemcpy(s_unicodeInputBuffer, s_unicodeInputBuffer+1, s_numUnicodeInput);\n\t\t}\n\t\treturn returnable;\n\t}\n\t\n\tvoid DuckInput_ClearUnicodeInput()\n\t{\n\t\ts_numUnicodeInput = 0;\n\t}\n\t\n\tfloat DuckInput_GetMouseX()\n\t{\n\t\treturn s_mouseX;\n\t}\n\t\n\tfloat DuckInput_GetMouseY()\n\t{\n\t\treturn s_mouseY;\n\t}\n\t\t\n\t\t\n\t\t\n\t\t/*\n\t\t\n\t\t\n\nvoid OsWrapper :: KeyDown(Key eKey)\n{\n\tm_keyState[eKey].bDown = true;\n}\n\nvoid OsWrapper :: KeyUp(Key eKey)\n{\n\tm_keyState[eKey].bUp = true;\n}\n\nvoid OsWrapper :: CharInput(Uint32 nChar)\n{\n\tm_nCharInputVector.push_back(nChar);\n}\n\nvoid OsWrapper :: MouseMove(float fX, float fY)\n{\n\tm_fMouseX = fX;\n\tm_fMouseY = fY;\n}\n\n*/","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\t/*typedef struct duck_matrix_secret duck_matrix_secret;\n\tstruct duck_matrix_secret\n\t{\n\t\tduck_matrix* matrix;\n\t\tduck_matrix_secret* next;\n\t};\n\t\n\tstatic duck_matrix_secret* s_matrixList = NULL;\n\t\n\tvoid DuckMatrix_Startup()\n\t{\n\t}\n\t\n\tvoid DuckMatrix_Shutdown()\n\t{\n\t\tassert(!s_matrixList); // you have not destroyed all created matrixs\n\t}\n\t\n\tduck_matrix* DuckMatrix_Create()\n\t{\n\t\tDUCK_LINKED_LIST_ADD(duck_matrix_secret, s_matrixList, temp);\n\t\t\n\t\ttemp->matrix = (duck_matrix*)Duck_Malloc(sizeof(duck_matrix));\n\t\t\n\t\treturn temp->matrix;\n\t}\n\t\n\tvoid DuckMatrix_Destroy(duck_matrix* matrix)\n\t{\n\t\tDUCK_LINKED_LIST_FIND(duck_matrix_secret, s_matrixList, matrix, temp);\n\t\tif (!temp)\n\t\t{\n\t\t\tprintf(\"*** Cannot destroy non existant matrix\");\n\t\t\tassert(false);\n\t\t}\n\t\t\n\t\tDuck_Free(temp->matrix);\n\t\t\n\t\tDUCK_LINKED_LIST_FREE(temp);\n\t}*/\n\t\t\n\t#define IDENTITY_MATRIX {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }\n\t\t\n\tvoid DuckMatrix_Multiply(float matrixA[16], const float matrixB[16])\n\t{\n\t\tfloat temp[16] = IDENTITY_MATRIX;\n\t\t\n\n\t\t//temp[0] = matrixA[0] * matrixB[0] + matrixA\n\n\t\t\n\t\t//temp[0] = \n\t\t\n\t\t\n\t\t\n\t\tint row, column, row_offset;\n\n\t\tfor (row = 0, row_offset = row * 4; row < 4; ++row, row_offset = row * 4)\n\t\t\tfor (column = 0; column < 4; ++column)\n\t\t\t\ttemp[row_offset + column] =\n\t\t\t\t\t(matrixA[column + 0] * matrixB[row_offset + 0]) +\n\t\t\t\t\t(matrixA[column + 4] * matrixB[row_offset + 1]) +\n\t\t\t\t\t(matrixA[column + 8] * matrixB[row_offset + 2]) +\n\t\t\t\t\t(matrixA[column + 12] * matrixB[row_offset + 3]);\n\t\t\t\t\t\n\t\tmemcpy(matrixA, temp, sizeof(float)*16);\n\t}\n\t\n\t\n\tvoid DuckMatrix_Ortho(float matrix[16], float left, float right, float top, float bottom, float near, float far)\n\t{\n\t\tfloat temp[16] = IDENTITY_MATRIX;\n\t\tmemcpy(matrix, temp, sizeof(float)*16);\n\n\t\tmatrix[0] = 2.0f / (right - left);\n\t\tmatrix[5] = 2.0f / (top - bottom);\n\t\tmatrix[10] = 2.0f / (far - near);\n\t\tmatrix[12] = - (right + left) / (right - left);\n\t\tmatrix[13] = - (top + bottom) / (top - bottom);\n\t}\n\t\n\tvoid DuckMatrix_Scale(float matrix[16], float x, float y, float z)\n\t{\n\t\tfloat scale[16] = IDENTITY_MATRIX;\n\t\t\n\t\tscale[0] = x;\n\t\tscale[5] = y;\n\t\tscale[10] = z;\n\n\t\tDuckMatrix_Multiply(matrix, scale);\n\t}\n\t\n\tvoid DuckMatrix_Translate(float matrix[16], float x, float y, float z)\n\t{\n\t\tfloat translation[16] = IDENTITY_MATRIX;\n\t\t\n\t\ttranslation[12] = x;\n\t\ttranslation[13] = y;\n\t\ttranslation[14] = z;\n\n\t\tDuckMatrix_Multiply(matrix, translation);\n\t}\n\t\n\tvoid DuckMatrix_RotateZ(float matrix[16], float angle)\n\t{\n\t\tfloat rotation[16] = IDENTITY_MATRIX;\n\t\tfloat sine = (float)sin(angle);\n\t\tfloat cosine = (float)cos(angle);\n\n\t\trotation[0] = cosine;\n\t\trotation[1] = -sine;\n\t\trotation[4] = sine;\n\t\trotation[5] = cosine;\n\n\t\tDuckMatrix_Multiply(matrix, rotation);\n\t}\n\n\n\n\t/*\n\t\t\n\t#define IDENTITY_MATRIX {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 }\n\t\t\n\tvoid DuckMatrix_Multiply(float matrixA[16], const float matrixB[16])\n\t{\n\t\tfloat temp[16];// = IDENTITY;\n\t\t\n\t\t\n\t\t//temp[0] = \n\t\t\n\t\t\n\t\t\n\t\tint row, column, row_offset;\n\n\t\tfor (row = 0, row_offset = row * 4; row < 4; ++row, row_offset = row * 4)\n\t\t\tfor (column = 0; column < 4; ++column)\n\t\t\t\ttemp[row_offset + column] =\n\t\t\t\t\t(matrixA[row_offset + 0] * matrixB[column + 0]) +\n\t\t\t\t\t(matrixA[row_offset + 1] * matrixB[column + 4]) +\n\t\t\t\t\t(matrixA[row_offset + 2] * matrixB[column + 8]) +\n\t\t\t\t\t(matrixA[row_offset + 3] * matrixB[column + 12]);\n\t\t\t\t\t\n\t\tmemcpy(matrixA, temp, sizeof(float)*16);\n\t}\n\t\n\t\n\tvoid DuckMatrix_Ortho(float matrix[16], float left, float right, float top, float bottom, float near, float far)\n\t{\n\t\tfloat temp[16] = IDENTITY_MATRIX;\n\t\tmemcpy(matrix, temp, sizeof(float)*16);\n\n\t\tmatrix[0] = 2.0f / (right - left);\n\t\tmatrix[5] = 2.0f / (top - bottom);\n\t\tmatrix[10] = 2.0f / (far - near);\n\t\tmatrix[12] = - (right + left) / (right - left);\n\t\tmatrix[13] = - (top + bottom) / (top - bottom);\n\n\t}\n\t\n\tvoid DuckMatrix_Scale(float matrix[16], float x, float y, float z)\n\t{\n\t\tfloat scale[16] = IDENTITY_MATRIX;\n\t\t\n\t\tscale[0] = x;\n\t\tscale[5] = y;\n\t\tscale[10] = z;\n\n\t\tDuckMatrix_Multiply(matrix, scale);\n\t}\n\t\n\tvoid DuckMatrix_Translate(float matrix[16], float x, float y, float z)\n\t{\n\t\tfloat translation[16] = IDENTITY_MATRIX;\n\t\t\n\t\ttranslation[12] = x;\n\t\ttranslation[13] = y;\n\t\ttranslation[14] = z;\n\n\t\tDuckMatrix_Multiply(matrix, translation);\n\t}\n\t\n\tvoid DuckMatrix_RotateZ(float matrix[16], float angle)\n\t{\n\t\tfloat rotation[16] = IDENTITY_MATRIX;\n\t\tfloat sine = (float)sin(angle);\n\t\tfloat cosine = (float)cos(angle);\n\n\t\trotation[0] = cosine;\n\t\trotation[1] = -sine;\n\t\trotation[4] = sine;\n\t\trotation[5] = cosine;\n\n\t\tDuckMatrix_Multiply(matrix, rotation);\n\t}*/","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\ttypedef struct duck_allocation duck_allocation;\n\tstruct duck_allocation\n\t{\n\t\tvoid* pointer;\n\t\tchar* file;\n\t\tint line;\n\t\tduck_allocation* next;\n\t};\n\t\n\tstatic bool s_initialized = false;\n\tstatic duck_allocation* s_allocationList = NULL;\n\t\n\n\n\tvoid DuckMemory_Startup()\n\t{\n\t\ts_initialized = true;\n\t}\n\t\n\tvoid DuckMemory_Shutdown()\n\t{\n\t\tif (s_allocationList)\n\t\t{\n\t\t\tprintf(\"********************** Leaks Detected ************************\\n\");\n\t\t\t\n\t\t\tduck_allocation* temp = s_allocationList;\n\t\t\twhile (temp)\n\t\t\t{\n\t\t\t\tprintf(\"%s (%d)\\n\", temp->file, temp->line);\n\t\t\t\ttemp = temp->next;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n/* Public Functionality */\n\tvoid* DuckMemory_Malloc(size_t size, const char* file, int line)\n\t{\n\t\tassert(s_initialized); // you have not called Duck_Startup();\n\t\t\n\t\tduck_allocation* temp = s_allocationList;\n\t\tif (temp)\n\t\t{\n\t\t\twhile (temp->next)\n\t\t\t\ttemp = temp->next;\n\t\t\ttemp->next = (duck_allocation*)malloc(sizeof(duck_allocation));\n\t\t\ttemp = temp->next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts_allocationList = (duck_allocation*)malloc(sizeof(duck_allocation));\n\t\t\ttemp = s_allocationList;\n\t\t}\n\t\tmemset(temp, 0, sizeof(duck_allocation));\n\t\ttemp->pointer = malloc(size);\n\t\ttemp->file = malloc(strlen(file)+1);\n\t\tstrcpy(temp->file, file);\n\t\ttemp->line = line;\n\t\t\n\t\treturn temp->pointer;\n\t}\n\t\n\tvoid DuckMemory_Free(void* pointer)\n\t{\n\t\tif (!pointer)\n\t\t\treturn;\n\t\t\n\t\tif (s_allocationList)\n\t\t{\n\t\t\tif (s_allocationList->pointer == pointer)\n\t\t\t{\n\t\t\t\tfree(s_allocationList->pointer);\n\t\t\t\t\n\t\t\t\tduck_allocation* temp = s_allocationList->next;\n\t\t\t\tfree(s_allocationList);\n\t\t\t\ts_allocationList = temp;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tduck_allocation* p = s_allocationList;\n\t\t\t\twhile (p->next)\n\t\t\t\t{\n\t\t\t\t\tif (p->next->pointer == pointer)\n\t\t\t\t\t{\n\t\t\t\t\t\tduck_allocation* temp = p->next;\n\t\t\t\t\t\t//printf(\"%x %s (%d)\\n\", (unsigned int)pointer, temp->file, temp->line);\n\t\t\t\t\t\tp->next = p->next->next;\n\t\t\t\t\t\tfree(temp->pointer);\n\t\t\t\t\t\tfree(temp);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tp = p->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"Unknown pointer: %x\\n\", (unsigned int)pointer);\n\t\tassert(false);\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel */\n\tGLuint DuckShader_LoadShader(const char* source, GLenum type)\n\t{\n\t\tGLuint shader = glCreateShader(type);\n\t\tglShaderSource(shader, 1, &source, NULL);\n\t\tglCompileShader(shader);\n\t\t// Check the result of the compilation\n\t\tGLint test;\n\t\tglGetShaderiv(shader, GL_COMPILE_STATUS, &test);\n\t\t\n\t\t//assert(test);\n\t\tif(!test) {\n\t\t\t\n\t\t\tchar temp[1024];\n\n\t\t\t//std::vector<char> compilation_log(512);\n\t\t\tglGetShaderInfoLog(shader, 1024, NULL, temp);\n\t\t\t//std::cerr << &compilation_log[0] << std::endl;\n\t\t\tprintf(\"Shader compilation failed with this message: %s\\n\", temp);\n\t\t\tassert(false);\n\t\t}\n\t\treturn shader;\n\t}\n\t\n\tGLuint DuckShader_LoadProgram(const char* vertexSource, const char* fragmentSource)\n\t{\n\t\tGLuint program = glCreateProgram();\n\t\tGLuint vertexShader = DuckShader_LoadShader(vertexSource, GL_VERTEX_SHADER);\n\t\tGLuint fragmentShader = DuckShader_LoadShader(fragmentSource, GL_FRAGMENT_SHADER);\n\t\t\n\t\tglAttachShader(program, vertexShader);\n\t\tglAttachShader(program, fragmentShader);\n\n\t\tglDeleteShader(vertexShader);\n\t\tglDeleteShader(fragmentShader);\n\n\t\tglLinkProgram(program);\n\t\tglUseProgram(program);\n\n\t\treturn program;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\tstruct duck_sprite\n\t{\n\t\tduck_sprite* previous;\n\t\tduck_sprite* next;\n\t\t\n\t\tduck_texture* texture; //duck_sprite_sheet* spriteSheet;\n\t\tduck_string* name;\n\t\t/*float sourceX;\n\t\tfloat sourceY;\n\t\tfloat sourceWidth;\n\t\tfloat sourceHeight;\n\t\tfloat destOffsetX;\n\t\tfloat destOffsetY;\n\t\tfloat destWidth;\n\t\tfloat destHeight;*/\n\t\t\n\t\tfloat width;\n\t\tfloat height;\n\t\t\n\t\t\n\t\tGLuint vertexBufferId;\n\t\tGLuint uvBufferId;\n\t\tGLuint indexBufferId;\n\t};\n\t\n\tstatic duck_sprite* s_spriteList = NULL;\n\t\n\tstatic GLuint s_program;\n\tstatic GLuint s_matrixUniform;\n\tstatic GLuint s_textureUniform;\n\tstatic GLuint s_vertexArray;\n \tstatic GLuint s_textureArray;\n\t\n\tvoid DuckSprite_Startup()\n\t{\n\t\tconst char* vertexSource =\n\t\t\t#if defined(EMSCRIPTEN)\n\t\t\t\t\"#version 100\\n\"\n\t\t\t\t\"precision mediump float;\\n\"\n\t\t\t#endif\n\t\t\t\"attribute vec3 vertexPosition_modelspace;\\n\"\n\t\t\t\"attribute vec2 vertexUV;\\n\"\n\t\t\t\"varying vec2 UV;\\n\"\n\t\t\t\"uniform mat4 MVP;\\n\"\n\t\t\t\"void main()\\n\"\n\t\t\t\"{\\n\"\n\t\t\t\"\tgl_Position =  MVP * vec4(vertexPosition_modelspace,1);\\n\"\n\t\t\t\"\tUV = vertexUV;\\n\"\n\t\t\t\"}\";\n\n\t\tconst char* fragmentSource =\n\t\t\t#if defined(EMSCRIPTEN)\n\t\t\t\t\"#version 100\\n\"\n\t\t\t\t\"precision mediump float;\\n\"\n\t\t\t#endif\n\t\t\t\"varying  vec2 UV;\\n\"\n\t\t\t\"uniform sampler2D myTextureSampler;\\n\"\n\t\t\t\"void main()\\n\"\n\t\t\t\"{\\n\"\n\t\t\t\"\tgl_FragColor = texture2D( myTextureSampler, UV );\\n\"\n\t\t\t\"}\";\n\t\t\t\n\t\ts_program = DuckShader_LoadProgram(vertexSource, fragmentSource);\n\t//\tassert(s_program);\n\t\ts_matrixUniform = glGetUniformLocation(s_program, \"MVP\");\n\t//\tassert(s_matrixUniform);\n\t\ts_textureUniform = glGetUniformLocation(s_program, \"myTextureSampler\");\n\t\t\n\t\ts_vertexArray = glGetAttribLocation(s_program, \"vertexPosition_modelspace\");\n \t\ts_textureArray = glGetAttribLocation(s_program, \"vertexUV\");\n \t\t\n\t//\ts_textureUniform = glGetUniformLocation(s_program, \"myTextureSampler\");\n\t\t\n\t//\tassert(s_textureUniform);\n\t}\n\t\n\tvoid DuckSprite_Shutdown()\n\t{\n\t\tassert(!s_spriteList);\n\t}\n\n\n\tduck_sprite* DuckSprite_Create(duck_texture* texture, const char* name, float sourceX, float sourceY, float sourceWidth, float sourceHeight, float destOffsetX, float destOffsetY, float destWidth, float destHeight)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_sprite, s_spriteList, sprite);\n\t\t\n\t\tsprite->texture = texture;\n\t\tsprite->name = DuckString_Create(name);\n\t\tsprite->width = destWidth;\n\t\tsprite->height = destHeight;\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfloat vertexArray[12] =\n\t\t{\n\t\t\tdestOffsetX,\t\t\t\tdestOffsetY,\t\t\t\t0.0f,\n\t\t\tdestOffsetX + sourceWidth,\tdestOffsetY,\t\t\t\t0.0f,\n\t\t\tdestOffsetX,\t\t\t\tdestOffsetY + sourceHeight,\t0.0f,\n\t\t\tdestOffsetX + sourceWidth,\tdestOffsetY + sourceHeight,\t0.0f\n\t\t};\n\t\tglGenBuffers(1, &sprite->vertexBufferId);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, sprite->vertexBufferId);\n\t\tglBufferData(GL_ARRAY_BUFFER, 4 * sizeof(float) * 3, vertexArray, GL_STATIC_DRAW);\n\t\n\t\n\t\n\t\n\t\n\t\tfloat x = sourceX / DuckTexture_GetWidth(texture);\n\t\tfloat y = sourceY / DuckTexture_GetHeight(texture);\n\t\tfloat w = sourceWidth / DuckTexture_GetWidth(texture);\n\t\tfloat h = sourceHeight / DuckTexture_GetHeight(texture);\n\n\t\tfloat uvArray[8] =\n\t\t{\n\t\t\tx, y,\n\t\t\tx + w, y,\n\t\t\tx, y + h,\n\t\t\tx + w, y + h\n\t\t};\n\t\tglGenBuffers(1, &sprite->uvBufferId);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, sprite->uvBufferId);\n\t\tglBufferData(GL_ARRAY_BUFFER, 4 * sizeof(float) * 2, uvArray, GL_STATIC_DRAW);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tUint16 indexArray[6] =\n\t\t{\n\t\t\t0, 1, 2,\n\t\t\t2, 1, 3\n\t\t};\n\t\tglGenBuffers(1, &sprite->indexBufferId);\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sprite->indexBufferId);\n\t\tglBufferData(GL_ELEMENT_ARRAY_BUFFER, 2 * sizeof(Uint16) * 3, indexArray, GL_STATIC_DRAW);\n\t\t\n\t\treturn sprite;\n\t}\n\t\n\tvoid DuckSprite_Destroy(duck_sprite* sprite)\n\t{\n\t\tglDeleteBuffers(1, &sprite->vertexBufferId);\n\t\tglDeleteBuffers(1, &sprite->uvBufferId);\n\t\tglDeleteBuffers(1, &sprite->indexBufferId);\n\t\tDuckString_Destroy(sprite->name);\n\t\tDUCK_LINKED_LIST_FREE2(s_spriteList, sprite);\n\t}\n\t\n\tvoid DuckSprite_PrepareMatrix(duck_sprite* sprite, float matrix[16], float x, float y, bool flipped, float angle)\n\t{\n\t\tDuckMatrix_Ortho(matrix, 0.0f, Duck_GetScreenWidth(), 0.0f, Duck_GetScreenHeight(), 0.0f, 1.0f);\n\t\tDuckMatrix_Translate(matrix, x, y, 0.0f);\n\t\tif (flipped || angle != 0.0f)\n\t\t{\n\t\t\tDuckMatrix_Translate(matrix, sprite->width/2, sprite->height/2, 0.0f);\n\t\t\tif (flipped)\n\t\t\t\tDuckMatrix_Scale(matrix, -1.0f, 1.0f, 1.0f);\n\t\t\tif (angle != 0.0f)\n\t\t\t\tDuckMatrix_RotateZ(matrix, angle);\n\t\t\tDuckMatrix_Translate(matrix, -sprite->width/2, -sprite->height/2, 0.0f);\n\t\t}\n\t}\n\t\n\tGLuint DuckSprite_GetTextureId(duck_sprite* sprite)\n\t{\n\t\treturn DuckTexture_GetTextureId(sprite->texture);\n\t}\n\t\n\tGLuint DuckSprite_GetVertexBufferId(duck_sprite* sprite)\n\t{\n\t\treturn sprite->vertexBufferId;\n\t}\n\t\n\tGLuint DuckSprite_GetUvBufferId(duck_sprite* sprite)\n\t{\n\t\treturn sprite->uvBufferId;\n\t}\n\t\n\tGLuint DuckSprite_GetIndexBufferId(duck_sprite* sprite)\n\t{\n\t\treturn sprite->indexBufferId;\n\t}\n\t\t\n\t\n\n/* Public Functionality */\n\tduck_sprite* DuckSprite_Get(const char* name)\n\t{\n\t\tif (strlen(name) > 0)\n\t\t{\n\t\t\tduck_sprite* sprite = s_spriteList;\n\t\t\twhile (sprite)\n\t\t\t{\n\t\t\t\tif (strcmp(DuckString_GetCString(sprite->name), name) == 0)\n\t\t\t\t\treturn sprite;\n\t\t\t\tsprite = sprite->next;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\t\n\t\n\t\n\tvoid DuckSprite_Render(duck_sprite* sprite, float x, float y, bool flipped, float angle)\n\t{\n\t\tassert(sprite);\n\t\t\n\t\tfloat matrix[16];\n\t\tDuckSprite_PrepareMatrix(sprite, matrix, x, y, flipped, angle);\n\t\t\n\t\tglUseProgram(s_program);\n\t\tglUniformMatrix4fv(s_matrixUniform, 1, GL_FALSE, matrix);\n\t\t\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D, DuckSprite_GetTextureId(sprite));\n\t\tglUniform1i(s_textureUniform, 0);\n\n\t\tglEnableVertexAttribArray(s_vertexArray);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, DuckSprite_GetVertexBufferId(sprite));\n\t\tglVertexAttribPointer(s_vertexArray, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n\n\t\tglEnableVertexAttribArray(s_textureArray);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, DuckSprite_GetUvBufferId(sprite));\n\t\tglVertexAttribPointer(s_textureArray, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);\n\n\t\tglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, DuckSprite_GetIndexBufferId(sprite));\n\t\tglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (void*)0);\n\t\t\n\t\tglDisableVertexAttribArray(s_textureArray);\n\t\tglDisableVertexAttribArray(s_vertexArray);\n\t\tglUseProgram(0);\n\t}\n\t\n\tfloat DuckSprite_GetWidth(duck_sprite* sprite)\n\t{\n\t\treturn sprite->width;\n\t}\n\t\n\tfloat DuckSprite_GetHeight(duck_sprite* sprite)\n\t{\n\t\treturn sprite->height;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\ttypedef struct duck_sprite_sheet_sprite duck_sprite_sheet_sprite;\n\tstruct duck_sprite_sheet_sprite\n\t{\n\t\tduck_sprite_sheet_sprite* previous;\n\t\tduck_sprite_sheet_sprite* next;\n\t\t\n\t\tduck_sprite* sprite;\n\t};\n\n\n\tstruct duck_sprite_sheet\n\t{\n\t\tduck_sprite_sheet* previous;\n\t\tduck_sprite_sheet* next;\n\t\t\n\t\tduck_file* file;\n\t\tduck_texture* texture;\n\t\t\n\t\t/*struct duck_sprite_sheet\n\t\t{*/\n\t\t\tbool loaded;\n\t\t\tfloat width;\n\t\t\tfloat height;\n\t\t/*};*/\n\t\t\t\n\t\tduck_sprite_sheet_sprite* spriteList;\n\t};\n\t\n\tstatic duck_sprite_sheet* s_spriteSheetList = NULL;\n\t\n\tvoid DuckSpriteSheet_Startup()\n\t{\n\t}\n\t\n\tvoid DuckSpriteSheet_Shutdown()\n\t{\n\t\tassert(!s_spriteSheetList);\n\t}\n\t\n\tvoid DuckSpriteSheet_Update()\n\t{\n\t\tduck_sprite_sheet* spriteSheet = s_spriteSheetList;\n\t\twhile (spriteSheet)\n\t\t{\n\t\t\tif (!spriteSheet->loaded)\n\t\t\t{\n\t\t\t\tif (DuckFile_Loaded(spriteSheet->file) && DuckTexture_Loaded(spriteSheet->texture))\n\t\t\t\t{\n\t\t\t\t\t//printf(\"A %lu\\n\", temp->file->dataSize);\n\t\t\t\t\tbool first = true;\n\t\t\t\t\tunsigned int offset = 0;\n\t\t\t\t\t\n\t\t\t\t\tconst char* charData = (const char*)DuckFile_GetData(spriteSheet->file);\n\t\t\t\t\n\t\t\t\t\t//const char* szFile = (const char*)FileManager::FileGetData(pSpriteSheet->hFileHandle);\n\t\t\t\t\t//Uint32 nFileSize = FileManager::FileGetSize(pSpriteSheet->hFileHandle);\n\n\t\t\t\t\tduck_string* line = DuckString_Create(\"\");\n\t\t\t\n\t\t\t\t\t//printf(\"~%s\\n\", line->cString);\n\n\t\t\t\t\twhile (offset < DuckFile_GetSize(spriteSheet->file))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (charData[offset] == '\\n')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint width = 0;\n\t\t\t\t\t\t\t\tint height = 0;\n\t\t\t\t\t\t\t\tsscanf(DuckString_GetCString(line), \"%d\\t%d\", &width, &height);\n\t\t\t\t\t\t\t\tfirst = false;\n\n\t\t\t\t\t\t\t\tspriteSheet->width = (float)width;\n\t\t\t\t\t\t\t\tspriteSheet->height = (float)height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//1_base_0\t0\t870\t80\t122\t32\t4\t142\t136\n\t\t\t\t\t\t\t\tchar szName[64];\n\t\t\t\t\t\t\t\tint sourceX, sourceY, sourceWidth, sourceHeight, destOffsetX, destOffsetY, destWidth, destHeight;\n\t\t\t\t\t\t\t\tsscanf(DuckString_GetCString(line), \"%s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", szName, &sourceX, &sourceY, &sourceWidth, &sourceHeight, &destOffsetX, &destOffsetY, &destWidth, &destHeight);\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tDUCK_LINKED_LIST_ADD2(duck_sprite_sheet_sprite, spriteSheet->spriteList, sprite);\n\t\t\t\t\t\t\t\tsprite->sprite = DuckSprite_Create(spriteSheet->texture, szName, (float)sourceX, (float)sourceY, (float)sourceWidth, (float)sourceHeight, (float)destOffsetX, (float)destOffsetY, (float)destWidth, (float)destHeight);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tDuckString_Set(line, \"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDuckString_AppendChar(line, charData[offset]);\n\t\t\t\t\t\t\t//printf(\"%s\\n\", line->cString);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//printf(\"XX\\n\");\n\t\t\t\t\tDuckString_Destroy(line);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tDuckFile_Close(spriteSheet->file);\n\t\t\t\t\tspriteSheet->file = NULL;\n\t\t\t\t\tspriteSheet->loaded = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspriteSheet = spriteSheet->next;\n\t\t}\n\t}\n\n\n\n\n\n\n\n/* Public Functionality */\n\tduck_sprite_sheet* DuckSpriteSheet_Create(const char* fileName)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_sprite_sheet, s_spriteSheetList, spriteSheet);\n\t\t\n\t\t//temp->spriteSheet = (duck_sprite_sheet*)Duck_Malloc(sizeof(duck_sprite_sheet));;\n\t\tduck_string* path = DuckString_Create(\"../Resource/\");\n\t\tDuckString_AppendCString(path, fileName);\n\t\tDuckString_AppendCString(path, \".txt\");\n\t\t\tspriteSheet->file = DuckFile_Open(DuckString_GetCString(path));\n\t\tDuckString_Destroy(path);\n\t\t\n\t\tspriteSheet->texture = DuckTexture_Create(fileName);\n\t\t\n\t\t\n\t\t\n\t\treturn spriteSheet;\n\t}\n\n\tvoid DuckSpriteSheet_Destroy(duck_sprite_sheet* spriteSheet)\n\t{\n\t\t/*DUCK_LINKED_LIST_FIND(duck_sprite_sheet_secret, s_spriteSheetList, spriteSheet, temp);\n\t\tassert(temp); // not found!\n\t\t*/\n\t\t\n\t\twhile (spriteSheet->spriteList)\n\t\t{\n\t\t\tduck_sprite_sheet_sprite* sprite = spriteSheet->spriteList;\n\t\t\tDuckSprite_Destroy(sprite->sprite);\n\t\t\tDUCK_LINKED_LIST_FREE2(spriteSheet->spriteList, sprite);\n\t\t}\n\t\t\n\t\tif (spriteSheet->file)\n\t\t\tDuckFile_Close(spriteSheet->file);\n\t\tDuckTexture_Destroy(spriteSheet->texture);\n\n\t\t\n\t\tDUCK_LINKED_LIST_FREE2(s_spriteSheetList, spriteSheet);\n\t}\n\t\n\tbool DuckSpriteSheet_Loaded(duck_sprite_sheet* spriteSheet)\n\t{\n\t\treturn spriteSheet->loaded;\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n/* Secret Squirrel Stuff */\n\tstruct duck_string\n\t{\n\t\tduck_string* previous;\n\t\tduck_string* next;\n\t\t\n\t\tint length;\n\t\tint bufferSize;\n\t\tchar* cString;\n\t};\n\t\n\tduck_string* s_stringList = NULL;\n\t\n\tvoid DuckString_Startup()\n\t{\n\t}\n\t\n\tvoid DuckString_Shutdown()\n\t{\n\t\tassert(!s_stringList); // you have not destroyed all created strings\n\t}\n\t\n\tvoid DuckString_SizeToFit(duck_string* string, int length)\n\t{\n\t\tif (string->bufferSize < length+1)\n\t\t{\n\t\t\tif (string->bufferSize == 0)\n\t\t\t{\n\t\t\t\tstring->bufferSize = length+1;\n\t\t\t\tstring->cString = (char*)Duck_Malloc(string->bufferSize);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\twhile (string->bufferSize < length+1)\n\t\t\t\t\tstring->bufferSize = string->bufferSize << 1;\n\t\t\t\n\t\t\t\tchar* oldCString = string->cString;\n\t\t\t\t\tstring->cString = (char*)Duck_Malloc(string->bufferSize);\n\t\t\t\t\tmemcpy(string->cString, oldCString, string->length+1);\n\t\t\t\tDuck_Free(oldCString);\n\t\t\t}\n\t\t}\n\t}\n\t\n/* Public Functionality */\n\tduck_string* DuckString_Create(const char* cString)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_string, s_stringList, string);\n\t\t\n\t\tDuckString_Set(string, cString);\n\t\t\n\t\treturn string;\n\t}\n\t\n\tvoid DuckString_Destroy(duck_string* string)\n\t{\n\t\t/*DUCK_LINKED_LIST_FIND(duck_string_secret, s_stringList, string, temp);\n\t\tif (!temp)\n\t\t{\n\t\t\tprintf(\"*** Cannot destroy non existant string\");\n\t\t\tassert(false);\n\t\t}*/\n\t\t\n\t\tDuck_Free(string->cString);\n\t\t\n\t\t\n\t\tDUCK_LINKED_LIST_FREE2(s_stringList, string);\n\t}\n\t\n\tint DuckString_GetLength(duck_string* string)\n\t{\n\t\treturn string->length;\n\t}\n\t\n\tconst char* DuckString_GetCString(duck_string* string)\n\t{\n\t\treturn string->cString;\n\t}\n\t\n\tvoid DuckString_Set(duck_string* string, const char* cString)\n\t{\n\t\tint length = strlen(cString);\n\t\tDuckString_SizeToFit(string, length);\n\t\t\n\t\tchar* p = string->cString;\n\t\tmemcpy(p, cString, length);\n\t\tp[length] = '\\0';\n\t\tstring->length = length;\n\t}\n\t\n\tvoid DuckString_AppendString(duck_string* string1, const duck_string* string2)\n\t{\n\t\tDuckString_SizeToFit(string1, string1->length + string2->length);\n\t\tchar* p = string1->cString;\n\t\tmemcpy(p + string1->length, string2->cString, string2->length);\n\t\tp[string1->length + string2->length] = '\\0';\n\t\tstring1->length += string2->length;\n\t}\n\t\n\tvoid DuckString_AppendCString(duck_string* string, const char* cString)\n\t{\n\t\t//printf(\"before: %s \", string->cString);\n\t\tint length = strlen(cString);\n\t\tDuckString_SizeToFit(string, string->length + length);\n\t\tchar* p = string->cString;\n\t\tmemcpy(p + string->length, cString, length);\n\t\tp[string->length + length] = '\\0';\n\t\tstring->length += length;\n\t\t//printf(\"after: %s\\n\", string->cString);\n\t}\n\t\n\tvoid DuckString_AppendChar(duck_string* string, const char c)\n\t{\n\t\t//printf(\"append: %c before: %s(%d:%lu) \", c, string->cString, string->length, strlen(string->cString));\n\t\tDuckString_SizeToFit(string, string->length + 1);\n\t\tchar* p = string->cString;\n\t\tp[string->length] = c;\n\t\tp[string->length + 1] = '\\0';\n\t\tstring->length++;\n\t\t//printf(\"after: %s(%d)\\n\", string->cString, string->length);\n\t}","#define DUCK_SECRET\n#include \"DuckEngine.h\"\n\n#include \"lodepng/lodepng.h\"\n\n/* Secret Squirrel Stuff */\n\tstruct duck_texture\n\t{\n\t\tduck_texture* previous;\n\t\tduck_texture* next;\n\n\t\tbool loaded;\n\t\tGLuint textureId;\n\t\tfloat width;\n\t\tfloat height;\n\t\t\n\t\tduck_file* file;\n\t};\n\n\tstatic duck_texture* s_textureList = NULL;\n\tstatic duck_texture* s_caulkTexture = NULL;\n\t\n\tvoid DuckTexture_Startup()\n\t{\n\t\t// Caulk\n\t\tint x;\n\t\tint y;\n\t\tint width = 32;\n\t\tint height = 32;\n\t\tunsigned char* image = (unsigned char*)Duck_Malloc(width*height*4);\n\t\tfor (y = 0; y < height; y++)\n\t\t{\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\tunsigned char* p = image + (x + y*width)*4;\n\t\t\t\tp[0] = x;\n\t\t\t\tp[1] = 0;\n\t\t\t\tp[2] = y;\n\t\t\t\tp[3] = ((x >> 3) + (y >> 3)) % 2 * 128 + 64; // alpha\n\t\t\t\t//printf(\"%d\\n\", p[3]);\n\t\t\t}\n\t\t}\n\t\t\n\t\ts_caulkTexture = DuckTexture_CreateFromMemory(width, height, GL_RGBA, image);\n\t\tDuck_Free(image);\n\t}\n\t\n\tvoid DuckTexture_Shutdown()\n\t{\n\t\tDuckTexture_Destroy(s_caulkTexture);\n\t\t\n\t\tassert(!s_textureList); // you have not unloaded all textures!\n\t}\n\n\n\n\n\n/*\t#ifdef EMSCRIPTEN\n\t\tvoid OnLoad(void* userPointer, const char* fileName)\n\t\t{\n\t\t\tduck_texture* texture = (duck_texture*)userPointer;\n\n\t\t\tSDL_Surface *surface = IMG_Load(fileName);\n\t\t\tif (surface)\n\t\t\t{\n\t\t\t\ttexture->loaded = true;\n\t\t\t\ttexture->width = surface->w;\n\t\t\t\ttexture->height = surface->h;\n\t\t\t\t\n\t\t\t\tglGenTextures(1, &texture->textureId);\n\t\t\t\tassert(texture->textureId > 0);\n\t\t\t\tglBindTexture(GL_TEXTURE_2D, texture->textureId);\n\t\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture->width, texture->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface->pixels);\n\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\t\t\t\n\t\t\t\tDuckFile_Close(texture->file);\n\t\t\t\ttexture->file = NULL;\n\n\t\t\t\tSDL_FreeSurface(surface);\n\n\t\t\t\t//free((void*)szFileName);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//free((void*)szFileName);\n\t\t\tprintf(\"TEXTURE LOAD ERROR 2\\n\");\n\t\t}\n\n\t\tvoid OnError(void* userPointer)\n\t\t{\n\t\t\tduck_texture* texture = (duck_texture*)userPointer;\n\t\t\tprintf(\"TEXTURE LOAD ERROR\\n\");\n\t\t}\n\t#endif\n*/\n\n\n\n\t\n\tvoid DuckTexture_Update()\n\t{\n\t\tduck_texture* texture = s_textureList;\n\t\twhile (texture)\n\t\t{\n\t\t\tif (!texture->loaded)\n\t\t\t{\n\t\t\t\tif (DuckFile_Loaded(texture->file))\n\t\t\t\t{\n\t\t\t\t\t//const char* charData = (const char*)texture->file->data;\n\n\t\t\t\t\tassert(DuckFile_GetSize(texture->file) > 0);\n\t\t\t\t\n\t\t\t\t\tunsigned char* imageData = 0;\n\t\t\t\t\tunsigned width = 0;\n\t\t\t\t\tunsigned height = 0;\n\t\t\t\t\tunsigned error = lodepng_decode32(&imageData, &width, &height, DuckFile_GetData(texture->file), DuckFile_GetSize(texture->file));\n\t\t\t\t\tassert(error == 0);\n\t\t\t\t\t\n\t\t\t\t\t\ttexture->loaded = true;\n\t\t\t\t\t\ttexture->width = width;\n\t\t\t\t\t\ttexture->height = height;\n\t\t\t\t\t\t\n\t\t\t\t\t\tglGenTextures(1, &texture->textureId);\n\t\t\t\t\t\tassert(texture->textureId > 0);\n\t\t\t\t\t\tglBindTexture(GL_TEXTURE_2D, texture->textureId);\n\t\t\t\t\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture->width, texture->height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);\n\t\t\t\t\t\t//glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, surface->w, surface->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, surface->pixels);\n\t\t\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\t\t\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\t\t\t\t\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\t\t\t\t\n\t\t\t\t\tfree(imageData);\n\t\t\t\t\t\n\t\t\t\t\tDuckFile_Close(texture->file);\n\t\t\t\t\ttexture->file = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttexture = texture->next;\n\t\t}\n\t}\n\t\n\tduck_texture* DuckTexture_CreateFromMemory(int width, int height, GLenum format, const void* data)\n\t{\n\t\t// GL_RGBA\n\t\tDUCK_LINKED_LIST_ADD2(duck_texture, s_textureList, texture);\n\t\t\n\t\ttexture->loaded = true;\n\t\ttexture->width = width;\n\t\ttexture->height = height;\n\t\n\t\tglGenTextures(1, &texture->textureId);\n\t\tassert(texture->textureId > 0);\n\t\tglBindTexture(GL_TEXTURE_2D, texture->textureId);\n\t\t// Todo: should be GL_RGBA?\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, format, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data); // GL_UNSIGNED_BYTE\n\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\t\n\t\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\n\t\treturn texture;\n\t}\n\t\n\tduck_texture* DuckTexture_GetCaulkTexture()\n\t{\n\t\treturn s_caulkTexture;\n\t}\n\t\n\t\n\n/* Public Functionality */\n\tduck_texture* DuckTexture_Create(const char* fileName)\n\t{\n\t\tDUCK_LINKED_LIST_ADD2(duck_texture, s_textureList, texture);\n\t\t\n\t\ttexture->loaded = false;\n\t\ttexture->textureId = s_caulkTexture->textureId;\n\t\ttexture->width = s_caulkTexture->width;\n\t\ttexture->height = s_caulkTexture->height;\n\t\t\n\t\tduck_string* path = DuckString_Create(\"../Resource/\");\n\t\tDuckString_AppendCString(path, fileName);\n\t\tDuckString_AppendCString(path, \".png\");\n\t\t\ttexture->file = DuckFile_Open(DuckString_GetCString(path));\n\t\tDuckString_Destroy(path);\n\t\t\n\t\treturn texture;\n\t}\n\t\n\t\n\t\n\tvoid DuckTexture_Destroy(duck_texture* texture)\n\t{\n\t\tif (texture->loaded)\n\t\t\tglDeleteTextures(1, &texture->textureId);\n\t\tif (texture->file)\n\t\t\tDuckFile_Close(texture->file);\n\n\t\tDUCK_LINKED_LIST_FREE2(s_textureList, texture);\n\t}\n\t\n\t\n\tbool DuckTexture_Loaded(duck_texture* texture)\n\t{\n\t\treturn texture->loaded;\n\t}\n\t\n\tGLuint DuckTexture_GetTextureId(duck_texture* texture)\n\t{\n\t\treturn texture->textureId;\n\t}\n\t\n\tfloat DuckTexture_GetWidth(duck_texture* texture)\n\t{\n\t\treturn texture->width;\n\t}\n\t\n\tfloat DuckTexture_GetHeight(duck_texture* texture)\n\t{\n\t\treturn texture->height;\n\t}","/*\nLodePNG version 20140801\n\nCopyright (c) 2005-2014 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nThe manual and changelog are in the header file \"lodepng.h\"\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\n*/\n\n#include \"lodepng.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef LODEPNG_COMPILE_CPP\n#include <fstream>\n#endif /*LODEPNG_COMPILE_CPP*/\n\n#define VERSION_STRING \"20140801\"\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\n#endif /*_MSC_VER */\n\n/*\nThis source file is built up in the following large parts. The code sections\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\n-Tools for C and common code for PNG and Zlib\n-C Code for Zlib (huffman, deflate, ...)\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\n-The C++ wrapper around all of the above\n*/\n\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\nof the name, so that you can easily change them to others related to your\nplatform if needed. Everything else in the code calls these. Pass\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\ndefine them in your own project's source files without needing to change\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\nfrom here.*/\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size)\n{\n  return malloc(size);\n}\n\nstatic void* lodepng_realloc(void* ptr, size_t new_size)\n{\n  return realloc(ptr, new_size);\n}\n\nstatic void lodepng_free(void* ptr)\n{\n  free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\nvoid* lodepng_malloc(size_t size);\nvoid* lodepng_realloc(void* ptr, size_t new_size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // Tools for C, and common code for PNG and Zlib.                       // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*\nOften in case of an error a value is assigned to a variable and then it breaks\nout of a loop (to go to the cleanup phase of a function). This macro does that.\nIt makes the error handling code shorter and more readable.\n\nExample: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);\n*/\n#define CERROR_BREAK(errorvar, code)\\\n{\\\n  errorvar = code;\\\n  break;\\\n}\n\n/*version of CERROR_BREAK that assumes the common case where the error variable is named \"error\"*/\n#define ERROR_BREAK(code) CERROR_BREAK(error, code)\n\n/*Set error var to the error code, and return it.*/\n#define CERROR_RETURN_ERROR(errorvar, code)\\\n{\\\n  errorvar = code;\\\n  return code;\\\n}\n\n/*Try the code, if it returns error, also return the error.*/\n#define CERROR_TRY_RETURN(call)\\\n{\\\n  unsigned error = call;\\\n  if(error) return error;\\\n}\n\n/*\nAbout uivector, ucvector and string:\n-All of them wrap dynamic arrays or text strings in a similar way.\n-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.\n-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.\n-They're not used in the interface, only internally in this file as static functions.\n-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.\n*/\n\n#ifdef LODEPNG_COMPILE_ZLIB\n/*dynamic vector of unsigned ints*/\ntypedef struct uivector\n{\n  unsigned* data;\n  size_t size; /*size in number of unsigned longs*/\n  size_t allocsize; /*allocated size in bytes*/\n} uivector;\n\nstatic void uivector_cleanup(void* p)\n{\n  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;\n  lodepng_free(((uivector*)p)->data);\n  ((uivector*)p)->data = NULL;\n}\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_resize(uivector* p, size_t size)\n{\n  if(size * sizeof(unsigned) > p->allocsize)\n  {\n    size_t newsize = size * sizeof(unsigned) * 2;\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data)\n    {\n      p->allocsize = newsize;\n      p->data = (unsigned*)data;\n      p->size = size;\n    }\n    else return 0;\n  }\n  else p->size = size;\n  return 1;\n}\n\n/*resize and give all new elements the value*/\nstatic unsigned uivector_resizev(uivector* p, size_t size, unsigned value)\n{\n  size_t oldsize = p->size, i;\n  if(!uivector_resize(p, size)) return 0;\n  for(i = oldsize; i < size; i++) p->data[i] = value;\n  return 1;\n}\n\nstatic void uivector_init(uivector* p)\n{\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_push_back(uivector* p, unsigned c)\n{\n  if(!uivector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}\n\n/*copy q to p, returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned uivector_copy(uivector* p, const uivector* q)\n{\n  size_t i;\n  if(!uivector_resize(p, q->size)) return 0;\n  for(i = 0; i < q->size; i++) p->data[i] = q->data[i];\n  return 1;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\n/*dynamic vector of unsigned chars*/\ntypedef struct ucvector\n{\n  unsigned char* data;\n  size_t size; /*used size*/\n  size_t allocsize; /*allocated size*/\n} ucvector;\n\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_resize(ucvector* p, size_t size)\n{\n  if(size * sizeof(unsigned char) > p->allocsize)\n  {\n    size_t newsize = size * sizeof(unsigned char) * 2;\n    void* data = lodepng_realloc(p->data, newsize);\n    if(data)\n    {\n      p->allocsize = newsize;\n      p->data = (unsigned char*)data;\n      p->size = size;\n    }\n    else return 0; /*error: not enough memory*/\n  }\n  else p->size = size;\n  return 1;\n}\n\n#ifdef LODEPNG_COMPILE_PNG\n\nstatic void ucvector_cleanup(void* p)\n{\n  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;\n  lodepng_free(((ucvector*)p)->data);\n  ((ucvector*)p)->data = NULL;\n}\n\nstatic void ucvector_init(ucvector* p)\n{\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n/*resize and give all new elements the value*/\nstatic unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)\n{\n  size_t oldsize = p->size, i;\n  if(!ucvector_resize(p, size)) return 0;\n  for(i = oldsize; i < size; i++) p->data[i] = value;\n  return 1;\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ZLIB\n/*you can both convert from vector to buffer&size and vica versa. If you use\ninit_buffer to take over a buffer and size, it is not needed to use cleanup*/\nstatic void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)\n{\n  p->data = buffer;\n  p->allocsize = p->size = size;\n}\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned ucvector_push_back(ucvector* p, unsigned char c)\n{\n  if(!ucvector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\n\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*returns 1 if success, 0 if failure ==> nothing done*/\nstatic unsigned string_resize(char** out, size_t size)\n{\n  char* data = (char*)lodepng_realloc(*out, size + 1);\n  if(data)\n  {\n    data[size] = 0; /*null termination char*/\n    *out = data;\n  }\n  return data != 0;\n}\n\n/*init a {char*, size_t} pair for use as string*/\nstatic void string_init(char** out)\n{\n  *out = NULL;\n  string_resize(out, 0);\n}\n\n/*free the above pair again*/\nstatic void string_cleanup(char** out)\n{\n  lodepng_free(*out);\n  *out = NULL;\n}\n\nstatic void string_set(char** out, const char* in)\n{\n  size_t insize = strlen(in), i = 0;\n  if(string_resize(out, insize))\n  {\n    for(i = 0; i < insize; i++)\n    {\n      (*out)[i] = in[i];\n    }\n  }\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nunsigned lodepng_read32bitInt(const unsigned char* buffer)\n{\n  return (unsigned)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);\n}\n\n#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)\n/*buffer must have at least 4 allocated bytes available*/\nstatic void lodepng_set32bitInt(unsigned char* buffer, unsigned value)\n{\n  buffer[0] = (unsigned char)((value >> 24) & 0xff);\n  buffer[1] = (unsigned char)((value >> 16) & 0xff);\n  buffer[2] = (unsigned char)((value >>  8) & 0xff);\n  buffer[3] = (unsigned char)((value      ) & 0xff);\n}\n#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic void lodepng_add32bitInt(ucvector* buffer, unsigned value)\n{\n  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/\n  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / File IO                                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DISK\n\nunsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)\n{\n  FILE* file;\n  long size;\n\n  /*provide some proper output values if error will happen*/\n  *out = 0;\n  *outsize = 0;\n\n  file = fopen(filename, \"rb\");\n  if(!file) return 78;\n\n  /*get filesize:*/\n  fseek(file , 0 , SEEK_END);\n  size = ftell(file);\n  rewind(file);\n\n  /*read contents of the file into the vector*/\n  *outsize = 0;\n  *out = (unsigned char*)lodepng_malloc((size_t)size);\n  if(size && (*out)) (*outsize) = fread(*out, 1, (size_t)size, file);\n\n  fclose(file);\n  if(!(*out) && size) return 83; /*the above malloc failed*/\n  return 0;\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nunsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)\n{\n  FILE* file;\n  file = fopen(filename, \"wb\" );\n  if(!file) return 79;\n  fwrite((char*)buffer , 1 , buffersize, file);\n  fclose(file);\n  return 0;\n}\n\n#endif /*LODEPNG_COMPILE_DISK*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of common code and tools. Begin of Zlib related code.            // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_ENCODER\n/*TODO: this ignores potential out of memory errors*/\n#define addBitToStream(/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\\\n{\\\n  /*add a new byte at the end*/\\\n  if(((*bitpointer) & 7) == 0) ucvector_push_back(bitstream, (unsigned char)0);\\\n  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\\\n  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\\\n  (*bitpointer)++;\\\n}\n\nstatic void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)\n{\n  size_t i;\n  for(i = 0; i < nbits; i++) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));\n}\n\nstatic void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)\n{\n  size_t i;\n  for(i = 0; i < nbits; i++) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)\n\nstatic unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)\n{\n  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));\n  (*bitpointer)++;\n  return result;\n}\n\nstatic unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0, i;\n  for(i = 0; i < nbits; i++)\n  {\n    result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;\n    (*bitpointer)++;\n  }\n  return result;\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflate - Huffman                                                      / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#define FIRST_LENGTH_CODE_INDEX 257\n#define LAST_LENGTH_CODE_INDEX 285\n/*256 literals, the end code, some length codes, and 2 unused codes*/\n#define NUM_DEFLATE_CODE_SYMBOLS 288\n/*the distance codes have their own symbols, 30 used, 2 unused*/\n#define NUM_DISTANCE_SYMBOLS 32\n/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/\n#define NUM_CODE_LENGTH_CODES 19\n\n/*the base lengths represented by codes 257-285*/\nstatic const unsigned LENGTHBASE[29]\n  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,\n     67, 83, 99, 115, 131, 163, 195, 227, 258};\n\n/*the extra bits used by codes 257-285 (added to base length)*/\nstatic const unsigned LENGTHEXTRA[29]\n  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,\n      4,  4,  4,   4,   5,   5,   5,   5,   0};\n\n/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/\nstatic const unsigned DISTANCEBASE[30]\n  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,\n     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};\n\n/*the extra bits of backwards distances (added to base)*/\nstatic const unsigned DISTANCEEXTRA[30]\n  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,\n       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};\n\n/*the order in which \"code length alphabet code lengths\" are stored, out of this\nthe huffman tree of the dynamic huffman tree lengths is generated*/\nstatic const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]\n  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*\nHuffman tree struct, containing multiple representations of the tree\n*/\ntypedef struct HuffmanTree\n{\n  unsigned* tree2d;\n  unsigned* tree1d;\n  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/\n  unsigned maxbitlen; /*maximum number of bits a single code can get*/\n  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/\n} HuffmanTree;\n\n/*function used for debug purposes to draw the tree in ascii art with C++*/\n/*\nstatic void HuffmanTree_draw(HuffmanTree* tree)\n{\n  std::cout << \"tree. length: \" << tree->numcodes << \" maxbitlen: \" << tree->maxbitlen << std::endl;\n  for(size_t i = 0; i < tree->tree1d.size; i++)\n  {\n    if(tree->lengths.data[i])\n      std::cout << i << \" \" << tree->tree1d.data[i] << \" \" << tree->lengths.data[i] << std::endl;\n  }\n  std::cout << std::endl;\n}*/\n\nstatic void HuffmanTree_init(HuffmanTree* tree)\n{\n  tree->tree2d = 0;\n  tree->tree1d = 0;\n  tree->lengths = 0;\n}\n\nstatic void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  lodepng_free(tree->tree2d);\n  lodepng_free(tree->tree1d);\n  lodepng_free(tree->lengths);\n}\n\n/*the tree representation used by the decoder. return value is error*/\nstatic unsigned HuffmanTree_make2DTree(HuffmanTree* tree)\n{\n  unsigned nodefilled = 0; /*up to which node it is filled*/\n  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/\n  unsigned n, i;\n\n  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));\n  if(!tree->tree2d) return 83; /*alloc fail*/\n\n  /*\n  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means\n  uninited, a value >= numcodes is an address to another bit, a value < numcodes\n  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as\n  many columns as codes - 1.\n  A good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.\n  Here, the internal nodes are stored (what their 0 and 1 option point to).\n  There is only memory for such good tree currently, if there are more nodes\n  (due to too long length codes), error 55 will happen\n  */\n  for(n = 0; n < tree->numcodes * 2; n++)\n  {\n    tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/\n  }\n\n  for(n = 0; n < tree->numcodes; n++) /*the codes*/\n  {\n    for(i = 0; i < tree->lengths[n]; i++) /*the bits for this code*/\n    {\n      unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);\n      if(treepos > tree->numcodes - 2) return 55; /*oversubscribed, see comment in lodepng_error_text*/\n      if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/\n      {\n        if(i + 1 == tree->lengths[n]) /*last bit*/\n        {\n          tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/\n          treepos = 0;\n        }\n        else\n        {\n          /*put address of the next step in here, first that address has to be found of course\n          (it's just nodefilled + 1)...*/\n          nodefilled++;\n          /*addresses encoded with numcodes added to it*/\n          tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;\n          treepos = nodefilled;\n        }\n      }\n      else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;\n    }\n  }\n\n  for(n = 0; n < tree->numcodes * 2; n++)\n  {\n    if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/\n  }\n\n  return 0;\n}\n\n/*\nSecond step for the ...makeFromLengths and ...makeFromFrequencies functions.\nnumcodes, lengths and maxbitlen must already be filled in correctly. return\nvalue is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)\n{\n  uivector blcount;\n  uivector nextcode;\n  unsigned bits, n, error = 0;\n\n  uivector_init(&blcount);\n  uivector_init(&nextcode);\n\n  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));\n  if(!tree->tree1d) error = 83; /*alloc fail*/\n\n  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)\n  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))\n    error = 83; /*alloc fail*/\n\n  if(!error)\n  {\n    /*step 1: count number of instances of each code length*/\n    for(bits = 0; bits < tree->numcodes; bits++) blcount.data[tree->lengths[bits]]++;\n    /*step 2: generate the nextcode values*/\n    for(bits = 1; bits <= tree->maxbitlen; bits++)\n    {\n      nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;\n    }\n    /*step 3: generate all the codes*/\n    for(n = 0; n < tree->numcodes; n++)\n    {\n      if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;\n    }\n  }\n\n  uivector_cleanup(&blcount);\n  uivector_cleanup(&nextcode);\n\n  if(!error) return HuffmanTree_make2DTree(tree);\n  else return error;\n}\n\n/*\ngiven the code lengths (as stored in the PNG file), generate the tree as defined\nby Deflate. maxbitlen is the maximum bits that a code in the tree can have.\nreturn value is error.\n*/\nstatic unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,\n                                            size_t numcodes, unsigned maxbitlen)\n{\n  unsigned i;\n  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  for(i = 0; i < numcodes; i++) tree->lengths[i] = bitlen[i];\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->maxbitlen = maxbitlen;\n  return HuffmanTree_makeFromLengths2(tree);\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*\nA coin, this is the terminology used for the package-merge algorithm and the\ncoin collector's problem. This is used to generate the huffman tree.\nA coin can be multiple coins (when they're merged)\n*/\ntypedef struct Coin\n{\n  uivector symbols;\n  float weight; /*the sum of all weights in this coin*/\n} Coin;\n\nstatic void coin_init(Coin* c)\n{\n  uivector_init(&c->symbols);\n}\n\n/*argument c is void* so that this dtor can be given as function pointer to the vector resize function*/\nstatic void coin_cleanup(void* c)\n{\n  uivector_cleanup(&((Coin*)c)->symbols);\n}\n\nstatic void coin_copy(Coin* c1, const Coin* c2)\n{\n  c1->weight = c2->weight;\n  uivector_copy(&c1->symbols, &c2->symbols);\n}\n\nstatic void add_coins(Coin* c1, const Coin* c2)\n{\n  size_t i;\n  for(i = 0; i < c2->symbols.size; i++) uivector_push_back(&c1->symbols, c2->symbols.data[i]);\n  c1->weight += c2->weight;\n}\n\nstatic void init_coins(Coin* coins, size_t num)\n{\n  size_t i;\n  for(i = 0; i < num; i++) coin_init(&coins[i]);\n}\n\nstatic void cleanup_coins(Coin* coins, size_t num)\n{\n  size_t i;\n  for(i = 0; i < num; i++) coin_cleanup(&coins[i]);\n}\n\nstatic int coin_compare(const void* a, const void* b) {\n  float wa = ((const Coin*)a)->weight;\n  float wb = ((const Coin*)b)->weight;\n  return wa > wb ? 1 : wa < wb ? -1 : 0;\n}\n\nstatic unsigned append_symbol_coins(Coin* coins, const unsigned* frequencies, unsigned numcodes, size_t sum)\n{\n  unsigned i;\n  unsigned j = 0; /*index of present symbols*/\n  for(i = 0; i < numcodes; i++)\n  {\n    if(frequencies[i] != 0) /*only include symbols that are present*/\n    {\n      coins[j].weight = frequencies[i] / (float)sum;\n      uivector_push_back(&coins[j].symbols, i);\n      j++;\n    }\n  }\n  return 0;\n}\n\nunsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\n                                      size_t numcodes, unsigned maxbitlen)\n{\n  unsigned i, j;\n  size_t sum = 0, numpresent = 0;\n  unsigned error = 0;\n  Coin* coins; /*the coins of the currently calculated row*/\n  Coin* prev_row; /*the previous row of coins*/\n  size_t numcoins;\n  size_t coinmem;\n\n  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/\n\n  for(i = 0; i < numcodes; i++)\n  {\n    if(frequencies[i] > 0)\n    {\n      numpresent++;\n      sum += frequencies[i];\n    }\n  }\n\n  for(i = 0; i < numcodes; i++) lengths[i] = 0;\n\n  /*ensure at least two present symbols. There should be at least one symbol\n  according to RFC 1951 section 3.2.7. To decoders incorrectly require two. To\n  make these work as well ensure there are at least two symbols. The\n  Package-Merge code below also doesn't work correctly if there's only one\n  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/\n  if(numpresent == 0)\n  {\n    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/\n  }\n  else if(numpresent == 1)\n  {\n    for(i = 0; i < numcodes; i++)\n    {\n      if(frequencies[i])\n      {\n        lengths[i] = 1;\n        lengths[i == 0 ? 1 : 0] = 1;\n        break;\n      }\n    }\n  }\n  else\n  {\n    /*Package-Merge algorithm represented by coin collector's problem\n    For every symbol, maxbitlen coins will be created*/\n\n    coinmem = numpresent * 2; /*max amount of coins needed with the current algo*/\n    coins = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);\n    prev_row = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);\n    if(!coins || !prev_row)\n    {\n      lodepng_free(coins);\n      lodepng_free(prev_row);\n      return 83; /*alloc fail*/\n    }\n    init_coins(coins, coinmem);\n    init_coins(prev_row, coinmem);\n\n    /*first row, lowest denominator*/\n    error = append_symbol_coins(coins, frequencies, numcodes, sum);\n    numcoins = numpresent;\n    qsort(coins, numcoins, sizeof(Coin), coin_compare);\n    if(!error)\n    {\n      unsigned numprev = 0;\n      for(j = 1; j <= maxbitlen && !error; j++) /*each of the remaining rows*/\n      {\n        unsigned tempnum;\n        Coin* tempcoins;\n        /*swap prev_row and coins, and their amounts*/\n        tempcoins = prev_row; prev_row = coins; coins = tempcoins;\n        tempnum = numprev; numprev = numcoins; numcoins = tempnum;\n\n        cleanup_coins(coins, numcoins);\n        init_coins(coins, numcoins);\n\n        numcoins = 0;\n\n        /*fill in the merged coins of the previous row*/\n        for(i = 0; i + 1 < numprev; i += 2)\n        {\n          /*merge prev_row[i] and prev_row[i + 1] into new coin*/\n          Coin* coin = &coins[numcoins++];\n          coin_copy(coin, &prev_row[i]);\n          add_coins(coin, &prev_row[i + 1]);\n        }\n        /*fill in all the original symbols again*/\n        if(j < maxbitlen)\n        {\n          error = append_symbol_coins(coins + numcoins, frequencies, numcodes, sum);\n          numcoins += numpresent;\n        }\n        qsort(coins, numcoins, sizeof(Coin), coin_compare);\n      }\n    }\n\n    if(!error)\n    {\n      /*calculate the lenghts of each symbol, as the amount of times a coin of each symbol is used*/\n      for(i = 0; i < numpresent - 1; i++)\n      {\n        Coin* coin = &coins[i];\n        for(j = 0; j < coin->symbols.size; j++) lengths[coin->symbols.data[j]]++;\n      }\n    }\n\n    cleanup_coins(coins, coinmem);\n    lodepng_free(coins);\n    cleanup_coins(prev_row, coinmem);\n    lodepng_free(prev_row);\n  }\n\n  return error;\n}\n\n/*Create the Huffman tree given the symbol frequencies*/\nstatic unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}\n\nstatic unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)\n{\n  return tree->tree1d[index];\n}\n\nstatic unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)\n{\n  return tree->lengths[index];\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/\nstatic unsigned generateFixedLitLenTree(HuffmanTree* tree)\n{\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/\n  for(i =   0; i <= 143; i++) bitlen[i] = 8;\n  for(i = 144; i <= 255; i++) bitlen[i] = 9;\n  for(i = 256; i <= 279; i++) bitlen[i] = 7;\n  for(i = 280; i <= 287; i++) bitlen[i] = 8;\n\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/\nstatic unsigned generateFixedDistanceTree(HuffmanTree* tree)\n{\n  unsigned i, error = 0;\n  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n  if(!bitlen) return 83; /*alloc fail*/\n\n  /*there are 32 distance codes, but 30-31 are unused*/\n  for(i = 0; i < NUM_DISTANCE_SYMBOLS; i++) bitlen[i] = 5;\n  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);\n\n  lodepng_free(bitlen);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/*\nreturns the code, or (unsigned)(-1) if error happened\ninbitlength is the length of the complete buffer, in bits (so its byte length times 8)\n*/\nstatic unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,\n                                    const HuffmanTree* codetree, size_t inbitlength)\n{\n  unsigned treepos = 0, ct;\n  for(;;)\n  {\n    if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/\n    /*\n    decode the symbol from the tree. The \"readBitFromStream\" code is inlined in\n    the expression below because this is the biggest bottleneck while decoding\n    */\n    ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];\n    (*bp)++;\n    if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/\n    else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/\n\n    if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/\n  }\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Inflator (Decompressor)                                                / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/\nstatic void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)\n{\n  /*TODO: check for out of memory errors*/\n  generateFixedLitLenTree(tree_ll);\n  generateFixedDistanceTree(tree_d);\n}\n\n/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/\nstatic unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,\n                                      const unsigned char* in, size_t* bp, size_t inlength)\n{\n  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/\n  unsigned error = 0;\n  unsigned n, HLIT, HDIST, HCLEN, i;\n  size_t inbitlength = inlength * 8;\n\n  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/\n  unsigned* bitlen_ll = 0; /*lit,len code lengths*/\n  unsigned* bitlen_d = 0; /*dist code lengths*/\n  /*code length code lengths (\"clcl\"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/\n  unsigned* bitlen_cl = 0;\n  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/\n\n  if((*bp) >> 3 >= inlength - 2) return 49; /*error: the bit pointer is or will go past the memory*/\n\n  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/\n  HLIT =  readBitsFromStream(bp, in, 5) + 257;\n  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/\n  HDIST = readBitsFromStream(bp, in, 5) + 1;\n  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/\n  HCLEN = readBitsFromStream(bp, in, 4) + 4;\n\n  HuffmanTree_init(&tree_cl);\n\n  while(!error)\n  {\n    /*read the code length codes out of 3 * (amount of code length codes) bits*/\n\n    bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));\n    if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);\n\n    for(i = 0; i < NUM_CODE_LENGTH_CODES; i++)\n    {\n      if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);\n      else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/\n    }\n\n    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);\n    if(error) break;\n\n    /*now we can use this tree to read the lengths for the tree that this function will return*/\n    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));\n    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));\n    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);\n    for(i = 0; i < NUM_DEFLATE_CODE_SYMBOLS; i++) bitlen_ll[i] = 0;\n    for(i = 0; i < NUM_DISTANCE_SYMBOLS; i++) bitlen_d[i] = 0;\n\n    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/\n    i = 0;\n    while(i < HLIT + HDIST)\n    {\n      unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);\n      if(code <= 15) /*a length code*/\n      {\n        if(i < HLIT) bitlen_ll[i] = code;\n        else bitlen_d[i - HLIT] = code;\n        i++;\n      }\n      else if(code == 16) /*repeat previous*/\n      {\n        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/\n        unsigned value; /*set value to the previous code*/\n\n        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\n        if (i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/\n\n        replength += readBitsFromStream(bp, in, 2);\n\n        if(i < HLIT + 1) value = bitlen_ll[i - 1];\n        else value = bitlen_d[i - HLIT - 1];\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; n++)\n        {\n          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/\n          if(i < HLIT) bitlen_ll[i] = value;\n          else bitlen_d[i - HLIT] = value;\n          i++;\n        }\n      }\n      else if(code == 17) /*repeat \"0\" 3-10 times*/\n      {\n        unsigned replength = 3; /*read in the bits that indicate repeat length*/\n        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\n\n        replength += readBitsFromStream(bp, in, 3);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; n++)\n        {\n          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          i++;\n        }\n      }\n      else if(code == 18) /*repeat \"0\" 11-138 times*/\n      {\n        unsigned replength = 11; /*read in the bits that indicate repeat length*/\n        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/\n\n        replength += readBitsFromStream(bp, in, 7);\n\n        /*repeat this value in the next lengths*/\n        for(n = 0; n < replength; n++)\n        {\n          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/\n\n          if(i < HLIT) bitlen_ll[i] = 0;\n          else bitlen_d[i - HLIT] = 0;\n          i++;\n        }\n      }\n      else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\n      {\n        if(code == (unsigned)(-1))\n        {\n          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n          (10=no endcode, 11=wrong jump outside of tree)*/\n          error = (*bp) > inbitlength ? 10 : 11;\n        }\n        else error = 16; /*unexisting code, this can never happen*/\n        break;\n      }\n    }\n    if(error) break;\n\n    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/\n\n    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/\n    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);\n    if(error) break;\n    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);\n\n    break; /*end of error-while*/\n  }\n\n  lodepng_free(bitlen_cl);\n  lodepng_free(bitlen_ll);\n  lodepng_free(bitlen_d);\n  HuffmanTree_cleanup(&tree_cl);\n\n  return error;\n}\n\n/*inflate a block with dynamic of fixed Huffman tree*/\nstatic unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,\n                                    size_t* pos, size_t inlength, unsigned btype)\n{\n  unsigned error = 0;\n  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/\n  HuffmanTree tree_d; /*the huffman tree for distance codes*/\n  size_t inbitlength = inlength * 8;\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);\n  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);\n\n  while(!error) /*decode all symbols until end reached, breaks at end code*/\n  {\n    /*code_ll is literal, length or end code*/\n    unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);\n    if(code_ll <= 255) /*literal symbol*/\n    {\n      if((*pos) >= out->size)\n      {\n        /*reserve more room at once*/\n        if(!ucvector_resize(out, ((*pos) + 1) * 2)) ERROR_BREAK(83 /*alloc fail*/);\n      }\n      out->data[(*pos)] = (unsigned char)(code_ll);\n      (*pos)++;\n    }\n    else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/\n    {\n      unsigned code_d, distance;\n      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/\n      size_t start, forward, backward, length;\n\n      /*part 1: get length base*/\n      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];\n\n      /*part 2: get extra bits and add the value of that to length*/\n      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];\n      if(*bp >= inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\n      length += readBitsFromStream(bp, in, numextrabits_l);\n\n      /*part 3: get distance code*/\n      code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);\n      if(code_d > 29)\n      {\n        if(code_ll == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\n        {\n          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n          (10=no endcode, 11=wrong jump outside of tree)*/\n          error = (*bp) > inlength * 8 ? 10 : 11;\n        }\n        else error = 18; /*error: invalid distance code (30-31 are never used)*/\n        break;\n      }\n      distance = DISTANCEBASE[code_d];\n\n      /*part 4: get extra bits from distance*/\n      numextrabits_d = DISTANCEEXTRA[code_d];\n      if(*bp >= inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/\n\n      distance += readBitsFromStream(bp, in, numextrabits_d);\n\n      /*part 5: fill in all the out[n] values based on the length and dist*/\n      start = (*pos);\n      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/\n      backward = start - distance;\n      if((*pos) + length >= out->size)\n      {\n        /*reserve more room at once*/\n        if(!ucvector_resize(out, ((*pos) + length) * 2)) ERROR_BREAK(83 /*alloc fail*/);\n      }\n\n      for(forward = 0; forward < length; forward++)\n      {\n        out->data[(*pos)] = out->data[backward];\n        (*pos)++;\n        backward++;\n        if(backward >= start) backward = start - distance;\n      }\n    }\n    else if(code_ll == 256)\n    {\n      break; /*end code, break the loop*/\n    }\n    else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/\n    {\n      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol\n      (10=no endcode, 11=wrong jump outside of tree)*/\n      error = (*bp) > inlength * 8 ? 10 : 11;\n      break;\n    }\n  }\n\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)\n{\n  /*go to first boundary of byte*/\n  size_t p;\n  unsigned LEN, NLEN, n, error = 0;\n  while(((*bp) & 0x7) != 0) (*bp)++;\n  p = (*bp) / 8; /*byte position*/\n\n  /*read LEN (2 bytes) and NLEN (2 bytes)*/\n  if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/\n  LEN = in[p] + 256u * in[p + 1]; p += 2;\n  NLEN = in[p] + 256u * in[p + 1]; p += 2;\n\n  /*check if 16-bit NLEN is really the one's complement of LEN*/\n  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/\n\n  if((*pos) + LEN >= out->size)\n  {\n    if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/\n  }\n\n  /*read the literal data: LEN bytes are now stored in the out buffer*/\n  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/\n  for(n = 0; n < LEN; n++) out->data[(*pos)++] = in[p++];\n\n  (*bp) = p * 8;\n\n  return error;\n}\n\nstatic unsigned lodepng_inflatev(ucvector* out,\n                                 const unsigned char* in, size_t insize,\n                                 const LodePNGDecompressSettings* settings)\n{\n  /*bit pointer in the \"in\" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/\n  size_t bp = 0;\n  unsigned BFINAL = 0;\n  size_t pos = 0; /*byte position in the out buffer*/\n\n  unsigned error = 0;\n\n  (void)settings;\n\n  while(!BFINAL)\n  {\n    unsigned BTYPE;\n    if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/\n    BFINAL = readBitFromStream(&bp, in);\n    BTYPE = 1u * readBitFromStream(&bp, in);\n    BTYPE += 2u * readBitFromStream(&bp, in);\n\n    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/\n    else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/\n    else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/\n\n    if(error) return error;\n  }\n\n  /*Only now we know the true size of out, resize it to that*/\n  if(!ucvector_resize(out, pos)) error = 83; /*alloc fail*/\n\n  return error;\n}\n\nunsigned lodepng_inflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGDecompressSettings* settings)\n{\n  unsigned error;\n  ucvector v;\n  ucvector_init_buffer(&v, *out, *outsize);\n  error = lodepng_inflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned inflate(unsigned char** out, size_t* outsize,\n                        const unsigned char* in, size_t insize,\n                        const LodePNGDecompressSettings* settings)\n{\n  if(settings->custom_inflate)\n  {\n    return settings->custom_inflate(out, outsize, in, insize, settings);\n  }\n  else\n  {\n    return lodepng_inflate(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Deflator (Compressor)                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;\n\n/*bitlen is the size in bits of the code*/\nstatic void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)\n{\n  addBitsToStreamReversed(bp, compressed, code, bitlen);\n}\n\n/*search the index in the array, that has the largest value smaller than or equal to the given value,\ngiven array must be sorted (if no value is smaller, it returns the size of the given array)*/\nstatic size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)\n{\n  /*linear search implementation*/\n  /*for(size_t i = 1; i < array_size; i++) if(array[i] > value) return i - 1;\n  return array_size - 1;*/\n\n  /*binary search implementation (not that much faster) (precondition: array_size > 0)*/\n  size_t left  = 1;\n  size_t right = array_size - 1;\n  while(left <= right)\n  {\n    size_t mid = (left + right) / 2;\n    if(array[mid] <= value) left = mid + 1; /*the value to find is more to the right*/\n    else if(array[mid - 1] > value) right = mid - 1; /*the value to find is more to the left*/\n    else return mid - 1;\n  }\n  return array_size - 1;\n}\n\nstatic void addLengthDistance(uivector* values, size_t length, size_t distance)\n{\n  /*values in encoded vector are those used by deflate:\n  0-255: literal bytes\n  256: end\n  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)\n  286-287: invalid*/\n\n  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);\n  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);\n  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);\n  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);\n\n  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);\n  uivector_push_back(values, extra_length);\n  uivector_push_back(values, dist_code);\n  uivector_push_back(values, extra_distance);\n}\n\n/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3\nbytes as input because 3 is the minimum match length for deflate*/\nstatic const unsigned HASH_NUM_VALUES = 65536;\nstatic const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/\n\ntypedef struct Hash\n{\n  int* head; /*hash value to head circular pos - can be outdated if went around window*/\n  /*circular pos to prev circular pos*/\n  unsigned short* chain;\n  int* val; /*circular pos to hash value*/\n\n  /*TODO: do this not only for zeros but for any repeated byte. However for PNG\n  it's always going to be the zeros that dominate, so not important for PNG*/\n  int* headz; /*similar to head, but for chainz*/\n  unsigned short* chainz; /*those with same amount of zeros*/\n  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/\n} Hash;\n\nstatic unsigned hash_init(Hash* hash, unsigned windowsize)\n{\n  unsigned i;\n  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);\n  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);\n  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));\n  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);\n\n  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)\n  {\n    return 83; /*alloc fail*/\n  }\n\n  /*initialize hash table*/\n  for(i = 0; i < HASH_NUM_VALUES; i++) hash->head[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->val[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->chain[i] = i; /*same value as index indicates uninitialized*/\n\n  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; i++) hash->headz[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->chainz[i] = i; /*same value as index indicates uninitialized*/\n\n  return 0;\n}\n\nstatic void hash_cleanup(Hash* hash)\n{\n  lodepng_free(hash->head);\n  lodepng_free(hash->val);\n  lodepng_free(hash->chain);\n\n  lodepng_free(hash->zeros);\n  lodepng_free(hash->headz);\n  lodepng_free(hash->chainz);\n}\n\n\n\nstatic unsigned getHash(const unsigned char* data, size_t size, size_t pos)\n{\n  unsigned result = 0;\n  if (pos + 2 < size)\n  {\n    /*A simple shift and xor hash is used. Since the data of PNGs is dominated\n    by zeroes due to the filters, a better hash does not have a significant\n    effect on speed in traversing the chain, and causes more time spend on\n    calculating the hash.*/\n    result ^= (unsigned)(data[pos + 0] << 0u);\n    result ^= (unsigned)(data[pos + 1] << 4u);\n    result ^= (unsigned)(data[pos + 2] << 8u);\n  } else {\n    size_t amount, i;\n    if(pos >= size) return 0;\n    amount = size - pos;\n    for(i = 0; i < amount; i++) result ^= (unsigned)(data[pos + i] << (i * 8u));\n  }\n  return result & HASH_BIT_MASK;\n}\n\nstatic unsigned countZeros(const unsigned char* data, size_t size, size_t pos)\n{\n  const unsigned char* start = data + pos;\n  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;\n  if(end > data + size) end = data + size;\n  data = start;\n  while (data != end && *data == 0) data++;\n  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/\n  return (unsigned)(data - start);\n}\n\n/*wpos = pos & (windowsize - 1)*/\nstatic void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)\n{\n  hash->val[wpos] = (int)hashval;\n  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];\n  hash->head[hashval] = wpos;\n\n  hash->zeros[wpos] = numzeros;\n  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];\n  hash->headz[numzeros] = wpos;\n}\n\n/*\nLZ77-encode the data. Return value is error code. The input are raw bytes, the output\nis in the form of unsigned integers with codes representing for example literal bytes, or\nlength/distance pairs.\nIt uses a hash table technique to let it encode faster. When doing LZ77 encoding, a\nsliding window (of windowsize) is used, and all past bytes in that window can be used as\nthe \"dictionary\". A brute force search through all possible distances would be slow, and\nthis hash technique is one out of several ways to speed this up.\n*/\nstatic unsigned encodeLZ77(uivector* out, Hash* hash,\n                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,\n                           unsigned minmatch, unsigned nicematch, unsigned lazymatching)\n{\n  size_t pos;\n  unsigned i, error = 0;\n  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/\n  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;\n  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;\n\n  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/\n  unsigned numzeros = 0;\n\n  unsigned offset; /*the offset represents the distance in LZ77 terminology*/\n  unsigned length;\n  unsigned lazy = 0;\n  unsigned lazylength = 0, lazyoffset = 0;\n  unsigned hashval;\n  unsigned current_offset, current_length;\n  unsigned prev_offset;\n  const unsigned char *lastptr, *foreptr, *backptr;\n  unsigned hashpos;\n\n  if(windowsize <= 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/\n  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/\n\n  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;\n\n  for(pos = inpos; pos < insize; pos++)\n  {\n    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/\n    unsigned chainlength = 0;\n\n    hashval = getHash(in, insize, pos);\n\n    if(usezeros && hashval == 0)\n    {\n      if (numzeros == 0) numzeros = countZeros(in, insize, pos);\n      else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) numzeros--;\n    }\n    else\n    {\n      numzeros = 0;\n    }\n\n    updateHashChain(hash, wpos, hashval, numzeros);\n\n    /*the length and offset found for the current position*/\n    length = 0;\n    offset = 0;\n\n    hashpos = hash->chain[wpos];\n\n    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];\n\n    /*search for the longest string*/\n    prev_offset = 0;\n    for(;;)\n    {\n      if(chainlength++ >= maxchainlength) break;\n      current_offset = hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize;\n\n      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/\n      prev_offset = current_offset;\n      if(current_offset > 0)\n      {\n        /*test the next characters*/\n        foreptr = &in[pos];\n        backptr = &in[pos - current_offset];\n\n        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/\n        if(numzeros >= 3)\n        {\n          unsigned skip = hash->zeros[hashpos];\n          if(skip > numzeros) skip = numzeros;\n          backptr += skip;\n          foreptr += skip;\n        }\n\n        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/\n        {\n          ++backptr;\n          ++foreptr;\n        }\n        current_length = (unsigned)(foreptr - &in[pos]);\n\n        if(current_length > length)\n        {\n          length = current_length; /*the longest length*/\n          offset = current_offset; /*the offset that is related to this longest length*/\n          /*jump out once a length of max length is found (speed gain). This also jumps\n          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/\n          if(current_length >= nicematch) break;\n        }\n      }\n\n      if(hashpos == hash->chain[hashpos]) break;\n      \n      if(numzeros >= 3 && length > numzeros) {\n        hashpos = hash->chainz[hashpos];\n        if(hash->zeros[hashpos] != numzeros) break;\n      } else {\n        hashpos = hash->chain[hashpos];\n        /*outdated hash value, happens if particular value was not encountered in whole last window*/\n        if(hash->val[hashpos] != (int)hashval) break;\n      }\n    }\n\n    if(lazymatching)\n    {\n      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)\n      {\n        lazy = 1;\n        lazylength = length;\n        lazyoffset = offset;\n        continue; /*try the next byte*/\n      }\n      if(lazy)\n      {\n        lazy = 0;\n        if(pos == 0) ERROR_BREAK(81);\n        if(length > lazylength + 1)\n        {\n          /*push the previous character as literal*/\n          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);\n        }\n        else\n        {\n          length = lazylength;\n          offset = lazyoffset;\n          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/\n          hash->headz[numzeros] = -1; /*idem*/\n          pos--;\n        }\n      }\n    }\n    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);\n\n    /*encode it as length/distance pair or literal value*/\n    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/\n    {\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    }\n    else if(length < minmatch || (length == 3 && offset > 4096))\n    {\n      /*compensate for the fact that longer offsets have more extra bits, a\n      length of only 3 may be not worth it then*/\n      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);\n    }\n    else\n    {\n      addLengthDistance(out, length, offset);\n      for(i = 1; i < length; i++)\n      {\n        pos++;\n        wpos = pos & (windowsize - 1);\n        hashval = getHash(in, insize, pos);\n        if(usezeros && hashval == 0)\n        {\n          if (numzeros == 0) numzeros = countZeros(in, insize, pos);\n          else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) numzeros--;\n        }\n        else\n        {\n          numzeros = 0;\n        }\n        updateHashChain(hash, wpos, hashval, numzeros);\n      }\n    }\n  } /*end of the loop through each character of input*/\n\n  return error;\n}\n\n/* /////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)\n{\n  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,\n  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/\n\n  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;\n  unsigned datapos = 0;\n  for(i = 0; i < numdeflateblocks; i++)\n  {\n    unsigned BFINAL, BTYPE, LEN, NLEN;\n    unsigned char firstbyte;\n\n    BFINAL = (i == numdeflateblocks - 1);\n    BTYPE = 0;\n\n    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));\n    ucvector_push_back(out, firstbyte);\n\n    LEN = 65535;\n    if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;\n    NLEN = 65535 - LEN;\n\n    ucvector_push_back(out, (unsigned char)(LEN % 256));\n    ucvector_push_back(out, (unsigned char)(LEN / 256));\n    ucvector_push_back(out, (unsigned char)(NLEN % 256));\n    ucvector_push_back(out, (unsigned char)(NLEN / 256));\n\n    /*Decompressed data*/\n    for(j = 0; j < 65535 && datapos < datasize; j++)\n    {\n      ucvector_push_back(out, data[datapos++]);\n    }\n  }\n\n  return 0;\n}\n\n/*\nwrite the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.\ntree_ll: the tree for lit and len codes.\ntree_d: the tree for distance codes.\n*/\nstatic void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,\n                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d)\n{\n  size_t i = 0;\n  for(i = 0; i < lz77_encoded->size; i++)\n  {\n    unsigned val = lz77_encoded->data[i];\n    addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));\n    if(val > 256) /*for a length code, 3 more things have to be added*/\n    {\n      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;\n      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];\n      unsigned length_extra_bits = lz77_encoded->data[++i];\n\n      unsigned distance_code = lz77_encoded->data[++i];\n\n      unsigned distance_index = distance_code;\n      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];\n      unsigned distance_extra_bits = lz77_encoded->data[++i];\n\n      addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),\n                       HuffmanTree_getLength(tree_d, distance_code));\n      addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);\n    }\n  }\n}\n\n/*Deflate for a block of type \"dynamic\", that is, with freely, optimally, created huffman trees*/\nstatic unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,\n                               const unsigned char* data, size_t datapos, size_t dataend,\n                               const LodePNGCompressSettings* settings, unsigned final)\n{\n  unsigned error = 0;\n\n  /*\n  A block is compressed as follows: The PNG data is lz77 encoded, resulting in\n  literal bytes and length/distance pairs. This is then huffman compressed with\n  two huffman trees. One huffman tree is used for the lit and len values (\"ll\"),\n  another huffman tree is used for the dist values (\"d\"). These two trees are\n  stored using their code lengths, and to compress even more these code lengths\n  are also run-length encoded and huffman compressed. This gives a huffman tree\n  of code lengths \"cl\". The code lenghts used to describe this third tree are\n  the code length code lengths (\"clcl\").\n  */\n\n  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/\n  uivector lz77_encoded;\n  HuffmanTree tree_ll; /*tree for lit,len values*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/\n  uivector frequencies_ll; /*frequency of lit,len codes*/\n  uivector frequencies_d; /*frequency of dist codes*/\n  uivector frequencies_cl; /*frequency of code length codes*/\n  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/\n  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/\n  /*bitlen_cl is the code length code lengths (\"clcl\"). The bit lengths of codes to represent tree_cl\n  (these are written as is in the file, it would be crazy to compress these using yet another huffman\n  tree that needs to be represented by yet another set of code lengths)*/\n  uivector bitlen_cl;\n  size_t datasize = dataend - datapos;\n\n  /*\n  Due to the huffman compression of huffman tree representations (\"two levels\"), there are some anologies:\n  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.\n  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.\n  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.\n  */\n\n  unsigned BFINAL = final;\n  size_t numcodes_ll, numcodes_d, i;\n  unsigned HLIT, HDIST, HCLEN;\n\n  uivector_init(&lz77_encoded);\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n  HuffmanTree_init(&tree_cl);\n  uivector_init(&frequencies_ll);\n  uivector_init(&frequencies_d);\n  uivector_init(&frequencies_cl);\n  uivector_init(&bitlen_lld);\n  uivector_init(&bitlen_lld_e);\n  uivector_init(&bitlen_cl);\n\n  /*This while loop never loops due to a break at the end, it is here to\n  allow breaking out of it to the cleanup phase on error conditions.*/\n  while(!error)\n  {\n    if(settings->use_lz77)\n    {\n      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                         settings->minmatch, settings->nicematch, settings->lazymatching);\n      if(error) break;\n    }\n    else\n    {\n      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);\n      for(i = datapos; i < dataend; i++) lz77_encoded.data[i] = data[i]; /*no LZ77, but still will be Huffman compressed*/\n    }\n\n    if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);\n    if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);\n\n    /*Count the frequencies of lit, len and dist codes*/\n    for(i = 0; i < lz77_encoded.size; i++)\n    {\n      unsigned symbol = lz77_encoded.data[i];\n      frequencies_ll.data[symbol]++;\n      if(symbol > 256)\n      {\n        unsigned dist = lz77_encoded.data[i + 2];\n        frequencies_d.data[dist]++;\n        i += 3;\n      }\n    }\n    frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/\n\n    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/\n    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);\n    if(error) break;\n    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/\n    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);\n    if(error) break;\n\n    numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;\n    numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;\n    /*store the code lengths of both generated trees in bitlen_lld*/\n    for(i = 0; i < numcodes_ll; i++) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));\n    for(i = 0; i < numcodes_d; i++) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));\n\n    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),\n    17 (3-10 zeroes), 18 (11-138 zeroes)*/\n    for(i = 0; i < (unsigned)bitlen_lld.size; i++)\n    {\n      unsigned j = 0; /*amount of repititions*/\n      while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) j++;\n\n      if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/\n      {\n        j++; /*include the first zero*/\n        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/\n        {\n          uivector_push_back(&bitlen_lld_e, 17);\n          uivector_push_back(&bitlen_lld_e, j - 3);\n        }\n        else /*repeat code 18 supports max 138 zeroes*/\n        {\n          if(j > 138) j = 138;\n          uivector_push_back(&bitlen_lld_e, 18);\n          uivector_push_back(&bitlen_lld_e, j - 11);\n        }\n        i += (j - 1);\n      }\n      else if(j >= 3) /*repeat code for value other than zero*/\n      {\n        size_t k;\n        unsigned num = j / 6, rest = j % 6;\n        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);\n        for(k = 0; k < num; k++)\n        {\n          uivector_push_back(&bitlen_lld_e, 16);\n          uivector_push_back(&bitlen_lld_e, 6 - 3);\n        }\n        if(rest >= 3)\n        {\n          uivector_push_back(&bitlen_lld_e, 16);\n          uivector_push_back(&bitlen_lld_e, rest - 3);\n        }\n        else j -= rest;\n        i += j;\n      }\n      else /*too short to benefit from repeat code*/\n      {\n        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);\n      }\n    }\n\n    /*generate tree_cl, the huffmantree of huffmantrees*/\n\n    if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);\n    for(i = 0; i < bitlen_lld_e.size; i++)\n    {\n      frequencies_cl.data[bitlen_lld_e.data[i]]++;\n      /*after a repeat code come the bits that specify the number of repetitions,\n      those don't need to be in the frequencies_cl calculation*/\n      if(bitlen_lld_e.data[i] >= 16) i++;\n    }\n\n    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,\n                                            frequencies_cl.size, frequencies_cl.size, 7);\n    if(error) break;\n\n    if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);\n    for(i = 0; i < tree_cl.numcodes; i++)\n    {\n      /*lenghts of code length tree is in the order as specified by deflate*/\n      bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);\n    }\n    while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)\n    {\n      /*remove zeros at the end, but minimum size must be 4*/\n      if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);\n    }\n    if(error) break;\n\n    /*\n    Write everything into the output\n\n    After the BFINAL and BTYPE, the dynamic block consists out of the following:\n    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN\n    - (HCLEN+4)*3 bits code lengths of code length alphabet\n    - HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - HDIST + 1 code lengths of distance alphabet (encoded using the code length\n      alphabet, + possible repetition codes 16, 17, 18)\n    - compressed data\n    - 256 (end code)\n    */\n\n    /*Write block type*/\n    addBitToStream(bp, out, BFINAL);\n    addBitToStream(bp, out, 0); /*first bit of BTYPE \"dynamic\"*/\n    addBitToStream(bp, out, 1); /*second bit of BTYPE \"dynamic\"*/\n\n    /*write the HLIT, HDIST and HCLEN values*/\n    HLIT = (unsigned)(numcodes_ll - 257);\n    HDIST = (unsigned)(numcodes_d - 1);\n    HCLEN = (unsigned)bitlen_cl.size - 4;\n    /*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/\n    while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) HCLEN--;\n    addBitsToStream(bp, out, HLIT, 5);\n    addBitsToStream(bp, out, HDIST, 5);\n    addBitsToStream(bp, out, HCLEN, 4);\n\n    /*write the code lenghts of the code length alphabet*/\n    for(i = 0; i < HCLEN + 4; i++) addBitsToStream(bp, out, bitlen_cl.data[i], 3);\n\n    /*write the lenghts of the lit/len AND the dist alphabet*/\n    for(i = 0; i < bitlen_lld_e.size; i++)\n    {\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),\n                       HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));\n      /*extra bits of repeat codes*/\n      if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);\n      else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);\n      else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);\n    }\n\n    /*write the compressed data symbols*/\n    writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);\n    /*error: the length of the end code 256 must be larger than 0*/\n    if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);\n\n    /*write the end code*/\n    addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));\n\n    break; /*end of error-while*/\n  }\n\n  /*cleanup*/\n  uivector_cleanup(&lz77_encoded);\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n  HuffmanTree_cleanup(&tree_cl);\n  uivector_cleanup(&frequencies_ll);\n  uivector_cleanup(&frequencies_d);\n  uivector_cleanup(&frequencies_cl);\n  uivector_cleanup(&bitlen_lld_e);\n  uivector_cleanup(&bitlen_lld);\n  uivector_cleanup(&bitlen_cl);\n\n  return error;\n}\n\nstatic unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,\n                             const unsigned char* data,\n                             size_t datapos, size_t dataend,\n                             const LodePNGCompressSettings* settings, unsigned final)\n{\n  HuffmanTree tree_ll; /*tree for literal values and length codes*/\n  HuffmanTree tree_d; /*tree for distance codes*/\n\n  unsigned BFINAL = final;\n  unsigned error = 0;\n  size_t i;\n\n  HuffmanTree_init(&tree_ll);\n  HuffmanTree_init(&tree_d);\n\n  generateFixedLitLenTree(&tree_ll);\n  generateFixedDistanceTree(&tree_d);\n\n  addBitToStream(bp, out, BFINAL);\n  addBitToStream(bp, out, 1); /*first bit of BTYPE*/\n  addBitToStream(bp, out, 0); /*second bit of BTYPE*/\n\n  if(settings->use_lz77) /*LZ77 encoded*/\n  {\n    uivector lz77_encoded;\n    uivector_init(&lz77_encoded);\n    error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,\n                       settings->minmatch, settings->nicematch, settings->lazymatching);\n    if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);\n    uivector_cleanup(&lz77_encoded);\n  }\n  else /*no LZ77, but still will be Huffman compressed*/\n  {\n    for(i = datapos; i < dataend; i++)\n    {\n      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));\n    }\n  }\n  /*add END code*/\n  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));\n\n  /*cleanup*/\n  HuffmanTree_cleanup(&tree_ll);\n  HuffmanTree_cleanup(&tree_d);\n\n  return error;\n}\n\nstatic unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,\n                                 const LodePNGCompressSettings* settings)\n{\n  unsigned error = 0;\n  size_t i, blocksize, numdeflateblocks;\n  size_t bp = 0; /*the bit pointer*/\n  Hash hash;\n\n  if(settings->btype > 2) return 61;\n  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);\n  else if(settings->btype == 1) blocksize = insize;\n  else /*if(settings->btype == 2)*/\n  {\n    blocksize = insize / 8 + 8;\n    if(blocksize < 65535) blocksize = 65535;\n  }\n\n  numdeflateblocks = (insize + blocksize - 1) / blocksize;\n  if(numdeflateblocks == 0) numdeflateblocks = 1;\n\n  error = hash_init(&hash, settings->windowsize);\n  if(error) return error;\n\n  for(i = 0; i < numdeflateblocks && !error; i++)\n  {\n    unsigned final = (i == numdeflateblocks - 1);\n    size_t start = i * blocksize;\n    size_t end = start + blocksize;\n    if(end > insize) end = insize;\n\n    if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);\n    else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);\n  }\n\n  hash_cleanup(&hash);\n\n  return error;\n}\n\nunsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings)\n{\n  unsigned error;\n  ucvector v;\n  ucvector_init_buffer(&v, *out, *outsize);\n  error = lodepng_deflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}\n\nstatic unsigned deflate(unsigned char** out, size_t* outsize,\n                        const unsigned char* in, size_t insize,\n                        const LodePNGCompressSettings* settings)\n{\n  if(settings->custom_deflate)\n  {\n    return settings->custom_deflate(out, outsize, in, insize, settings);\n  }\n  else\n  {\n    return lodepng_deflate(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Adler32                                                                  */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)\n{\n   unsigned s1 = adler & 0xffff;\n   unsigned s2 = (adler >> 16) & 0xffff;\n\n  while(len > 0)\n  {\n    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5550 ? 5550 : len;\n    len -= amount;\n    while(amount > 0)\n    {\n      s1 += (*data++);\n      s2 += s1;\n      amount--;\n    }\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}\n\n/*Return the adler32 of the bytes data[0..len-1]*/\nstatic unsigned adler32(const unsigned char* data, unsigned len)\n{\n  return update_adler32(1L, data, len);\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Zlib                                                                   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nunsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                 size_t insize, const LodePNGDecompressSettings* settings)\n{\n  unsigned error = 0;\n  unsigned CM, CINFO, FDICT;\n\n  if(insize < 2) return 53; /*error, size of zlib data too small*/\n  /*read information from zlib header*/\n  if((in[0] * 256 + in[1]) % 31 != 0)\n  {\n    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/\n    return 24;\n  }\n\n  CM = in[0] & 15;\n  CINFO = (in[0] >> 4) & 15;\n  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/\n  FDICT = (in[1] >> 5) & 1;\n  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/\n\n  if(CM != 8 || CINFO > 7)\n  {\n    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/\n    return 25;\n  }\n  if(FDICT != 0)\n  {\n    /*error: the specification of PNG says about the zlib stream:\n      \"The additional flags shall not specify a preset dictionary.\"*/\n    return 26;\n  }\n\n  error = inflate(out, outsize, in + 2, insize - 2, settings);\n  if(error) return error;\n\n  if(!settings->ignore_adler32)\n  {\n    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);\n    unsigned checksum = adler32(*out, (unsigned)(*outsize));\n    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/\n  }\n\n  return 0; /*no error*/\n}\n\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                size_t insize, const LodePNGDecompressSettings* settings)\n{\n  if(settings->custom_zlib)\n  {\n    return settings->custom_zlib(out, outsize, in, insize, settings);\n  }\n  else\n  {\n    return lodepng_zlib_decompress(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nunsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                               size_t insize, const LodePNGCompressSettings* settings)\n{\n  /*initially, *out must be NULL and outsize 0, if you just give some random *out\n  that's pointing to a non allocated buffer, this'll crash*/\n  ucvector outv;\n  size_t i;\n  unsigned error;\n  unsigned char* deflatedata = 0;\n  size_t deflatesize = 0;\n\n  unsigned ADLER32;\n  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/\n  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/\n  unsigned FLEVEL = 0;\n  unsigned FDICT = 0;\n  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;\n  unsigned FCHECK = 31 - CMFFLG % 31;\n  CMFFLG += FCHECK;\n\n  /*ucvector-controlled version of the output buffer, for dynamic array*/\n  ucvector_init_buffer(&outv, *out, *outsize);\n\n  ucvector_push_back(&outv, (unsigned char)(CMFFLG / 256));\n  ucvector_push_back(&outv, (unsigned char)(CMFFLG % 256));\n\n  error = deflate(&deflatedata, &deflatesize, in, insize, settings);\n\n  if(!error)\n  {\n    ADLER32 = adler32(in, (unsigned)insize);\n    for(i = 0; i < deflatesize; i++) ucvector_push_back(&outv, deflatedata[i]);\n    lodepng_free(deflatedata);\n    lodepng_add32bitInt(&outv, ADLER32);\n  }\n\n  *out = outv.data;\n  *outsize = outv.size;\n\n  return error;\n}\n\n/* compress using the default or custom zlib function */\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings)\n{\n  if(settings->custom_zlib)\n  {\n    return settings->custom_zlib(out, outsize, in, insize, settings);\n  }\n  else\n  {\n    return lodepng_zlib_compress(out, outsize, in, insize, settings);\n  }\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#else /*no LODEPNG_COMPILE_ZLIB*/\n\n#ifdef LODEPNG_COMPILE_DECODER\nstatic unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                size_t insize, const LodePNGDecompressSettings* settings)\n{\n  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,\n                              size_t insize, const LodePNGCompressSettings* settings)\n{\n  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */\n  return settings->custom_zlib(out, outsize, in, insize, settings);\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#endif /*LODEPNG_COMPILE_ZLIB*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/*this is a good tradeoff between speed and compression ratio*/\n#define DEFAULT_WINDOWSIZE 2048\n\nvoid lodepng_compress_settings_init(LodePNGCompressSettings* settings)\n{\n  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/\n  settings->btype = 2;\n  settings->use_lz77 = 1;\n  settings->windowsize = DEFAULT_WINDOWSIZE;\n  settings->minmatch = 3;\n  settings->nicematch = 128;\n  settings->lazymatching = 1;\n\n  settings->custom_zlib = 0;\n  settings->custom_deflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};\n\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nvoid lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)\n{\n  settings->ignore_adler32 = 0;\n\n  settings->custom_zlib = 0;\n  settings->custom_inflate = 0;\n  settings->custom_context = 0;\n}\n\nconst LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // End of Zlib related code. Begin of PNG related code.                 // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_PNG\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / CRC32                                                                  / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/* CRC polynomial: 0xedb88320 */\nstatic unsigned lodepng_crc32_table[256] = {\n           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,\n   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,\n   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,\n   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,\n   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,\n   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,\n   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,\n   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,\n  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,\n  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,\n  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,\n  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,\n  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,\n  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,\n  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,\n  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,\n  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,\n  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,\n  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,\n  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,\n  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,\n  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,\n  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,\n  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,\n  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,\n  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,\n  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,\n  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,\n  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,\n  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,\n  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,\n  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u\n};\n\n/*Return the CRC of the bytes buf[0..len-1].*/\nunsigned lodepng_crc32(const unsigned char* buf, size_t len)\n{\n  unsigned c = 0xffffffffL;\n  size_t n;\n\n  for(n = 0; n < len; n++)\n  {\n    c = lodepng_crc32_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);\n  }\n  return c ^ 0xffffffffL;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nstatic unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)\n{\n  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);\n  (*bitpointer)++;\n  return result;\n}\n\nstatic unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\nstatic void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)\n{\n  /*the current bit in bitstream must be 0 for this to work*/\n  if(bit)\n  {\n    /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\n    bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));\n  }\n  (*bitpointer)++;\n}\n#endif /*LODEPNG_COMPILE_DECODER*/\n\nstatic void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)\n{\n  /*the current bit in bitstream may be 0 or 1 for this to work*/\n  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));\n  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));\n  (*bitpointer)++;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG chunks                                                             / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\nunsigned lodepng_chunk_length(const unsigned char* chunk)\n{\n  return lodepng_read32bitInt(&chunk[0]);\n}\n\nvoid lodepng_chunk_type(char type[5], const unsigned char* chunk)\n{\n  unsigned i;\n  for(i = 0; i < 4; i++) type[i] = (char)chunk[4 + i];\n  type[4] = 0; /*null termination char*/\n}\n\nunsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)\n{\n  if(strlen(type) != 4) return 0;\n  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);\n}\n\nunsigned char lodepng_chunk_ancillary(const unsigned char* chunk)\n{\n  return((chunk[4] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_private(const unsigned char* chunk)\n{\n  return((chunk[6] & 32) != 0);\n}\n\nunsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)\n{\n  return((chunk[7] & 32) != 0);\n}\n\nunsigned char* lodepng_chunk_data(unsigned char* chunk)\n{\n  return &chunk[8];\n}\n\nconst unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)\n{\n  return &chunk[8];\n}\n\nunsigned lodepng_chunk_check_crc(const unsigned char* chunk)\n{\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);\n  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/\n  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);\n  if(CRC != checksum) return 1;\n  else return 0;\n}\n\nvoid lodepng_chunk_generate_crc(unsigned char* chunk)\n{\n  unsigned length = lodepng_chunk_length(chunk);\n  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);\n  lodepng_set32bitInt(chunk + 8 + length, CRC);\n}\n\nunsigned char* lodepng_chunk_next(unsigned char* chunk)\n{\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  return &chunk[total_chunk_length];\n}\n\nconst unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)\n{\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  return &chunk[total_chunk_length];\n}\n\nunsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)\n{\n  unsigned i;\n  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;\n  unsigned char *chunk_start, *new_buffer;\n  size_t new_length = (*outlength) + total_chunk_length;\n  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/\n\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\n  if(!new_buffer) return 83; /*alloc fail*/\n  (*out) = new_buffer;\n  (*outlength) = new_length;\n  chunk_start = &(*out)[new_length - total_chunk_length];\n\n  for(i = 0; i < total_chunk_length; i++) chunk_start[i] = chunk[i];\n\n  return 0;\n}\n\nunsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,\n                              const char* type, const unsigned char* data)\n{\n  unsigned i;\n  unsigned char *chunk, *new_buffer;\n  size_t new_length = (*outlength) + length + 12;\n  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/\n  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);\n  if(!new_buffer) return 83; /*alloc fail*/\n  (*out) = new_buffer;\n  (*outlength) = new_length;\n  chunk = &(*out)[(*outlength) - length - 12];\n\n  /*1: length*/\n  lodepng_set32bitInt(chunk, (unsigned)length);\n\n  /*2: chunk name (4 letters)*/\n  chunk[4] = (unsigned char)type[0];\n  chunk[5] = (unsigned char)type[1];\n  chunk[6] = (unsigned char)type[2];\n  chunk[7] = (unsigned char)type[3];\n\n  /*3: the data*/\n  for(i = 0; i < length; i++) chunk[8 + i] = data[i];\n\n  /*4: CRC (of the chunkname characters and the data)*/\n  lodepng_chunk_generate_crc(chunk);\n\n  return 0;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / Color types and such                                                   / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*return type is a LodePNG error code*/\nstatic unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/\n{\n  switch(colortype)\n  {\n    case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/\n    case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/\n    case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/\n    case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/\n    case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/\n    default: return 31;\n  }\n  return 0; /*allowed color type / bits combination*/\n}\n\nstatic unsigned getNumColorChannels(LodePNGColorType colortype)\n{\n  switch(colortype)\n  {\n    case 0: return 1; /*grey*/\n    case 2: return 3; /*RGB*/\n    case 3: return 1; /*palette*/\n    case 4: return 2; /*grey + alpha*/\n    case 6: return 4; /*RGBA*/\n  }\n  return 0; /*unexisting color type*/\n}\n\nstatic unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)\n{\n  /*bits per pixel is amount of channels * bits per channel*/\n  return getNumColorChannels(colortype) * bitdepth;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\nvoid lodepng_color_mode_init(LodePNGColorMode* info)\n{\n  info->key_defined = 0;\n  info->key_r = info->key_g = info->key_b = 0;\n  info->colortype = LCT_RGBA;\n  info->bitdepth = 8;\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\nvoid lodepng_color_mode_cleanup(LodePNGColorMode* info)\n{\n  lodepng_palette_clear(info);\n}\n\nunsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)\n{\n  size_t i;\n  lodepng_color_mode_cleanup(dest);\n  *dest = *source;\n  if(source->palette)\n  {\n    dest->palette = (unsigned char*)lodepng_malloc(1024);\n    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/\n    for(i = 0; i < source->palettesize * 4; i++) dest->palette[i] = source->palette[i];\n  }\n  return 0;\n}\n\nstatic int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)\n{\n  size_t i;\n  if(a->colortype != b->colortype) return 0;\n  if(a->bitdepth != b->bitdepth) return 0;\n  if(a->key_defined != b->key_defined) return 0;\n  if(a->key_defined)\n  {\n    if(a->key_r != b->key_r) return 0;\n    if(a->key_g != b->key_g) return 0;\n    if(a->key_b != b->key_b) return 0;\n  }\n  if(a->palettesize != b->palettesize) return 0;\n  for(i = 0; i < a->palettesize * 4; i++)\n  {\n    if(a->palette[i] != b->palette[i]) return 0;\n  }\n  return 1;\n}\n\nvoid lodepng_palette_clear(LodePNGColorMode* info)\n{\n  if(info->palette) lodepng_free(info->palette);\n  info->palette = 0;\n  info->palettesize = 0;\n}\n\nunsigned lodepng_palette_add(LodePNGColorMode* info,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  unsigned char* data;\n  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with\n  the max of 256 colors, it'll have the exact alloc size*/\n  if(!info->palette) /*allocate palette if empty*/\n  {\n    /*room for 256 colors with 4 bytes each*/\n    data = (unsigned char*)lodepng_realloc(info->palette, 1024);\n    if(!data) return 83; /*alloc fail*/\n    else info->palette = data;\n  }\n  info->palette[4 * info->palettesize + 0] = r;\n  info->palette[4 * info->palettesize + 1] = g;\n  info->palette[4 * info->palettesize + 2] = b;\n  info->palette[4 * info->palettesize + 3] = a;\n  info->palettesize++;\n  return 0;\n}\n\nunsigned lodepng_get_bpp(const LodePNGColorMode* info)\n{\n  /*calculate bits per pixel out of colortype and bitdepth*/\n  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);\n}\n\nunsigned lodepng_get_channels(const LodePNGColorMode* info)\n{\n  return getNumColorChannels(info->colortype);\n}\n\nunsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)\n{\n  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;\n}\n\nunsigned lodepng_is_alpha_type(const LodePNGColorMode* info)\n{\n  return (info->colortype & 4) != 0; /*4 or 6*/\n}\n\nunsigned lodepng_is_palette_type(const LodePNGColorMode* info)\n{\n  return info->colortype == LCT_PALETTE;\n}\n\nunsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)\n{\n  size_t i;\n  for(i = 0; i < info->palettesize; i++)\n  {\n    if(info->palette[i * 4 + 3] < 255) return 1;\n  }\n  return 0;\n}\n\nunsigned lodepng_can_have_alpha(const LodePNGColorMode* info)\n{\n  return info->key_defined\n      || lodepng_is_alpha_type(info)\n      || lodepng_has_palette_alpha(info);\n}\n\nsize_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)\n{\n  return (w * h * lodepng_get_bpp(color) + 7) / 8;\n}\n\nsize_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)\n{\n  return (w * h * lodepng_get_bpp_lct(colortype, bitdepth) + 7) / 8;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic void LodePNGUnknownChunks_init(LodePNGInfo* info)\n{\n  unsigned i;\n  for(i = 0; i < 3; i++) info->unknown_chunks_data[i] = 0;\n  for(i = 0; i < 3; i++) info->unknown_chunks_size[i] = 0;\n}\n\nstatic void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)\n{\n  unsigned i;\n  for(i = 0; i < 3; i++) lodepng_free(info->unknown_chunks_data[i]);\n}\n\nstatic unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)\n{\n  unsigned i;\n\n  LodePNGUnknownChunks_cleanup(dest);\n\n  for(i = 0; i < 3; i++)\n  {\n    size_t j;\n    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];\n    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);\n    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/\n    for(j = 0; j < src->unknown_chunks_size[i]; j++)\n    {\n      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];\n    }\n  }\n\n  return 0;\n}\n\n/******************************************************************************/\n\nstatic void LodePNGText_init(LodePNGInfo* info)\n{\n  info->text_num = 0;\n  info->text_keys = NULL;\n  info->text_strings = NULL;\n}\n\nstatic void LodePNGText_cleanup(LodePNGInfo* info)\n{\n  size_t i;\n  for(i = 0; i < info->text_num; i++)\n  {\n    string_cleanup(&info->text_keys[i]);\n    string_cleanup(&info->text_strings[i]);\n  }\n  lodepng_free(info->text_keys);\n  lodepng_free(info->text_strings);\n}\n\nstatic unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  size_t i = 0;\n  dest->text_keys = 0;\n  dest->text_strings = 0;\n  dest->text_num = 0;\n  for(i = 0; i < source->text_num; i++)\n  {\n    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));\n  }\n  return 0;\n}\n\nvoid lodepng_clear_text(LodePNGInfo* info)\n{\n  LodePNGText_cleanup(info);\n}\n\nunsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)\n{\n  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));\n  if(!new_keys || !new_strings)\n  {\n    lodepng_free(new_keys);\n    lodepng_free(new_strings);\n    return 83; /*alloc fail*/\n  }\n\n  info->text_num++;\n  info->text_keys = new_keys;\n  info->text_strings = new_strings;\n\n  string_init(&info->text_keys[info->text_num - 1]);\n  string_set(&info->text_keys[info->text_num - 1], key);\n\n  string_init(&info->text_strings[info->text_num - 1]);\n  string_set(&info->text_strings[info->text_num - 1], str);\n\n  return 0;\n}\n\n/******************************************************************************/\n\nstatic void LodePNGIText_init(LodePNGInfo* info)\n{\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}\n\nstatic void LodePNGIText_cleanup(LodePNGInfo* info)\n{\n  size_t i;\n  for(i = 0; i < info->itext_num; i++)\n  {\n    string_cleanup(&info->itext_keys[i]);\n    string_cleanup(&info->itext_langtags[i]);\n    string_cleanup(&info->itext_transkeys[i]);\n    string_cleanup(&info->itext_strings[i]);\n  }\n  lodepng_free(info->itext_keys);\n  lodepng_free(info->itext_langtags);\n  lodepng_free(info->itext_transkeys);\n  lodepng_free(info->itext_strings);\n}\n\nstatic unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  size_t i = 0;\n  dest->itext_keys = 0;\n  dest->itext_langtags = 0;\n  dest->itext_transkeys = 0;\n  dest->itext_strings = 0;\n  dest->itext_num = 0;\n  for(i = 0; i < source->itext_num; i++)\n  {\n    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],\n                                        source->itext_transkeys[i], source->itext_strings[i]));\n  }\n  return 0;\n}\n\nvoid lodepng_clear_itext(LodePNGInfo* info)\n{\n  LodePNGIText_cleanup(info);\n}\n\nunsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,\n                           const char* transkey, const char* str)\n{\n  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));\n  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));\n  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));\n  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)\n  {\n    lodepng_free(new_keys);\n    lodepng_free(new_langtags);\n    lodepng_free(new_transkeys);\n    lodepng_free(new_strings);\n    return 83; /*alloc fail*/\n  }\n\n  info->itext_num++;\n  info->itext_keys = new_keys;\n  info->itext_langtags = new_langtags;\n  info->itext_transkeys = new_transkeys;\n  info->itext_strings = new_strings;\n\n  string_init(&info->itext_keys[info->itext_num - 1]);\n  string_set(&info->itext_keys[info->itext_num - 1], key);\n\n  string_init(&info->itext_langtags[info->itext_num - 1]);\n  string_set(&info->itext_langtags[info->itext_num - 1], langtag);\n\n  string_init(&info->itext_transkeys[info->itext_num - 1]);\n  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);\n\n  string_init(&info->itext_strings[info->itext_num - 1]);\n  string_set(&info->itext_strings[info->itext_num - 1], str);\n\n  return 0;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nvoid lodepng_info_init(LodePNGInfo* info)\n{\n  lodepng_color_mode_init(&info->color);\n  info->interlace_method = 0;\n  info->compression_method = 0;\n  info->filter_method = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  info->background_defined = 0;\n  info->background_r = info->background_g = info->background_b = 0;\n\n  LodePNGText_init(info);\n  LodePNGIText_init(info);\n\n  info->time_defined = 0;\n  info->phys_defined = 0;\n\n  LodePNGUnknownChunks_init(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nvoid lodepng_info_cleanup(LodePNGInfo* info)\n{\n  lodepng_color_mode_cleanup(&info->color);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  LodePNGText_cleanup(info);\n  LodePNGIText_cleanup(info);\n\n  LodePNGUnknownChunks_cleanup(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\nunsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  lodepng_info_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  return 0;\n}\n\nvoid lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)\n{\n  LodePNGInfo temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/\nstatic void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)\n{\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/\n  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/\n  unsigned p = index & m;\n  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/\n  in = in << (bits * (m - p));\n  if(p == 0) out[index * bits / 8] = in;\n  else out[index * bits / 8] |= in;\n}\n\ntypedef struct ColorTree ColorTree;\n\n/*\nOne node of a color tree\nThis is the data structure used to count the number of unique colors and to get a palette\nindex for a color. It's like an octree, but because the alpha channel is used too, each\nnode has 16 instead of 8 children.\n*/\nstruct ColorTree\n{\n  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/\n  int index; /*the payload. Only has a meaningful value if this is in the last level*/\n};\n\nstatic void color_tree_init(ColorTree* tree)\n{\n  int i;\n  for(i = 0; i < 16; i++) tree->children[i] = 0;\n  tree->index = -1;\n}\n\nstatic void color_tree_cleanup(ColorTree* tree)\n{\n  int i;\n  for(i = 0; i < 16; i++)\n  {\n    if(tree->children[i])\n    {\n      color_tree_cleanup(tree->children[i]);\n      lodepng_free(tree->children[i]);\n    }\n  }\n}\n\n/*returns -1 if color not present, its index otherwise*/\nstatic int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  int bit = 0;\n  for(bit = 0; bit < 8; bit++)\n  {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i]) return -1;\n    else tree = tree->children[i];\n  }\n  return tree ? tree->index : -1;\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\nstatic int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  return color_tree_get(tree, r, g, b, a) >= 0;\n}\n#endif /*LODEPNG_COMPILE_ENCODER*/\n\n/*color is not allowed to already exist.\nIndex should be >= 0 (it's signed to be compatible with using -1 for \"doesn't exist\")*/\nstatic void color_tree_add(ColorTree* tree,\n                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)\n{\n  int bit;\n  for(bit = 0; bit < 8; bit++)\n  {\n    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);\n    if(!tree->children[i])\n    {\n      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));\n      color_tree_init(tree->children[i]);\n    }\n    tree = tree->children[i];\n  }\n  tree->index = (int)index;\n}\n\n/*put a pixel, given its RGBA color, into image of any color type*/\nstatic unsigned rgba8ToPixel(unsigned char* out, size_t i,\n                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,\n                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;\n    if(mode->bitdepth == 8) out[i] = grey;\n    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;\n    else\n    {\n      /*take the most significant bits of grey*/\n      grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);\n      addColorBits(out, i, mode->bitdepth, grey);\n    }\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    if(mode->bitdepth == 8)\n    {\n      out[i * 3 + 0] = r;\n      out[i * 3 + 1] = g;\n      out[i * 3 + 2] = b;\n    }\n    else\n    {\n      out[i * 6 + 0] = out[i * 6 + 1] = r;\n      out[i * 6 + 2] = out[i * 6 + 3] = g;\n      out[i * 6 + 4] = out[i * 6 + 5] = b;\n    }\n  }\n  else if(mode->colortype == LCT_PALETTE)\n  {\n    int index = color_tree_get(tree, r, g, b, a);\n    if(index < 0) return 82; /*color not in palette*/\n    if(mode->bitdepth == 8) out[i] = index;\n    else addColorBits(out, i, mode->bitdepth, (unsigned)index);\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;\n    if(mode->bitdepth == 8)\n    {\n      out[i * 2 + 0] = grey;\n      out[i * 2 + 1] = a;\n    }\n    else if(mode->bitdepth == 16)\n    {\n      out[i * 4 + 0] = out[i * 4 + 1] = grey;\n      out[i * 4 + 2] = out[i * 4 + 3] = a;\n    }\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    if(mode->bitdepth == 8)\n    {\n      out[i * 4 + 0] = r;\n      out[i * 4 + 1] = g;\n      out[i * 4 + 2] = b;\n      out[i * 4 + 3] = a;\n    }\n    else\n    {\n      out[i * 8 + 0] = out[i * 8 + 1] = r;\n      out[i * 8 + 2] = out[i * 8 + 3] = g;\n      out[i * 8 + 4] = out[i * 8 + 5] = b;\n      out[i * 8 + 6] = out[i * 8 + 7] = a;\n    }\n  }\n\n  return 0; /*no error*/\n}\n\n/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/\nstatic void rgba16ToPixel(unsigned char* out, size_t i,\n                         const LodePNGColorMode* mode,\n                         unsigned short r, unsigned short g, unsigned short b, unsigned short a)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\n    out[i * 2 + 0] = (grey >> 8) & 255;\n    out[i * 2 + 1] = grey & 255;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    out[i * 6 + 0] = (r >> 8) & 255;\n    out[i * 6 + 1] = r & 255;\n    out[i * 6 + 2] = (g >> 8) & 255;\n    out[i * 6 + 3] = g & 255;\n    out[i * 6 + 4] = (b >> 8) & 255;\n    out[i * 6 + 5] = b & 255;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;\n    out[i * 4 + 0] = (grey >> 8) & 255;\n    out[i * 4 + 1] = grey & 255;\n    out[i * 4 + 2] = (a >> 8) & 255;\n    out[i * 4 + 3] = a & 255;\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    out[i * 8 + 0] = (r >> 8) & 255;\n    out[i * 8 + 1] = r & 255;\n    out[i * 8 + 2] = (g >> 8) & 255;\n    out[i * 8 + 3] = g & 255;\n    out[i * 8 + 4] = (b >> 8) & 255;\n    out[i * 8 + 5] = b & 255;\n    out[i * 8 + 6] = (a >> 8) & 255;\n    out[i * 8 + 7] = a & 255;\n  }\n}\n\n/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/\nstatic void getPixelColorRGBA8(unsigned char* r, unsigned char* g,\n                               unsigned char* b, unsigned char* a,\n                               const unsigned char* in, size_t i,\n                               const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    if(mode->bitdepth == 8)\n    {\n      *r = *g = *b = in[i];\n      if(mode->key_defined && *r == mode->key_r) *a = 0;\n      else *a = 255;\n    }\n    else if(mode->bitdepth == 16)\n    {\n      *r = *g = *b = in[i * 2 + 0];\n      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n      else *a = 255;\n    }\n    else\n    {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = i * mode->bitdepth;\n      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n      *r = *g = *b = (value * 255) / highest;\n      if(mode->key_defined && value == mode->key_r) *a = 0;\n      else *a = 255;\n    }\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    if(mode->bitdepth == 8)\n    {\n      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];\n      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;\n      else *a = 255;\n    }\n    else\n    {\n      *r = in[i * 6 + 0];\n      *g = in[i * 6 + 2];\n      *b = in[i * 6 + 4];\n      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n      else *a = 255;\n    }\n  }\n  else if(mode->colortype == LCT_PALETTE)\n  {\n    unsigned index;\n    if(mode->bitdepth == 8) index = in[i];\n    else\n    {\n      size_t j = i * mode->bitdepth;\n      index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n    }\n\n    if(index >= mode->palettesize)\n    {\n      /*This is an error according to the PNG spec, but common PNG decoders make it black instead.\n      Done here too, slightly faster due to no error handling needed.*/\n      *r = *g = *b = 0;\n      *a = 255;\n    }\n    else\n    {\n      *r = mode->palette[index * 4 + 0];\n      *g = mode->palette[index * 4 + 1];\n      *b = mode->palette[index * 4 + 2];\n      *a = mode->palette[index * 4 + 3];\n    }\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    if(mode->bitdepth == 8)\n    {\n      *r = *g = *b = in[i * 2 + 0];\n      *a = in[i * 2 + 1];\n    }\n    else\n    {\n      *r = *g = *b = in[i * 4 + 0];\n      *a = in[i * 4 + 2];\n    }\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    if(mode->bitdepth == 8)\n    {\n      *r = in[i * 4 + 0];\n      *g = in[i * 4 + 1];\n      *b = in[i * 4 + 2];\n      *a = in[i * 4 + 3];\n    }\n    else\n    {\n      *r = in[i * 8 + 0];\n      *g = in[i * 8 + 2];\n      *b = in[i * 8 + 4];\n      *a = in[i * 8 + 6];\n    }\n  }\n}\n\n/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color\nmode test cases, optimized to convert the colors much faster, when converting\nto RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with\nenough memory, if has_alpha is true the output is RGBA. mode has the color mode\nof the input buffer.*/\nstatic void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,\n                                unsigned has_alpha, const unsigned char* in,\n                                const LodePNGColorMode* mode)\n{\n  unsigned num_channels = has_alpha ? 4 : 3;\n  size_t i;\n  if(mode->colortype == LCT_GREY)\n  {\n    if(mode->bitdepth == 8)\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = buffer[1] = buffer[2] = in[i];\n        if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;\n      }\n    }\n    else if(mode->bitdepth == 16)\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2];\n        if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;\n      }\n    }\n    else\n    {\n      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/\n      size_t j = 0;\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);\n        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;\n        if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;\n      }\n    }\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    if(mode->bitdepth == 8)\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = in[i * 3 + 0];\n        buffer[1] = in[i * 3 + 1];\n        buffer[2] = in[i * 3 + 2];\n        if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r\n           && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;\n      }\n    }\n    else\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = in[i * 6 + 0];\n        buffer[1] = in[i * 6 + 2];\n        buffer[2] = in[i * 6 + 4];\n        if(has_alpha) buffer[3] = mode->key_defined\n           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;\n      }\n    }\n  }\n  else if(mode->colortype == LCT_PALETTE)\n  {\n    unsigned index;\n    size_t j = 0;\n    for(i = 0; i < numpixels; i++, buffer += num_channels)\n    {\n      if(mode->bitdepth == 8) index = in[i];\n      else index = readBitsFromReversedStream(&j, in, mode->bitdepth);\n\n      if(index >= mode->palettesize)\n      {\n        /*This is an error according to the PNG spec, but most PNG decoders make it black instead.\n        Done here too, slightly faster due to no error handling needed.*/\n        buffer[0] = buffer[1] = buffer[2] = 0;\n        if(has_alpha) buffer[3] = 255;\n      }\n      else\n      {\n        buffer[0] = mode->palette[index * 4 + 0];\n        buffer[1] = mode->palette[index * 4 + 1];\n        buffer[2] = mode->palette[index * 4 + 2];\n        if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];\n      }\n    }\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    if(mode->bitdepth == 8)\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];\n        if(has_alpha) buffer[3] = in[i * 2 + 1];\n      }\n    }\n    else\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];\n        if(has_alpha) buffer[3] = in[i * 4 + 2];\n      }\n    }\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    if(mode->bitdepth == 8)\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = in[i * 4 + 0];\n        buffer[1] = in[i * 4 + 1];\n        buffer[2] = in[i * 4 + 2];\n        if(has_alpha) buffer[3] = in[i * 4 + 3];\n      }\n    }\n    else\n    {\n      for(i = 0; i < numpixels; i++, buffer += num_channels)\n      {\n        buffer[0] = in[i * 8 + 0];\n        buffer[1] = in[i * 8 + 2];\n        buffer[2] = in[i * 8 + 4];\n        if(has_alpha) buffer[3] = in[i * 8 + 6];\n      }\n    }\n  }\n}\n\n/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with\ngiven color type, but the given color type must be 16-bit itself.*/\nstatic void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}\n\nunsigned lodepng_convert(unsigned char* out, const unsigned char* in,\n                         LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,\n                         unsigned w, unsigned h)\n{\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = w * h;\n\n  if(lodepng_color_mode_equal(mode_out, mode_in))\n  {\n    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);\n    for(i = 0; i < numbytes; i++) out[i] = in[i];\n    return 0;\n  }\n\n  if(mode_out->colortype == LCT_PALETTE)\n  {\n    size_t palsize = 1u << mode_out->bitdepth;\n    if(mode_out->palettesize < palsize) palsize = mode_out->palettesize;\n    color_tree_init(&tree);\n    for(i = 0; i < palsize; i++)\n    {\n      unsigned char* p = &mode_out->palette[i * 4];\n      color_tree_add(&tree, p[0], p[1], p[2], p[3], i);\n    }\n  }\n\n  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)\n  {\n    for(i = 0; i < numpixels; i++)\n    {\n      unsigned short r = 0, g = 0, b = 0, a = 0;\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);\n      rgba16ToPixel(out, i, mode_out, r, g, b, a);\n    }\n  }\n  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)\n  {\n    getPixelColorsRGBA8(out, numpixels, 1, in, mode_in);\n  }\n  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)\n  {\n    getPixelColorsRGBA8(out, numpixels, 0, in, mode_in);\n  }\n  else\n  {\n    unsigned char r = 0, g = 0, b = 0, a = 0;\n    for(i = 0; i < numpixels; i++)\n    {\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);\n      rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);\n    }\n  }\n\n  if(mode_out->colortype == LCT_PALETTE)\n  {\n    color_tree_cleanup(&tree);\n  }\n\n  return 0; /*no error (this function currently never has one, but maybe OOM detection added later.)*/\n}\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\nvoid lodepng_color_profile_init(LodePNGColorProfile* profile)\n{\n  profile->colored = 0;\n  profile->key = 0;\n  profile->alpha = 0;\n  profile->key_r = profile->key_g = profile->key_b = 0;\n  profile->numcolors = 0;\n  profile->bits = 1;\n}\n\n/*function used for debug purposes with C++*/\n/*void printColorProfile(LodePNGColorProfile* p)\n{\n  std::cout << \"colored: \" << (int)p->colored << \", \";\n  std::cout << \"key: \" << (int)p->key << \", \";\n  std::cout << \"key_r: \" << (int)p->key_r << \", \";\n  std::cout << \"key_g: \" << (int)p->key_g << \", \";\n  std::cout << \"key_b: \" << (int)p->key_b << \", \";\n  std::cout << \"alpha: \" << (int)p->alpha << \", \";\n  std::cout << \"numcolors: \" << (int)p->numcolors << \", \";\n  std::cout << \"bits: \" << (int)p->bits << std::endl;\n}*/\n\n/*Returns how many bits needed to represent given value (max 8 bit)*/\nunsigned getValueRequiredBits(unsigned char value)\n{\n  if(value == 0 || value == 255) return 1;\n  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/\n  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;\n  return 8;\n}\n\n/*profile must already have been inited with mode.\nIt's ok to set some parameters of profile to done already.*/\nunsigned get_color_profile(LodePNGColorProfile* profile,\n                           const unsigned char* in, unsigned w, unsigned h,\n                           const LodePNGColorMode* mode)\n{\n  unsigned error = 0;\n  size_t i;\n  ColorTree tree;\n  size_t numpixels = w * h;\n\n  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;\n  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;\n  unsigned numcolors_done = 0;\n  unsigned bpp = lodepng_get_bpp(mode);\n  unsigned bits_done = bpp == 1 ? 1 : 0;\n  unsigned maxnumcolors = 257;\n  unsigned sixteen = 0;\n  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));\n\n  color_tree_init(&tree);\n\n  /*Check if the 16-bit input is truly 16-bit*/\n  if(mode->bitdepth == 16)\n  {\n    unsigned short r, g, b, a;\n    for(i = 0; i < numpixels; i++)\n    {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\n      if(r % 257u != 0 || g % 257u != 0 || b % 257u != 0 || a % 257u != 0) /*first and second byte differ*/\n      {\n        sixteen = 1;\n        break;\n      }\n    }\n  }\n\n  if(sixteen)\n  {\n    unsigned short r = 0, g = 0, b = 0, a = 0;\n    profile->bits = 16;\n    bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/\n\n    for(i = 0; i < numpixels; i++)\n    {\n      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);\n      \n      if(!colored_done && (r != g || r != b))\n      {\n        profile->colored = 1;\n        colored_done = 1;\n      }\n\n      if(!alpha_done)\n      {\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\n        if(a != 65535 && (a != 0 || (profile->key && !matchkey)))\n        {\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n        else if(a == 0 && !profile->alpha && !profile->key)\n        {\n          profile->key = 1;\n          profile->key_r = r;\n          profile->key_g = g;\n          profile->key_b = b;\n        }\n        else if(a == 65535 && profile->key && matchkey)\n        {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          profile->alpha = 1;\n          alpha_done = 1;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n  }\n  else /* < 16-bit */\n  {\n    for(i = 0; i < numpixels; i++)\n    {\n      unsigned char r = 0, g = 0, b = 0, a = 0;\n      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);\n\n      if(!bits_done && profile->bits < 8)\n      {\n        /*only r is checked, < 8 bits is only relevant for greyscale*/\n        unsigned bits = getValueRequiredBits(r);\n        if(bits > profile->bits) profile->bits = bits;\n      }\n      bits_done = (profile->bits >= bpp);\n\n      if(!colored_done && (r != g || r != b))\n      {\n        profile->colored = 1;\n        colored_done = 1;\n        if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/\n      }\n\n      if(!alpha_done)\n      {\n        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);\n        if(a != 255 && (a != 0 || (profile->key && !matchkey)))\n        {\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n        else if(a == 0 && !profile->alpha && !profile->key)\n        {\n          profile->key = 1;\n          profile->key_r = r;\n          profile->key_g = g;\n          profile->key_b = b;\n        }\n        else if(a == 255 && profile->key && matchkey)\n        {\n          /* Color key cannot be used if an opaque pixel also has that RGB color. */\n          profile->alpha = 1;\n          alpha_done = 1;\n          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/\n        }\n      }\n\n      if(!numcolors_done)\n      {\n        if(!color_tree_has(&tree, r, g, b, a))\n        {\n          color_tree_add(&tree, r, g, b, a, profile->numcolors);\n          if(profile->numcolors < 256)\n          {\n            unsigned char* p = profile->palette;\n            unsigned i = profile->numcolors;\n            p[i * 4 + 0] = r;\n            p[i * 4 + 1] = g;\n            p[i * 4 + 2] = b;\n            p[i * 4 + 3] = a;\n          }\n          profile->numcolors++;\n          numcolors_done = profile->numcolors >= maxnumcolors;\n        }\n      }\n\n      if(alpha_done && numcolors_done && colored_done && bits_done) break;\n    }\n\n    /*make the profile's key always 16-bit for consistency - repeat each byte twice*/\n    profile->key_r *= 257;\n    profile->key_g *= 257;\n    profile->key_b *= 257;\n  }\n\n  color_tree_cleanup(&tree);\n  return error;\n}\n\n/*Automatically chooses color type that gives smallest amount of bits in the\noutput image, e.g. grey if there are only greyscale pixels, palette if there\nare less than 256 colors, ...\nUpdates values of mode with a potentially smaller color model. mode_out should\ncontain the user chosen color model, but will be overwritten with the new chosen one.*/\nunsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n\n  if(prof.key && w * h <= 16) prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/\n  grey_ok = !prof.colored && !prof.alpha; /*grey without alpha, with potentially low bits*/\n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/\n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/\n\n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/\n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else /*8-bit or 16-bit per channel*/\n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/\n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n\n  return error;\n}\n\n#endif /* #ifdef LODEPNG_COMPILE_ENCODER */\n\n/*\nPaeth predicter, used by PNG filter type 4\nThe parameters are of type short, but should come from unsigned chars, the shorts\nare only needed to make the paeth calculation correct.\n*/\nstatic unsigned char paethPredictor(short a, short b, short c)\n{\n  short pa = abs(b - c);\n  short pb = abs(a - c);\n  short pc = abs(a + b - c - c);\n\n  if(pc < pa && pc < pb) return (unsigned char)c;\n  else if(pb < pa) return (unsigned char)b;\n  else return (unsigned char)a;\n}\n\n/*shared values used by multiple Adam7 related functions*/\n\nstatic const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/\nstatic const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/\nstatic const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/\nstatic const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/\n\n/*\nOutputs various dimensions and positions in the image related to the Adam7 reduced images.\npassw: output containing the width of the 7 passes\npassh: output containing the height of the 7 passes\nfilter_passstart: output containing the index of the start and end of each\n reduced image with filter bytes\npadded_passstart output containing the index of the start and end of each\n reduced image when without filter bytes but with padded scanlines\npassstart: output containing the index of the start and end of each reduced\n image without padding between scanlines, but still padding between the images\nw, h: width and height of non-interlaced image\nbpp: bits per pixel\n\"padded\" is only relevant if bpp is less than 8 and a scanline or image does not\n end at a full byte\n*/\nstatic void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],\n                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)\n{\n  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/\n  unsigned i;\n\n  /*calculate width and height in pixels of each pass*/\n  for(i = 0; i < 7; i++)\n  {\n    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];\n    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];\n    if(passw[i] == 0) passh[i] = 0;\n    if(passh[i] == 0) passw[i] = 0;\n  }\n\n  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;\n  for(i = 0; i < 7; i++)\n  {\n    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/\n    filter_passstart[i + 1] = filter_passstart[i]\n                            + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);\n    /*bits padded if needed to fill full byte at end of each scanline*/\n    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);\n    /*only padded at end of reduced image*/\n    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;\n  }\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Decoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*read the information from the header and store it in the LodePNGInfo. return value is error*/\nunsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,\n                         const unsigned char* in, size_t insize)\n{\n  LodePNGInfo* info = &state->info_png;\n  if(insize == 0 || in == 0)\n  {\n    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/\n  }\n  if(insize < 29)\n  {\n    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/\n  }\n\n  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/\n  lodepng_info_cleanup(info);\n  lodepng_info_init(info);\n\n  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71\n     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)\n  {\n    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/\n  }\n  if(in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R')\n  {\n    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/\n  }\n\n  /*read the values given in the header*/\n  *w = lodepng_read32bitInt(&in[16]);\n  *h = lodepng_read32bitInt(&in[20]);\n  info->color.bitdepth = in[24];\n  info->color.colortype = (LodePNGColorType)in[25];\n  info->compression_method = in[26];\n  info->filter_method = in[27];\n  info->interlace_method = in[28];\n\n  if(!state->decoder.ignore_crc)\n  {\n    unsigned CRC = lodepng_read32bitInt(&in[29]);\n    unsigned checksum = lodepng_crc32(&in[12], 17);\n    if(CRC != checksum)\n    {\n      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/\n    }\n  }\n\n  /*error: only compression method 0 is allowed in the specification*/\n  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);\n  /*error: only filter method 0 is allowed in the specification*/\n  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);\n  /*error: only interlace methods 0 and 1 exist in the specification*/\n  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);\n\n  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);\n  return state->error;\n}\n\nstatic unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,\n                                 size_t bytewidth, unsigned char filterType, size_t length)\n{\n  /*\n  For PNG filter method 0\n  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,\n  the filter works byte per byte (bytewidth = 1)\n  precon is the previous unfiltered scanline, recon the result, scanline the current one\n  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead\n  recon and scanline MAY be the same memory address! precon must be disjoint.\n  */\n\n  size_t i;\n  switch(filterType)\n  {\n    case 0:\n      for(i = 0; i < length; i++) recon[i] = scanline[i];\n      break;\n    case 1:\n      for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];\n      for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth];\n      break;\n    case 2:\n      if(precon)\n      {\n        for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];\n      }\n      else\n      {\n        for(i = 0; i < length; i++) recon[i] = scanline[i];\n      }\n      break;\n    case 3:\n      if(precon)\n      {\n        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;\n        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];\n        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;\n      }\n      break;\n    case 4:\n      if(precon)\n      {\n        for(i = 0; i < bytewidth; i++)\n        {\n          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/\n        }\n        for(i = bytewidth; i < length; i++)\n        {\n          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));\n        }\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++)\n        {\n          recon[i] = scanline[i];\n        }\n        for(i = bytewidth; i < length; i++)\n        {\n          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/\n          recon[i] = (scanline[i] + recon[i - bytewidth]);\n        }\n      }\n      break;\n    default: return 36; /*error: unexisting filter type given*/\n  }\n  return 0;\n}\n\nstatic unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\n{\n  /*\n  For PNG filter method 0\n  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)\n  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline\n  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel\n  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)\n  */\n\n  unsigned y;\n  unsigned char* prevline = 0;\n\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7) / 8;\n  size_t linebytes = (w * bpp + 7) / 8;\n\n  for(y = 0; y < h; y++)\n  {\n    size_t outindex = linebytes * y;\n    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n    unsigned char filterType = in[inindex];\n\n    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));\n\n    prevline = &out[outindex];\n  }\n\n  return 0;\n}\n\n/*\nin: Adam7 interlaced image, with no padding bits between scanlines, but between\n reduced images so that each reduced image starts at a byte.\nout: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h\nbpp: bits per pixel\nout has the following size in bits: w * h * bpp.\nin is possibly bigger due to padding bits between reduced images.\nout must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation\n(because that's likely a little bit faster)\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\n{\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8)\n  {\n    for(i = 0; i < 7; i++)\n    {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8;\n      for(y = 0; y < passh[i]; y++)\n      for(x = 0; x < passw[i]; x++)\n      {\n        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\n        for(b = 0; b < bytewidth; b++)\n        {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  }\n  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/\n  {\n    for(i = 0; i < 7; i++)\n    {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; y++)\n      for(x = 0; x < passw[i]; x++)\n      {\n        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\n        for(b = 0; b < bpp; b++)\n        {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/\n          setBitOfReversedStream0(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\nstatic void removePaddingBits(unsigned char* out, const unsigned char* in,\n                              size_t olinebits, size_t ilinebits, unsigned h)\n{\n  /*\n  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need\n  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers\n  for the Adam7 code, the color convert code and the output to the user.\n  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must\n  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits\n  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7\n  only useful if (ilinebits - olinebits) is a value in the range 1..7\n  */\n  unsigned y;\n  size_t diff = ilinebits - olinebits;\n  size_t ibp = 0, obp = 0; /*input and output bit pointers*/\n  for(y = 0; y < h; y++)\n  {\n    size_t x;\n    for(x = 0; x < olinebits; x++)\n    {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    ibp += diff;\n  }\n}\n\n/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from\nthe IDAT chunks (with filter index bytes and possible padding bits)\nreturn value is error*/\nstatic unsigned postProcessScanlines(unsigned char* out, unsigned char* in,\n                                     unsigned w, unsigned h, const LodePNGInfo* info_png)\n{\n  /*\n  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.\n  Steps:\n  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)\n  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace\n  NOTE: the in buffer will be overwritten with intermediate data!\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  if(bpp == 0) return 31; /*error: invalid colortype*/\n\n  if(info_png->interlace_method == 0)\n  {\n    if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\n    {\n      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));\n      removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);\n    }\n    /*we can immediatly filter into the out buffer, no other steps needed*/\n    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));\n  }\n  else /*interlace_method is 1 (Adam7)*/\n  {\n    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned i;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    for(i = 0; i < 7; i++)\n    {\n      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));\n      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,\n      move bytes instead of bits or move not at all*/\n      if(bpp < 8)\n      {\n        /*remove padding bits in scanlines; after this there still may be padding\n        bits between the different reduced images: each reduced image still starts nicely at a byte*/\n        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,\n                          ((passw[i] * bpp + 7) / 8) * 8, passh[i]);\n      }\n    }\n\n    Adam7_deinterlace(out, in, w, h, bpp);\n  }\n\n  return 0;\n}\n\nstatic unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)\n{\n  unsigned pos = 0, i;\n  if(color->palette) lodepng_free(color->palette);\n  color->palettesize = chunkLength / 3;\n  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);\n  if(!color->palette && color->palettesize)\n  {\n    color->palettesize = 0;\n    return 83; /*alloc fail*/\n  }\n  if(color->palettesize > 256) return 38; /*error: palette too big*/\n\n  for(i = 0; i < color->palettesize; i++)\n  {\n    color->palette[4 * i + 0] = data[pos++]; /*R*/\n    color->palette[4 * i + 1] = data[pos++]; /*G*/\n    color->palette[4 * i + 2] = data[pos++]; /*B*/\n    color->palette[4 * i + 3] = 255; /*alpha*/\n  }\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)\n{\n  unsigned i;\n  if(color->colortype == LCT_PALETTE)\n  {\n    /*error: more alpha values given than there are palette entries*/\n    if(chunkLength > color->palettesize) return 38;\n\n    for(i = 0; i < chunkLength; i++) color->palette[4 * i + 3] = data[i];\n  }\n  else if(color->colortype == LCT_GREY)\n  {\n    /*error: this chunk must be 2 bytes for greyscale image*/\n    if(chunkLength != 2) return 30;\n\n    color->key_defined = 1;\n    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];\n  }\n  else if(color->colortype == LCT_RGB)\n  {\n    /*error: this chunk must be 6 bytes for RGB image*/\n    if(chunkLength != 6) return 41;\n\n    color->key_defined = 1;\n    color->key_r = 256u * data[0] + data[1];\n    color->key_g = 256u * data[2] + data[3];\n    color->key_b = 256u * data[4] + data[5];\n  }\n  else return 42; /*error: tRNS chunk not allowed for other color models*/\n\n  return 0; /* OK */\n}\n\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n/*background color chunk (bKGD)*/\nstatic unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  if(info->color.colortype == LCT_PALETTE)\n  {\n    /*error: this chunk must be 1 byte for indexed color image*/\n    if(chunkLength != 1) return 43;\n\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = data[0];\n  }\n  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)\n  {\n    /*error: this chunk must be 2 bytes for greyscale image*/\n    if(chunkLength != 2) return 44;\n\n    info->background_defined = 1;\n    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];\n  }\n  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)\n  {\n    /*error: this chunk must be 6 bytes for greyscale image*/\n    if(chunkLength != 6) return 45;\n\n    info->background_defined = 1;\n    info->background_r = 256u * data[0] + data[1];\n    info->background_g = 256u * data[2] + data[3];\n    info->background_b = 256u * data[4] + data[5];\n  }\n\n  return 0; /* OK */\n}\n\n/*text chunk (tEXt)*/\nstatic unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n\n  while(!error) /*not really a while loop, only used to break on error*/\n  {\n    unsigned length, string2_begin;\n\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n\n    string2_begin = length + 1; /*skip keyword null terminator*/\n\n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)lodepng_malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n\n    error = lodepng_add_text(info, key, str);\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(str);\n\n  return error;\n}\n\n/*compressed text chunk (zTXt)*/\nstatic unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,\n                               const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  unsigned i;\n\n  unsigned length, string2_begin;\n  char *key = 0;\n  ucvector decoded;\n\n  ucvector_init(&decoded);\n\n  while(!error) /*not really a while loop, only used to break on error*/\n  {\n    for(length = 0; length < chunkLength && data[length] != 0; length++) ;\n    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n\n    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    string2_begin = length + 2;\n    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/\n\n    length = chunkLength - string2_begin;\n    /*will fail if zlib error, e.g. if length is too small*/\n    error = zlib_decompress(&decoded.data, &decoded.size,\n                            (unsigned char*)(&data[string2_begin]),\n                            length, zlibsettings);\n    if(error) break;\n    ucvector_push_back(&decoded, 0);\n\n    error = lodepng_add_text(info, key, (char*)decoded.data);\n\n    break;\n  }\n\n  lodepng_free(key);\n  ucvector_cleanup(&decoded);\n\n  return error;\n}\n\n/*international text chunk (iTXt)*/\nstatic unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,\n                               const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  unsigned i;\n\n  unsigned length, begin, compressed;\n  char *key = 0, *langtag = 0, *transkey = 0;\n  ucvector decoded;\n  ucvector_init(&decoded);\n\n  while(!error) /*not really a while loop, only used to break on error*/\n  {\n    /*Quick check if the chunk length isn't too small. Even without check\n    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/\n    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/\n\n    /*read the key*/\n    for(length = 0; length < chunkLength && data[length] != 0; length++) ;\n    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/\n\n    key = (char*)lodepng_malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n\n    /*read the compression method*/\n    compressed = data[length + 1];\n    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/\n\n    /*even though it's not allowed by the standard, no error is thrown if\n    there's no null termination char, if the text is empty for the next 3 texts*/\n\n    /*read the langtag*/\n    begin = length + 3;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; i++) length++;\n\n    langtag = (char*)lodepng_malloc(length + 1);\n    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    langtag[length] = 0;\n    for(i = 0; i < length; i++) langtag[i] = (char)data[begin + i];\n\n    /*read the transkey*/\n    begin += length + 1;\n    length = 0;\n    for(i = begin; i < chunkLength && data[i] != 0; i++) length++;\n\n    transkey = (char*)lodepng_malloc(length + 1);\n    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/\n\n    transkey[length] = 0;\n    for(i = 0; i < length; i++) transkey[i] = (char)data[begin + i];\n\n    /*read the actual text*/\n    begin += length + 1;\n\n    length = chunkLength < begin ? 0 : chunkLength - begin;\n\n    if(compressed)\n    {\n      /*will fail if zlib error, e.g. if length is too small*/\n      error = zlib_decompress(&decoded.data, &decoded.size,\n                              (unsigned char*)(&data[begin]),\n                              length, zlibsettings);\n      if(error) break;\n      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;\n      ucvector_push_back(&decoded, 0);\n    }\n    else\n    {\n      if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);\n\n      decoded.data[length] = 0;\n      for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];\n    }\n\n    error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);\n\n    break;\n  }\n\n  lodepng_free(key);\n  lodepng_free(langtag);\n  lodepng_free(transkey);\n  ucvector_cleanup(&decoded);\n\n  return error;\n}\n\nstatic unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/\n\n  info->time_defined = 1;\n  info->time.year = 256u * data[0] + data[1];\n  info->time.month = data[2];\n  info->time.day = data[3];\n  info->time.hour = data[4];\n  info->time.minute = data[5];\n  info->time.second = data[6];\n\n  return 0; /* OK */\n}\n\nstatic unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/\n\n  info->phys_defined = 1;\n  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];\n  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];\n  info->phys_unit = data[8];\n\n  return 0; /* OK */\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n/*read a PNG, the result will be in the same color type as the PNG (hence \"generic\")*/\nstatic void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,\n                          LodePNGState* state,\n                          const unsigned char* in, size_t insize)\n{\n  unsigned char IEND = 0;\n  const unsigned char* chunk;\n  size_t i;\n  ucvector idat; /*the data from idat chunks*/\n  ucvector scanlines;\n\n  /*for unknown chunk order*/\n  unsigned unknown = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\n  /*provide some proper output values if error will happen*/\n  *out = 0;\n\n  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/\n  if(state->error) return;\n\n  ucvector_init(&idat);\n  chunk = &in[33]; /*first byte of the first chunk after the header*/\n\n  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.\n  IDAT data is put at the start of the in buffer*/\n  while(!IEND && !state->error)\n  {\n    unsigned chunkLength;\n    const unsigned char* data; /*the data in the chunk*/\n\n    /*error: size of the in buffer too small to contain next chunk*/\n    if((size_t)((chunk - in) + 12) > insize || chunk < in) CERROR_BREAK(state->error, 30);\n\n    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/\n    chunkLength = lodepng_chunk_length(chunk);\n    /*error: chunk length larger than the max PNG chunk size*/\n    if(chunkLength > 2147483647) CERROR_BREAK(state->error, 63);\n\n    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)\n    {\n      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/\n    }\n\n    data = lodepng_chunk_data_const(chunk);\n\n    /*IDAT chunk, containing compressed image data*/\n    if(lodepng_chunk_type_equals(chunk, \"IDAT\"))\n    {\n      size_t oldsize = idat.size;\n      if(!ucvector_resize(&idat, oldsize + chunkLength)) CERROR_BREAK(state->error, 83 /*alloc fail*/);\n      for(i = 0; i < chunkLength; i++) idat.data[oldsize + i] = data[i];\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 3;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    }\n    /*IEND chunk*/\n    else if(lodepng_chunk_type_equals(chunk, \"IEND\"))\n    {\n      IEND = 1;\n    }\n    /*palette chunk (PLTE)*/\n    else if(lodepng_chunk_type_equals(chunk, \"PLTE\"))\n    {\n      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      critical_pos = 2;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    }\n    /*palette transparency chunk (tRNS)*/\n    else if(lodepng_chunk_type_equals(chunk, \"tRNS\"))\n    {\n      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);\n      if(state->error) break;\n    }\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*background color chunk (bKGD)*/\n    else if(lodepng_chunk_type_equals(chunk, \"bKGD\"))\n    {\n      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    }\n    /*text chunk (tEXt)*/\n    else if(lodepng_chunk_type_equals(chunk, \"tEXt\"))\n    {\n      if(state->decoder.read_text_chunks)\n      {\n        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);\n        if(state->error) break;\n      }\n    }\n    /*compressed text chunk (zTXt)*/\n    else if(lodepng_chunk_type_equals(chunk, \"zTXt\"))\n    {\n      if(state->decoder.read_text_chunks)\n      {\n        state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);\n        if(state->error) break;\n      }\n    }\n    /*international text chunk (iTXt)*/\n    else if(lodepng_chunk_type_equals(chunk, \"iTXt\"))\n    {\n      if(state->decoder.read_text_chunks)\n      {\n        state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);\n        if(state->error) break;\n      }\n    }\n    else if(lodepng_chunk_type_equals(chunk, \"tIME\"))\n    {\n      state->error = readChunk_tIME(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    }\n    else if(lodepng_chunk_type_equals(chunk, \"pHYs\"))\n    {\n      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);\n      if(state->error) break;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    else /*it's not an implemented chunk type, so ignore it: skip over the data*/\n    {\n      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/\n      if(!lodepng_chunk_ancillary(chunk)) CERROR_BREAK(state->error, 69);\n\n      unknown = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n      if(state->decoder.remember_unknown_chunks)\n      {\n        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],\n                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);\n        if(state->error) break;\n      }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    }\n\n    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/\n    {\n      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/\n    }\n\n    if(!IEND) chunk = lodepng_chunk_next_const(chunk);\n  }\n\n  ucvector_init(&scanlines);\n  if(!state->error)\n  {\n    /*maximum final image length is already reserved in the vector's length - this is not really necessary*/\n    if(!ucvector_resize(&scanlines, lodepng_get_raw_size(*w, *h, &state->info_png.color) + *h))\n    {\n      state->error = 83; /*alloc fail*/\n    }\n  }\n  if(!state->error)\n  {\n    /*decompress with the Zlib decompressor*/\n    state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,\n                                   idat.size, &state->decoder.zlibsettings);\n  }\n  ucvector_cleanup(&idat);\n\n  if(!state->error)\n  {\n    ucvector outv;\n    ucvector_init(&outv);\n    if(!ucvector_resizev(&outv,\n        lodepng_get_raw_size(*w, *h, &state->info_png.color), 0)) state->error = 83; /*alloc fail*/\n    if(!state->error) state->error = postProcessScanlines(outv.data, scanlines.data, *w, *h, &state->info_png);\n    *out = outv.data;\n  }\n  ucvector_cleanup(&scanlines);\n}\n\nunsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,\n                        LodePNGState* state,\n                        const unsigned char* in, size_t insize)\n{\n  *out = 0;\n  decodeGeneric(out, w, h, state, in, insize);\n  if(state->error) return state->error;\n  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))\n  {\n    /*same color type, no copying or converting of data needed*/\n    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype\n    the raw image has to the end user*/\n    if(!state->decoder.color_convert)\n    {\n      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);\n      if(state->error) return state->error;\n    }\n  }\n  else\n  {\n    /*color conversion needed; sort of copy of the data*/\n    unsigned char* data = *out;\n    size_t outsize;\n\n    /*TODO: check if this works according to the statement in the documentation: \"The converter can convert\n    from greyscale input color type, to 8-bit greyscale or greyscale with alpha\"*/\n    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)\n       && !(state->info_raw.bitdepth == 8))\n    {\n      return 56; /*unsupported color mode conversion*/\n    }\n\n    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);\n    *out = (unsigned char*)lodepng_malloc(outsize);\n    if(!(*out))\n    {\n      state->error = 83; /*alloc fail*/\n    }\n    else state->error = lodepng_convert(*out, data, &state->info_raw,\n                                        &state->info_png.color, *w, *h);\n    lodepng_free(data);\n  }\n  return state->error;\n}\n\nunsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,\n                               size_t insize, LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n  error = lodepng_decode(out, w, h, &state, in, insize);\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,\n                             LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error;\n  error = lodepng_load_file(&buffer, &buffersize, filename);\n  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)\n{\n  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);\n}\n\nunsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)\n{\n  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)\n{\n  settings->color_convert = 1;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->read_text_chunks = 1;\n  settings->remember_unknown_chunks = 0;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n  settings->ignore_crc = 0;\n  lodepng_decompress_settings_init(&settings->zlibsettings);\n}\n\n#endif /*LODEPNG_COMPILE_DECODER*/\n\n#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)\n\nvoid lodepng_state_init(LodePNGState* state)\n{\n#ifdef LODEPNG_COMPILE_DECODER\n  lodepng_decoder_settings_init(&state->decoder);\n#endif /*LODEPNG_COMPILE_DECODER*/\n#ifdef LODEPNG_COMPILE_ENCODER\n  lodepng_encoder_settings_init(&state->encoder);\n#endif /*LODEPNG_COMPILE_ENCODER*/\n  lodepng_color_mode_init(&state->info_raw);\n  lodepng_info_init(&state->info_png);\n  state->error = 1;\n}\n\nvoid lodepng_state_cleanup(LodePNGState* state)\n{\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}\n\nvoid lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)\n{\n  lodepng_state_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->info_raw);\n  lodepng_info_init(&dest->info_png);\n  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;\n  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;\n}\n\n#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */\n\n#ifdef LODEPNG_COMPILE_ENCODER\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* / PNG Encoder                                                            / */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*chunkName must be string of 4 characters*/\nstatic unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)\n{\n  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));\n  out->allocsize = out->size; /*fix the allocsize again*/\n  return 0;\n}\n\nstatic void writeSignature(ucvector* out)\n{\n  /*8 bytes PNG signature, aka the magic bytes*/\n  ucvector_push_back(out, 137);\n  ucvector_push_back(out, 80);\n  ucvector_push_back(out, 78);\n  ucvector_push_back(out, 71);\n  ucvector_push_back(out, 13);\n  ucvector_push_back(out, 10);\n  ucvector_push_back(out, 26);\n  ucvector_push_back(out, 10);\n}\n\nstatic unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,\n                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)\n{\n  unsigned error = 0;\n  ucvector header;\n  ucvector_init(&header);\n\n  lodepng_add32bitInt(&header, w); /*width*/\n  lodepng_add32bitInt(&header, h); /*height*/\n  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/\n  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/\n  ucvector_push_back(&header, 0); /*compression method*/\n  ucvector_push_back(&header, 0); /*filter method*/\n  ucvector_push_back(&header, interlace_method); /*interlace method*/\n\n  error = addChunk(out, \"IHDR\", header.data, header.size);\n  ucvector_cleanup(&header);\n\n  return error;\n}\n\nstatic unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)\n{\n  unsigned error = 0;\n  size_t i;\n  ucvector PLTE;\n  ucvector_init(&PLTE);\n  for(i = 0; i < info->palettesize * 4; i++)\n  {\n    /*add all channels except alpha channel*/\n    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);\n  }\n  error = addChunk(out, \"PLTE\", PLTE.data, PLTE.size);\n  ucvector_cleanup(&PLTE);\n\n  return error;\n}\n\nstatic unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)\n{\n  unsigned error = 0;\n  size_t i;\n  ucvector tRNS;\n  ucvector_init(&tRNS);\n  if(info->colortype == LCT_PALETTE)\n  {\n    size_t amount = info->palettesize;\n    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/\n    for(i = info->palettesize; i > 0; i--)\n    {\n      if(info->palette[4 * (i - 1) + 3] == 255) amount--;\n      else break;\n    }\n    /*add only alpha channel*/\n    for(i = 0; i < amount; i++) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);\n  }\n  else if(info->colortype == LCT_GREY)\n  {\n    if(info->key_defined)\n    {\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));\n    }\n  }\n  else if(info->colortype == LCT_RGB)\n  {\n    if(info->key_defined)\n    {\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_g / 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_g % 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_b / 256));\n      ucvector_push_back(&tRNS, (unsigned char)(info->key_b % 256));\n    }\n  }\n\n  error = addChunk(out, \"tRNS\", tRNS.data, tRNS.size);\n  ucvector_cleanup(&tRNS);\n\n  return error;\n}\n\nstatic unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,\n                              LodePNGCompressSettings* zlibsettings)\n{\n  ucvector zlibdata;\n  unsigned error = 0;\n\n  /*compress with the Zlib compressor*/\n  ucvector_init(&zlibdata);\n  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);\n  if(!error) error = addChunk(out, \"IDAT\", zlibdata.data, zlibdata.size);\n  ucvector_cleanup(&zlibdata);\n\n  return error;\n}\n\nstatic unsigned addChunk_IEND(ucvector* out)\n{\n  unsigned error = 0;\n  error = addChunk(out, \"IEND\", 0, 0);\n  return error;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n\nstatic unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)\n{\n  unsigned error = 0;\n  size_t i;\n  ucvector text;\n  ucvector_init(&text);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&text, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\n  ucvector_push_back(&text, 0); /*0 termination char*/\n  for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&text, (unsigned char)textstring[i]);\n  error = addChunk(out, \"tEXt\", text.data, text.size);\n  ucvector_cleanup(&text);\n\n  return error;\n}\n\nstatic unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,\n                              LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data, compressed;\n  size_t i, textsize = strlen(textstring);\n\n  ucvector_init(&data);\n  ucvector_init(&compressed);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\n  ucvector_push_back(&data, 0); /*0 termination char*/\n  ucvector_push_back(&data, 0); /*compression method: 0*/\n\n  error = zlib_compress(&compressed.data, &compressed.size,\n                        (unsigned char*)textstring, textsize, zlibsettings);\n  if(!error)\n  {\n    for(i = 0; i < compressed.size; i++) ucvector_push_back(&data, compressed.data[i]);\n    error = addChunk(out, \"zTXt\", data.data, data.size);\n  }\n\n  ucvector_cleanup(&compressed);\n  ucvector_cleanup(&data);\n  return error;\n}\n\nstatic unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data;\n  size_t i, textsize = strlen(textstring);\n\n  ucvector_init(&data);\n\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/\n  ucvector_push_back(&data, 0); /*null termination char*/\n  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/\n  ucvector_push_back(&data, 0); /*compression method*/\n  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);\n  ucvector_push_back(&data, 0); /*null termination char*/\n  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);\n  ucvector_push_back(&data, 0); /*null termination char*/\n\n  if(compressed)\n  {\n    ucvector compressed_data;\n    ucvector_init(&compressed_data);\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\n                          (unsigned char*)textstring, textsize, zlibsettings);\n    if(!error)\n    {\n      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);\n    }\n    ucvector_cleanup(&compressed_data);\n  }\n  else /*not compressed*/\n  {\n    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);\n  }\n\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\n  ucvector_cleanup(&data);\n  return error;\n}\n\nstatic unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)\n{\n  unsigned error = 0;\n  ucvector bKGD;\n  ucvector_init(&bKGD);\n  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)\n  {\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));\n  }\n  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)\n  {\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_g / 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_g % 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_b / 256));\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_b % 256));\n  }\n  else if(info->color.colortype == LCT_PALETTE)\n  {\n    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256)); /*palette index*/\n  }\n\n  error = addChunk(out, \"bKGD\", bKGD.data, bKGD.size);\n  ucvector_cleanup(&bKGD);\n\n  return error;\n}\n\nstatic unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)\n{\n  unsigned error = 0;\n  unsigned char* data = (unsigned char*)lodepng_malloc(7);\n  if(!data) return 83; /*alloc fail*/\n  data[0] = (unsigned char)(time->year / 256);\n  data[1] = (unsigned char)(time->year % 256);\n  data[2] = (unsigned char)time->month;\n  data[3] = (unsigned char)time->day;\n  data[4] = (unsigned char)time->hour;\n  data[5] = (unsigned char)time->minute;\n  data[6] = (unsigned char)time->second;\n  error = addChunk(out, \"tIME\", data, 7);\n  lodepng_free(data);\n  return error;\n}\n\nstatic unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)\n{\n  unsigned error = 0;\n  ucvector data;\n  ucvector_init(&data);\n\n  lodepng_add32bitInt(&data, info->phys_x);\n  lodepng_add32bitInt(&data, info->phys_y);\n  ucvector_push_back(&data, info->phys_unit);\n\n  error = addChunk(out, \"pHYs\", data.data, data.size);\n  ucvector_cleanup(&data);\n\n  return error;\n}\n\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nstatic void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,\n                           size_t length, size_t bytewidth, unsigned char filterType)\n{\n  size_t i;\n  switch(filterType)\n  {\n    case 0: /*None*/\n      for(i = 0; i < length; i++) out[i] = scanline[i];\n      break;\n    case 1: /*Sub*/\n      if(prevline)\n      {\n        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];\n        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth];\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];\n        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth];\n      }\n      break;\n    case 2: /*Up*/\n      if(prevline)\n      {\n        for(i = 0; i < length; i++) out[i] = scanline[i] - prevline[i];\n      }\n      else\n      {\n        for(i = 0; i < length; i++) out[i] = scanline[i];\n      }\n      break;\n    case 3: /*Average*/\n      if(prevline)\n      {\n        for(i = 0; i < bytewidth; i++) out[i] = scanline[i] - prevline[i] / 2;\n        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) / 2);\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];\n        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth] / 2;\n      }\n      break;\n    case 4: /*Paeth*/\n      if(prevline)\n      {\n        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/\n        for(i = 0; i < bytewidth; i++) out[i] = (scanline[i] - prevline[i]);\n        for(i = bytewidth; i < length; i++)\n        {\n          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));\n        }\n      }\n      else\n      {\n        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];\n        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/\n        for(i = bytewidth; i < length; i++) out[i] = (scanline[i] - scanline[i - bytewidth]);\n      }\n      break;\n    default: return; /*unexisting filter type given*/\n  }\n}\n\n/* log2 approximation. A slight bit faster than std::log. */\nstatic float flog2(float f)\n{\n  float result = 0;\n  while(f > 32) { result += 4; f /= 16; }\n  while(f > 2) { result++; f /= 2; }\n  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);\n}\n\nstatic unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,\n                       const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)\n{\n  /*\n  For PNG filter method 0\n  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are\n  the scanlines with 1 extra byte per scanline\n  */\n\n  unsigned bpp = lodepng_get_bpp(info);\n  /*the width of a scanline in bytes, not including the filter type*/\n  size_t linebytes = (w * bpp + 7) / 8;\n  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/\n  size_t bytewidth = (bpp + 7) / 8;\n  const unsigned char* prevline = 0;\n  unsigned x, y;\n  unsigned error = 0;\n  LodePNGFilterStrategy strategy = settings->filter_strategy;\n\n  /*\n  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:\n   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.\n      use fixed filtering, with the filter None).\n   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is\n     not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply\n     all five filters and select the filter that produces the smallest sum of absolute values per row.\n  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.\n\n  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,\n  but for \"the other case\", whatever strategy filter_strategy is set to instead of the minimum sum\n  heuristic is used.\n  */\n  if(settings->filter_palette_zero &&\n     (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;\n\n  if(bpp == 0) return 31; /*error: invalid color type*/\n\n  if(strategy == LFS_ZERO)\n  {\n    for(y = 0; y < h; y++)\n    {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      out[outindex] = 0; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);\n      prevline = &in[inindex];\n    }\n  }\n  else if(strategy == LFS_MINSUM)\n  {\n    /*adaptive filtering*/\n    size_t sum[5];\n    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned char type, bestType = 0;\n\n    for(type = 0; type < 5; type++)\n    {\n      ucvector_init(&attempt[type]);\n      if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/\n    }\n\n    if(!error)\n    {\n      for(y = 0; y < h; y++)\n      {\n        /*try the 5 filter types*/\n        for(type = 0; type < 5; type++)\n        {\n          filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);\n\n          /*calculate the sum of the result*/\n          sum[type] = 0;\n          if(type == 0)\n          {\n            for(x = 0; x < linebytes; x++) sum[type] += (unsigned char)(attempt[type].data[x]);\n          }\n          else\n          {\n            for(x = 0; x < linebytes; x++)\n            {\n              /*For differences, each byte should be treated as signed, values above 127 are negative\n              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.\n              This means filtertype 0 is almost never chosen, but that is justified.*/\n              unsigned char s = attempt[type].data[x];\n              sum[type] += s < 128 ? s : (255U - s);\n            }\n          }\n\n          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n          if(type == 0 || sum[type] < smallest)\n          {\n            bestType = type;\n            smallest = sum[type];\n          }\n        }\n\n        prevline = &in[y * linebytes];\n\n        /*now fill the out values*/\n        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n        for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];\n      }\n    }\n\n    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);\n  }\n  else if(strategy == LFS_ENTROPY)\n  {\n    float sum[5];\n    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/\n    float smallest = 0;\n    unsigned type, bestType = 0;\n    unsigned count[256];\n\n    for(type = 0; type < 5; type++)\n    {\n      ucvector_init(&attempt[type]);\n      if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/\n    }\n\n    for(y = 0; y < h; y++)\n    {\n      /*try the 5 filter types*/\n      for(type = 0; type < 5; type++)\n      {\n        filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);\n        for(x = 0; x < 256; x++) count[x] = 0;\n        for(x = 0; x < linebytes; x++) count[attempt[type].data[x]]++;\n        count[type]++; /*the filter type itself is part of the scanline*/\n        sum[type] = 0;\n        for(x = 0; x < 256; x++)\n        {\n          float p = count[x] / (float)(linebytes + 1);\n          sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;\n        }\n        /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/\n        if(type == 0 || sum[type] < smallest)\n        {\n          bestType = type;\n          smallest = sum[type];\n        }\n      }\n\n      prevline = &in[y * linebytes];\n\n      /*now fill the out values*/\n      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n      for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];\n    }\n\n    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);\n  }\n  else if(strategy == LFS_PREDEFINED)\n  {\n    for(y = 0; y < h; y++)\n    {\n      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/\n      size_t inindex = linebytes * y;\n      unsigned char type = settings->predefined_filters[y];\n      out[outindex] = type; /*filter type byte*/\n      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);\n      prevline = &in[inindex];\n    }\n  }\n  else if(strategy == LFS_BRUTE_FORCE)\n  {\n    /*brute force filter chooser.\n    deflate the scanline after every filter attempt to see which one deflates best.\n    This is very slow and gives only slightly smaller, sometimes even larger, result*/\n    size_t size[5];\n    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/\n    size_t smallest = 0;\n    unsigned type = 0, bestType = 0;\n    unsigned char* dummy;\n    LodePNGCompressSettings zlibsettings = settings->zlibsettings;\n    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,\n    to simulate the true case where the tree is the same for the whole image. Sometimes it gives\n    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare\n    cases better compression. It does make this a bit less slow, so it's worth doing this.*/\n    zlibsettings.btype = 1;\n    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG\n    images only, so disable it*/\n    zlibsettings.custom_zlib = 0;\n    zlibsettings.custom_deflate = 0;\n    for(type = 0; type < 5; type++)\n    {\n      ucvector_init(&attempt[type]);\n      ucvector_resize(&attempt[type], linebytes); /*todo: give error if resize failed*/\n    }\n    for(y = 0; y < h; y++) /*try the 5 filter types*/\n    {\n      for(type = 0; type < 5; type++)\n      {\n        unsigned testsize = attempt[type].size;\n        /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/\n\n        filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);\n        size[type] = 0;\n        dummy = 0;\n        zlib_compress(&dummy, &size[type], attempt[type].data, testsize, &zlibsettings);\n        lodepng_free(dummy);\n        /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/\n        if(type == 0 || size[type] < smallest)\n        {\n          bestType = type;\n          smallest = size[type];\n        }\n      }\n      prevline = &in[y * linebytes];\n      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/\n      for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];\n    }\n    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);\n  }\n  else return 88; /* unknown filter strategy */\n\n  return error;\n}\n\nstatic void addPaddingBits(unsigned char* out, const unsigned char* in,\n                           size_t olinebits, size_t ilinebits, unsigned h)\n{\n  /*The opposite of the removePaddingBits function\n  olinebits must be >= ilinebits*/\n  unsigned y;\n  size_t diff = olinebits - ilinebits;\n  size_t obp = 0, ibp = 0; /*bit pointers*/\n  for(y = 0; y < h; y++)\n  {\n    size_t x;\n    for(x = 0; x < ilinebits; x++)\n    {\n      unsigned char bit = readBitFromReversedStream(&ibp, in);\n      setBitOfReversedStream(&obp, out, bit);\n    }\n    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid\n    \"Use of uninitialised value of size ###\" warning from valgrind*/\n    for(x = 0; x < diff; x++) setBitOfReversedStream(&obp, out, 0);\n  }\n}\n\n/*\nin: non-interlaced image with size w*h\nout: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with\n no padding bits between scanlines, but between reduced images so that each\n reduced image starts at a byte.\nbpp: bits per pixel\nthere are no padding bits, not between scanlines, not between reduced images\nin has the following size in bits: w * h * bpp.\nout is possibly bigger due to padding bits between reduced images\nNOTE: comments about padding bits are only relevant if bpp < 8\n*/\nstatic void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)\n{\n  unsigned passw[7], passh[7];\n  size_t filter_passstart[8], padded_passstart[8], passstart[8];\n  unsigned i;\n\n  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n  if(bpp >= 8)\n  {\n    for(i = 0; i < 7; i++)\n    {\n      unsigned x, y, b;\n      size_t bytewidth = bpp / 8;\n      for(y = 0; y < passh[i]; y++)\n      for(x = 0; x < passw[i]; x++)\n      {\n        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;\n        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;\n        for(b = 0; b < bytewidth; b++)\n        {\n          out[pixeloutstart + b] = in[pixelinstart + b];\n        }\n      }\n    }\n  }\n  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/\n  {\n    for(i = 0; i < 7; i++)\n    {\n      unsigned x, y, b;\n      unsigned ilinebits = bpp * passw[i];\n      unsigned olinebits = bpp * w;\n      size_t obp, ibp; /*bit pointers (for out and in buffer)*/\n      for(y = 0; y < passh[i]; y++)\n      for(x = 0; x < passw[i]; x++)\n      {\n        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;\n        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);\n        for(b = 0; b < bpp; b++)\n        {\n          unsigned char bit = readBitFromReversedStream(&ibp, in);\n          setBitOfReversedStream(&obp, out, bit);\n        }\n      }\n    }\n  }\n}\n\n/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.\nreturn value is error**/\nstatic unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,\n                                    unsigned w, unsigned h,\n                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)\n{\n  /*\n  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:\n  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter\n  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter\n  */\n  unsigned bpp = lodepng_get_bpp(&info_png->color);\n  unsigned error = 0;\n\n  if(info_png->interlace_method == 0)\n  {\n    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/\n\n    if(!error)\n    {\n      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/\n      if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)\n      {\n        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));\n        if(!padded) error = 83; /*alloc fail*/\n        if(!error)\n        {\n          addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);\n          error = filter(*out, padded, w, h, &info_png->color, settings);\n        }\n        lodepng_free(padded);\n      }\n      else\n      {\n        /*we can immediatly filter into the out buffer, no other steps needed*/\n        error = filter(*out, in, w, h, &info_png->color, settings);\n      }\n    }\n  }\n  else /*interlace_method is 1 (Adam7)*/\n  {\n    unsigned passw[7], passh[7];\n    size_t filter_passstart[8], padded_passstart[8], passstart[8];\n    unsigned char* adam7;\n\n    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);\n\n    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/\n    *out = (unsigned char*)lodepng_malloc(*outsize);\n    if(!(*out)) error = 83; /*alloc fail*/\n\n    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);\n    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/\n\n    if(!error)\n    {\n      unsigned i;\n\n      Adam7_interlace(adam7, in, w, h, bpp);\n      for(i = 0; i < 7; i++)\n      {\n        if(bpp < 8)\n        {\n          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);\n          if(!padded) ERROR_BREAK(83); /*alloc fail*/\n          addPaddingBits(padded, &adam7[passstart[i]],\n                         ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);\n          error = filter(&(*out)[filter_passstart[i]], padded,\n                         passw[i], passh[i], &info_png->color, settings);\n          lodepng_free(padded);\n        }\n        else\n        {\n          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],\n                         passw[i], passh[i], &info_png->color, settings);\n        }\n\n        if(error) break;\n      }\n    }\n\n    lodepng_free(adam7);\n  }\n\n  return error;\n}\n\n/*\npalette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...\nreturns 0 if the palette is opaque,\nreturns 1 if the palette has a single color with alpha 0 ==> color key\nreturns 2 if the palette is semi-translucent.\n*/\nstatic unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)\n{\n  size_t i;\n  unsigned key = 0;\n  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/\n  for(i = 0; i < palettesize; i++)\n  {\n    if(!key && palette[4 * i + 3] == 0)\n    {\n      r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];\n      key = 1;\n      i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/\n    }\n    else if(palette[4 * i + 3] != 255) return 2;\n    /*when key, no opaque RGB may have key's RGB*/\n    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;\n  }\n  return key;\n}\n\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\nstatic unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)\n{\n  unsigned char* inchunk = data;\n  while((size_t)(inchunk - data) < datasize)\n  {\n    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));\n    out->allocsize = out->size; /*fix the allocsize again*/\n    inchunk = lodepng_chunk_next(inchunk);\n  }\n  return 0;\n}\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n\nunsigned lodepng_encode(unsigned char** out, size_t* outsize,\n                        const unsigned char* image, unsigned w, unsigned h,\n                        LodePNGState* state)\n{\n  LodePNGInfo info;\n  ucvector outv;\n  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/\n  size_t datasize = 0;\n\n  /*provide some proper output values if error will happen*/\n  *out = 0;\n  *outsize = 0;\n  state->error = 0;\n\n  lodepng_info_init(&info);\n  lodepng_info_copy(&info, &state->info_png);\n\n  if((info.color.colortype == LCT_PALETTE || state->encoder.force_palette)\n      && (info.color.palettesize == 0 || info.color.palettesize > 256))\n  {\n    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/\n    return state->error;\n  }\n\n  if(state->encoder.auto_convert)\n  {\n    state->error = lodepng_auto_choose_color(&info.color, image, w, h, &state->info_raw);\n  }\n  if(state->error) return state->error;\n\n  if(state->encoder.zlibsettings.btype > 2)\n  {\n    CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/\n  }\n  if(state->info_png.interlace_method > 1)\n  {\n    CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/\n  }\n\n  state->error = checkColorValidity(info.color.colortype, info.color.bitdepth);\n  if(state->error) return state->error; /*error: unexisting color type given*/\n  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);\n  if(state->error) return state->error; /*error: unexisting color type given*/\n\n  if(!lodepng_color_mode_equal(&state->info_raw, &info.color))\n  {\n    unsigned char* converted;\n    size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;\n\n    converted = (unsigned char*)lodepng_malloc(size);\n    if(!converted && size) state->error = 83; /*alloc fail*/\n    if(!state->error)\n    {\n      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);\n    }\n    if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);\n    lodepng_free(converted);\n  }\n  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);\n\n  ucvector_init(&outv);\n  while(!state->error) /*while only executed once, to break on error*/\n  {\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    size_t i;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*write signature and chunks*/\n    writeSignature(&outv);\n    /*IHDR*/\n    addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*unknown chunks between IHDR and PLTE*/\n    if(info.unknown_chunks_data[0])\n    {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);\n      if(state->error) break;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*PLTE*/\n    if(info.color.colortype == LCT_PALETTE)\n    {\n      addChunk_PLTE(&outv, &info.color);\n    }\n    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))\n    {\n      addChunk_PLTE(&outv, &info.color);\n    }\n    /*tRNS*/\n    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)\n    {\n      addChunk_tRNS(&outv, &info.color);\n    }\n    if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)\n    {\n      addChunk_tRNS(&outv, &info.color);\n    }\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*bKGD (must come between PLTE and the IDAt chunks*/\n    if(info.background_defined) addChunk_bKGD(&outv, &info);\n    /*pHYs (must come before the IDAT chunks)*/\n    if(info.phys_defined) addChunk_pHYs(&outv, &info);\n\n    /*unknown chunks between PLTE and IDAT*/\n    if(info.unknown_chunks_data[1])\n    {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);\n      if(state->error) break;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    /*IDAT (multiple IDAT chunks must be consecutive)*/\n    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);\n    if(state->error) break;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n    /*tIME*/\n    if(info.time_defined) addChunk_tIME(&outv, &info.time);\n    /*tEXt and/or zTXt*/\n    for(i = 0; i < info.text_num; i++)\n    {\n      if(strlen(info.text_keys[i]) > 79)\n      {\n        state->error = 66; /*text chunk too large*/\n        break;\n      }\n      if(strlen(info.text_keys[i]) < 1)\n      {\n        state->error = 67; /*text chunk too small*/\n        break;\n      }\n      if(state->encoder.text_compression)\n      {\n        addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);\n      }\n      else\n      {\n        addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);\n      }\n    }\n    /*LodePNG version id in text chunk*/\n    if(state->encoder.add_id)\n    {\n      unsigned alread_added_id_text = 0;\n      for(i = 0; i < info.text_num; i++)\n      {\n        if(!strcmp(info.text_keys[i], \"LodePNG\"))\n        {\n          alread_added_id_text = 1;\n          break;\n        }\n      }\n      if(alread_added_id_text == 0)\n      {\n        addChunk_tEXt(&outv, \"LodePNG\", VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/\n      }\n    }\n    /*iTXt*/\n    for(i = 0; i < info.itext_num; i++)\n    {\n      if(strlen(info.itext_keys[i]) > 79)\n      {\n        state->error = 66; /*text chunk too large*/\n        break;\n      }\n      if(strlen(info.itext_keys[i]) < 1)\n      {\n        state->error = 67; /*text chunk too small*/\n        break;\n      }\n      addChunk_iTXt(&outv, state->encoder.text_compression,\n                    info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],\n                    &state->encoder.zlibsettings);\n    }\n\n    /*unknown chunks between IDAT and IEND*/\n    if(info.unknown_chunks_data[2])\n    {\n      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);\n      if(state->error) break;\n    }\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n    addChunk_IEND(&outv);\n\n    break; /*this isn't really a while loop; no error happened so break out now!*/\n  }\n\n  lodepng_info_cleanup(&info);\n  lodepng_free(data);\n  /*instead of cleaning the vector up, give it to the output*/\n  *out = outv.data;\n  *outsize = outv.size;\n\n  return state->error;\n}\n\nunsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,\n                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned error;\n  LodePNGState state;\n  lodepng_state_init(&state);\n  state.info_raw.colortype = colortype;\n  state.info_raw.bitdepth = bitdepth;\n  state.info_png.color.colortype = colortype;\n  state.info_png.color.bitdepth = bitdepth;\n  lodepng_encode(out, outsize, image, w, h, &state);\n  error = state.error;\n  lodepng_state_cleanup(&state);\n  return error;\n}\n\nunsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)\n{\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)\n{\n  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,\n                             LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);\n  if(!error) error = lodepng_save_file(buffer, buffersize, filename);\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)\n{\n  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);\n}\n\nunsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)\n{\n  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);\n}\n#endif /*LODEPNG_COMPILE_DISK*/\n\nvoid lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)\n{\n  lodepng_compress_settings_init(&settings->zlibsettings);\n  settings->filter_palette_zero = 1;\n  settings->filter_strategy = LFS_MINSUM;\n  settings->auto_convert = 1;\n  settings->force_palette = 0;\n  settings->predefined_filters = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  settings->add_id = 0;\n  settings->text_compression = 1;\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n\n#endif /*LODEPNG_COMPILE_ENCODER*/\n#endif /*LODEPNG_COMPILE_PNG*/\n\n#ifdef LODEPNG_COMPILE_ERROR_TEXT\n/*\nThis returns the description of a numerical error code in English. This is also\nthe documentation of all the error codes.\n*/\nconst char* lodepng_error_text(unsigned code)\n{\n  switch(code)\n  {\n    case 0: return \"no error, everything went ok\";\n    case 1: return \"nothing done yet\"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/\n    case 10: return \"end of input memory reached without huffman end code\"; /*while huffman decoding*/\n    case 11: return \"error in code tree made it jump outside of huffman tree\"; /*while huffman decoding*/\n    case 13: return \"problem while processing dynamic deflate block\";\n    case 14: return \"problem while processing dynamic deflate block\";\n    case 15: return \"problem while processing dynamic deflate block\";\n    case 16: return \"unexisting code while processing dynamic deflate block\";\n    case 17: return \"end of out buffer memory reached while inflating\";\n    case 18: return \"invalid distance code while inflating\";\n    case 19: return \"end of out buffer memory reached while inflating\";\n    case 20: return \"invalid deflate block BTYPE encountered while decoding\";\n    case 21: return \"NLEN is not ones complement of LEN in a deflate block\";\n     /*end of out buffer memory reached while inflating:\n     This can happen if the inflated deflate data is longer than the amount of bytes required to fill up\n     all the pixels of the image, given the color depth and image dimensions. Something that doesn't\n     happen in a normal, well encoded, PNG image.*/\n    case 22: return \"end of out buffer memory reached while inflating\";\n    case 23: return \"end of in buffer memory reached while inflating\";\n    case 24: return \"invalid FCHECK in zlib header\";\n    case 25: return \"invalid compression method in zlib header\";\n    case 26: return \"FDICT encountered in zlib header while it's not used for PNG\";\n    case 27: return \"PNG file is smaller than a PNG header\";\n    /*Checks the magic file header, the first 8 bytes of the PNG file*/\n    case 28: return \"incorrect PNG signature, it's no PNG or corrupted\";\n    case 29: return \"first chunk is not the header chunk\";\n    case 30: return \"chunk length too large, chunk broken off at end of file\";\n    case 31: return \"illegal PNG color type or bpp\";\n    case 32: return \"illegal PNG compression method\";\n    case 33: return \"illegal PNG filter method\";\n    case 34: return \"illegal PNG interlace method\";\n    case 35: return \"chunk length of a chunk is too large or the chunk too small\";\n    case 36: return \"illegal PNG filter type encountered\";\n    case 37: return \"illegal bit depth for this color type given\";\n    case 38: return \"the palette is too big\"; /*more than 256 colors*/\n    case 39: return \"more palette alpha values given in tRNS chunk than there are colors in the palette\";\n    case 40: return \"tRNS chunk has wrong size for greyscale image\";\n    case 41: return \"tRNS chunk has wrong size for RGB image\";\n    case 42: return \"tRNS chunk appeared while it was not allowed for this color type\";\n    case 43: return \"bKGD chunk has wrong size for palette image\";\n    case 44: return \"bKGD chunk has wrong size for greyscale image\";\n    case 45: return \"bKGD chunk has wrong size for RGB image\";\n    /*the input data is empty, maybe a PNG file doesn't exist or is in the wrong path*/\n    case 48: return \"empty input or file doesn't exist\";\n    case 49: return \"jumped past memory while generating dynamic huffman tree\";\n    case 50: return \"jumped past memory while generating dynamic huffman tree\";\n    case 51: return \"jumped past memory while inflating huffman block\";\n    case 52: return \"jumped past memory while inflating\";\n    case 53: return \"size of zlib data too small\";\n    case 54: return \"repeat symbol in tree while there was no value symbol yet\";\n    /*jumped past tree while generating huffman tree, this could be when the\n    tree will have more leaves than symbols after generating it out of the\n    given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/\n    case 55: return \"jumped past tree while generating huffman tree\";\n    case 56: return \"given output image colortype or bitdepth not supported for color conversion\";\n    case 57: return \"invalid CRC encountered (checking CRC can be disabled)\";\n    case 58: return \"invalid ADLER32 encountered (checking ADLER32 can be disabled)\";\n    case 59: return \"requested color conversion not supported\";\n    case 60: return \"invalid window size given in the settings of the encoder (must be 0-32768)\";\n    case 61: return \"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\";\n    /*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/\n    case 62: return \"conversion from color to greyscale not supported\";\n    case 63: return \"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\"; /*(2^31-1)*/\n    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/\n    case 64: return \"the length of the END symbol 256 in the Huffman tree is 0\";\n    case 66: return \"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\";\n    case 67: return \"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\";\n    case 68: return \"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\";\n    case 69: return \"unknown chunk type with 'critical' flag encountered by the decoder\";\n    case 71: return \"unexisting interlace mode given to encoder (must be 0 or 1)\";\n    case 72: return \"while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)\";\n    case 73: return \"invalid tIME chunk size\";\n    case 74: return \"invalid pHYs chunk size\";\n    /*length could be wrong, or data chopped off*/\n    case 75: return \"no null termination char found while decoding text chunk\";\n    case 76: return \"iTXt chunk too short to contain required bytes\";\n    case 77: return \"integer overflow in buffer size\";\n    case 78: return \"failed to open file for reading\"; /*file doesn't exist or couldn't be opened for reading*/\n    case 79: return \"failed to open file for writing\";\n    case 80: return \"tried creating a tree of 0 symbols\";\n    case 81: return \"lazy matching at pos 0 is impossible\";\n    case 82: return \"color conversion to palette requested while a color isn't in palette\";\n    case 83: return \"memory allocation failed\";\n    case 84: return \"given image too small to contain all pixels to be encoded\";\n    case 86: return \"impossible offset in lz77 encoding (internal bug)\";\n    case 87: return \"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\";\n    case 88: return \"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\";\n    case 89: return \"text chunk keyword too short or long: must have size 1-79\";\n    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/\n    case 90: return \"windowsize must be a power of two\";\n  }\n  return \"unknown error code\";\n}\n#endif /*LODEPNG_COMPILE_ERROR_TEXT*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // C++ Wrapper                                                          // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n#ifdef LODEPNG_COMPILE_CPP\nnamespace lodepng\n{\n\n#ifdef LODEPNG_COMPILE_DISK\nvoid load_file(std::vector<unsigned char>& buffer, const std::string& filename)\n{\n  std::ifstream file(filename.c_str(), std::ios::in|std::ios::binary|std::ios::ate);\n\n  /*get filesize*/\n  std::streamsize size = 0;\n  if(file.seekg(0, std::ios::end).good()) size = file.tellg();\n  if(file.seekg(0, std::ios::beg).good()) size -= file.tellg();\n\n  /*read contents of the file into the vector*/\n  buffer.resize(size_t(size));\n  if(size > 0) file.read((char*)(&buffer[0]), size);\n}\n\n/*write given buffer to the file, overwriting the file, it doesn't append to it.*/\nvoid save_file(const std::vector<unsigned char>& buffer, const std::string& filename)\n{\n  std::ofstream file(filename.c_str(), std::ios::out|std::ios::binary);\n  file.write(buffer.empty() ? 0 : (char*)&buffer[0], std::streamsize(buffer.size()));\n}\n#endif //LODEPNG_COMPILE_DISK\n\n#ifdef LODEPNG_COMPILE_ZLIB\n#ifdef LODEPNG_COMPILE_DECODER\nunsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                    const LodePNGDecompressSettings& settings)\n{\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_decompress(&buffer, &buffersize, in, insize, &settings);\n  if(buffer)\n  {\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                    const LodePNGDecompressSettings& settings)\n{\n  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif //LODEPNG_COMPILE_DECODER\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,\n                  const LodePNGCompressSettings& settings)\n{\n  unsigned char* buffer = 0;\n  size_t buffersize = 0;\n  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);\n  if(buffer)\n  {\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,\n                  const LodePNGCompressSettings& settings)\n{\n  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);\n}\n#endif //LODEPNG_COMPILE_ENCODER\n#endif //LODEPNG_COMPILE_ZLIB\n\n\n#ifdef LODEPNG_COMPILE_PNG\n\nState::State()\n{\n  lodepng_state_init(this);\n}\n\nState::State(const State& other)\n{\n  lodepng_state_init(this);\n  lodepng_state_copy(this, &other);\n}\n\nState::~State()\n{\n  lodepng_state_cleanup(this);\n}\n\nState& State::operator=(const State& other)\n{\n  lodepng_state_copy(this, &other);\n  return *this;\n}\n\n#ifdef LODEPNG_COMPILE_DECODER\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,\n                size_t insize, LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned char* buffer;\n  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);\n  if(buffer && !error)\n  {\n    State state;\n    state.info_raw.colortype = colortype;\n    state.info_raw.bitdepth = bitdepth;\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth)\n{\n  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const unsigned char* in, size_t insize)\n{\n  unsigned char* buffer = NULL;\n  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);\n  if(buffer && !error)\n  {\n    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n  }\n  lodepng_free(buffer);\n  return error;\n}\n\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,\n                State& state,\n                const std::vector<unsigned char>& in)\n{\n  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,\n                LodePNGColorType colortype, unsigned bitdepth)\n{\n  std::vector<unsigned char> buffer;\n  load_file(buffer, filename);\n  return decode(out, w, h, buffer, colortype, bitdepth);\n}\n#endif //LODEPNG_COMPILE_DECODER\n#endif //LODEPNG_COMPILE_DISK\n\n#ifdef LODEPNG_COMPILE_ENCODER\nunsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);\n  if(buffer)\n  {\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth)\n{\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const unsigned char* in, unsigned w, unsigned h,\n                State& state)\n{\n  unsigned char* buffer;\n  size_t buffersize;\n  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);\n  if(buffer)\n  {\n    out.insert(out.end(), &buffer[0], &buffer[buffersize]);\n    lodepng_free(buffer);\n  }\n  return error;\n}\n\nunsigned encode(std::vector<unsigned char>& out,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                State& state)\n{\n  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;\n  return encode(out, in.empty() ? 0 : &in[0], w, h, state);\n}\n\n#ifdef LODEPNG_COMPILE_DISK\nunsigned encode(const std::string& filename,\n                const unsigned char* in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth)\n{\n  std::vector<unsigned char> buffer;\n  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);\n  if(!error) save_file(buffer, filename);\n  return error;\n}\n\nunsigned encode(const std::string& filename,\n                const std::vector<unsigned char>& in, unsigned w, unsigned h,\n                LodePNGColorType colortype, unsigned bitdepth)\n{\n  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;\n  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);\n}\n#endif //LODEPNG_COMPILE_DISK\n#endif //LODEPNG_COMPILE_ENCODER\n#endif //LODEPNG_COMPILE_PNG\n} //namespace lodepng\n#endif /*LODEPNG_COMPILE_CPP*/\n","// stb_truetype.h - v0.7 - public domain\r\n// authored from 2009-2013 by Sean Barrett / RAD Game Tools\r\n//\r\n//   This library processes TrueType files:\r\n//        parse files\r\n//        extract glyph metrics\r\n//        extract glyph shapes\r\n//        render glyphs to one-channel bitmaps with antialiasing (box filter)\r\n//\r\n//   Todo:\r\n//        non-MS cmaps\r\n//        crashproof on bad data\r\n//        hinting? (no longer patented)\r\n//        cleartype-style AA?\r\n//        optimize: use simple memory allocator for intermediates\r\n//        optimize: build edge-list directly from curves\r\n//        optimize: rasterize directly from curves?\r\n//\r\n// ADDITIONAL CONTRIBUTORS\r\n//\r\n//   Mikko Mononen: compound shape support, more cmap formats\r\n//   Tor Andersson: kerning, subpixel rendering\r\n//\r\n//   Bug/warning reports:\r\n//       \"Zer\" on mollyrocket (with fix)\r\n//       Cass Everitt\r\n//       stoiko (Haemimont Games)\r\n//       Brian Hook \r\n//       Walter van Niftrik\r\n//\r\n// VERSION HISTORY\r\n//\r\n//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back\r\n//   0.6c (2012-07-24) improve documentation\r\n//   0.6b (2012-07-20) fix a few more warnings\r\n//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,\r\n//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty\r\n//   0.5  (2011-12-09) bugfixes:\r\n//                        subpixel glyph renderer computed wrong bounding box\r\n//                        first vertex of shape can be off-curve (FreeSans)\r\n//   0.4b (2011-12-03) fixed an error in the font baking example\r\n//   0.4  (2011-12-01) kerning, subpixel rendering (tor)\r\n//                    bugfixes for:\r\n//                        codepoint-to-glyph conversion using table fmt=12\r\n//                        codepoint-to-glyph conversion using table fmt=4\r\n//                        stbtt_GetBakedQuad with non-square texture (Zer)\r\n//                    updated Hello World! sample to use kerning and subpixel\r\n//                    fixed some warnings\r\n//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)\r\n//                    userdata, malloc-from-userdata, non-zero fill (STB)\r\n//   0.2  (2009-03-11) Fix unsigned/signed char warnings\r\n//   0.1  (2009-03-09) First public release\r\n//\r\n// LICENSE\r\n//\r\n//   This software is in the public domain. Where that dedication is not\r\n//   recognized, you are granted a perpetual, irrevokable license to copy\r\n//   and modify this file as you see fit.\r\n//\r\n// USAGE\r\n//\r\n//   Include this file in whatever places neeed to refer to it. In ONE C/C++\r\n//   file, write:\r\n//      #define STB_TRUETYPE_IMPLEMENTATION\r\n//   before the #include of this file. This expands out the actual\r\n//   implementation into that C/C++ file.\r\n//\r\n//   Simple 3D API (don't ship this, but it's fine for tools and quick start,\r\n//                  and you can cut and paste from it to move to more advanced)\r\n//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture\r\n//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char\r\n//\r\n//   \"Load\" a font file from a memory buffer (you have to keep the buffer loaded)\r\n//           stbtt_InitFont()\r\n//           stbtt_GetFontOffsetForIndex()        -- use for TTC font collections\r\n//\r\n//   Render a unicode codepoint to a bitmap\r\n//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap\r\n//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide\r\n//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be\r\n//\r\n//   Character advance/positioning\r\n//           stbtt_GetCodepointHMetrics()\r\n//           stbtt_GetFontVMetrics()\r\n//           stbtt_GetCodepointKernAdvance()\r\n//\r\n// ADDITIONAL DOCUMENTATION\r\n//\r\n//   Immediately after this block comment are a series of sample programs.\r\n//\r\n//   After the sample programs is the \"header file\" section. This section\r\n//   includes documentation for each API function.\r\n//\r\n//   Some important concepts to understand to use this library:\r\n//\r\n//      Codepoint\r\n//         Characters are defined by unicode codepoints, e.g. 65 is\r\n//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is\r\n//         the hiragana for \"ma\".\r\n//\r\n//      Glyph\r\n//         A visual character shape (every codepoint is rendered as\r\n//         some glyph)\r\n//\r\n//      Glyph index\r\n//         A font-specific integer ID representing a glyph\r\n//\r\n//      Baseline\r\n//         Glyph shapes are defined relative to a baseline, which is the\r\n//         bottom of uppercase characters. Characters extend both above\r\n//         and below the baseline.\r\n//\r\n//      Current Point\r\n//         As you draw text to the screen, you keep track of a \"current point\"\r\n//         which is the origin of each character. The current point's vertical\r\n//         position is the baseline. Even \"baked fonts\" use this model.\r\n//\r\n//      Vertical Font Metrics\r\n//         The vertical qualities of the font, used to vertically position\r\n//         and space the characters. See docs for stbtt_GetFontVMetrics.\r\n//\r\n//      Font Size in Pixels or Points\r\n//         The preferred interface for specifying font sizes in stb_truetype\r\n//         is to specify how tall the font's vertical extent should be in pixels.\r\n//         If that sounds good enough, skip the next paragraph.\r\n//\r\n//         Most font APIs instead use \"points\", which are a common typographic\r\n//         measurement for describing font size, defined as 72 points per inch.\r\n//         stb_truetype provides a point API for compatibility. However, true\r\n//         \"per inch\" conventions don't make much sense on computer displays\r\n//         since they different monitors have different number of pixels per\r\n//         inch. For example, Windows traditionally uses a convention that\r\n//         there are 96 pixels per inch, thus making 'inch' measurements have\r\n//         nothing to do with inches, and thus effectively defining a point to\r\n//         be 1.333 pixels. Additionally, the TrueType font data provides\r\n//         an explicit scale factor to scale a given font's glyphs to points,\r\n//         but the author has observed that this scale factor is often wrong\r\n//         for non-commercial fonts, thus making fonts scaled in points\r\n//         according to the TrueType spec incoherently sized in practice.\r\n//\r\n// ADVANCED USAGE\r\n//\r\n//   Quality:\r\n//\r\n//    - Use the functions with Subpixel at the end to allow your characters\r\n//      to have subpixel positioning. Since the font is anti-aliased, not\r\n//      hinted, this is very import for quality. (This is not possible with\r\n//      baked fonts.)\r\n//\r\n//    - Kerning is now supported, and if you're supporting subpixel rendering\r\n//      then kerning is worth using to give your text a polished look.\r\n//\r\n//   Performance:\r\n//\r\n//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;\r\n//      if you don't do this, stb_truetype is forced to do the conversion on\r\n//      every call.\r\n//\r\n//    - There are a lot of memory allocations. We should modify it to take\r\n//      a temp buffer and allocate from the temp buffer (without freeing),\r\n//      should help performance a lot.\r\n//\r\n// NOTES\r\n//\r\n//   The system uses the raw data found in the .ttf file without changing it\r\n//   and without building auxiliary data structures. This is a bit inefficient\r\n//   on little-endian systems (the data is big-endian), but assuming you're\r\n//   caching the bitmaps or glyph shapes this shouldn't be a big deal.\r\n//\r\n//   It appears to be very hard to programmatically determine what font a\r\n//   given file is in a general way. I provide an API for this, but I don't\r\n//   recommend it.\r\n//\r\n//\r\n// SOURCE STATISTICS (based on v0.6c, 2050 LOC)\r\n//\r\n//   Documentation & header file        520 LOC  \\___ 660 LOC documentation\r\n//   Sample code                        140 LOC  /\r\n//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType\r\n//   Software rasterization             240 LOC  \\                           .\r\n//   Curve tesselation                  120 LOC   \\__ 550 LOC Bitmap creation\r\n//   Bitmap management                  100 LOC   /\r\n//   Baked bitmap interface              70 LOC  /\r\n//   Font name matching & access        150 LOC  ---- 150 \r\n//   C runtime library abstraction       60 LOC  ----  60\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n////\r\n////  SAMPLE PROGRAMS\r\n////\r\n//\r\n//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless\r\n//\r\n#if 0\r\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\r\n#include \"stb_truetype.h\"\r\n\r\nchar ttf_buffer[1<<20];\r\nunsigned char temp_bitmap[512*512];\r\n\r\nstbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs\r\nGLstbtt_uint ftex;\r\n\r\nvoid my_stbtt_initfont(void)\r\n{\r\n   fread(ttf_buffer, 1, 1<<20, fopen(\"c:/windows/fonts/times.ttf\", \"rb\"));\r\n   stbtt_BakeFontBitmap(data,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!\r\n   // can free ttf_buffer at this point\r\n   glGenTextures(1, &ftex);\r\n   glBindTexture(GL_TEXTURE_2D, ftex);\r\n   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);\r\n   // can free temp_bitmap at this point\r\n   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\r\n}\r\n\r\nvoid my_stbtt_print(float x, float y, char *text)\r\n{\r\n   // assume orthographic projection with units = screen pixels, origin at top left\r\n   glBindTexture(GL_TEXTURE_2D, ftex);\r\n   glBegin(GL_QUADS);\r\n   while (*text) {\r\n      if (*text >= 32 && *text < 128) {\r\n         stbtt_aligned_quad q;\r\n         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl,0=old d3d\r\n         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);\r\n         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);\r\n         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);\r\n         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);\r\n      }\r\n      ++text;\r\n   }\r\n   glEnd();\r\n}\r\n#endif\r\n//\r\n//\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Complete program (this compiles): get a single bitmap, print as ASCII art\r\n//\r\n#if 0\r\n#include <stdio.h>\r\n#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation\r\n#include \"stb_truetype.h\"\r\n\r\nchar ttf_buffer[1<<25];\r\n\r\nint main(int argc, char **argv)\r\n{\r\n   stbtt_fontinfo font;\r\n   unsigned char *bitmap;\r\n   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);\r\n\r\n   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : \"c:/windows/fonts/arialbd.ttf\", \"rb\"));\r\n\r\n   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));\r\n   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);\r\n\r\n   for (j=0; j < h; ++j) {\r\n      for (i=0; i < w; ++i)\r\n         putchar(\" .:ioVM@\"[bitmap[j*w+i]>>5]);\r\n      putchar('\\n');\r\n   }\r\n   return 0;\r\n}\r\n#endif \r\n//\r\n// Output:\r\n//\r\n//     .ii.\r\n//    @@@@@@.\r\n//   V@Mio@@o\r\n//   :i.  V@V\r\n//     :oM@@M\r\n//   :@@@MM@M\r\n//   @@o  o@M\r\n//  :@@.  M@M\r\n//   @@@o@@@@\r\n//   :M@@V:@@.\r\n//  \r\n//////////////////////////////////////////////////////////////////////////////\r\n// \r\n// Complete program: print \"Hello World!\" banner, with bugs\r\n//\r\n#if 0\r\nchar buffer[24<<20];\r\nunsigned char screen[20][79];\r\n\r\nint main(int arg, char **argv)\r\n{\r\n   stbtt_fontinfo font;\r\n   int i,j,ascent,baseline,ch=0;\r\n   float scale, xpos=0;\r\n   char *text = \"Heljo World!\";\r\n\r\n   fread(buffer, 1, 1000000, fopen(\"c:/windows/fonts/arialbd.ttf\", \"rb\"));\r\n   stbtt_InitFont(&font, buffer, 0);\r\n\r\n   scale = stbtt_ScaleForPixelHeight(&font, 15);\r\n   stbtt_GetFontVMetrics(&font, &ascent,0,0);\r\n   baseline = (int) (ascent*scale);\r\n\r\n   while (text[ch]) {\r\n      int advance,lsb,x0,y0,x1,y1;\r\n      float x_shift = xpos - (float) floor(xpos);\r\n      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);\r\n      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);\r\n      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);\r\n      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong\r\n      // because this API is really for baking character bitmaps into textures. if you want to render\r\n      // a sequence of characters, you really need to render each bitmap to a temp buffer, then\r\n      // \"alpha blend\" that into the working buffer\r\n      xpos += (advance * scale);\r\n      if (text[ch+1])\r\n         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);\r\n      ++ch;\r\n   }\r\n\r\n   for (j=0; j < 20; ++j) {\r\n      for (i=0; i < 78; ++i)\r\n         putchar(\" .:ioVM@\"[screen[j][i]>>5]);\r\n      putchar('\\n');\r\n   }\r\n\r\n   return 0;\r\n}\r\n#endif\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   INTEGRATION WITH YOUR CODEBASE\r\n////\r\n////   The following sections allow you to supply alternate definitions\r\n////   of C library functions used by stb_truetype.\r\n\r\n#ifdef STB_TRUETYPE_IMPLEMENTATION\r\n   // #define your own (u)stbtt_int8/16/32 before including to override this\r\n   #ifndef stbtt_uint8\r\n   typedef unsigned char   stbtt_uint8;\r\n   typedef signed   char   stbtt_int8;\r\n   typedef unsigned short  stbtt_uint16;\r\n   typedef signed   short  stbtt_int16;\r\n   typedef unsigned int    stbtt_uint32;\r\n   typedef signed   int    stbtt_int32;\r\n   #endif\r\n\r\n   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];\r\n   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];\r\n\r\n   // #define your own STBTT_sort() to override this to avoid qsort\r\n   #ifndef STBTT_sort\r\n   #include <stdlib.h>\r\n   #define STBTT_sort(data,num_items,item_size,compare_func)   qsort(data,num_items,item_size,compare_func)\r\n   #endif\r\n\r\n   // #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h\r\n   #ifndef STBTT_ifloor\r\n   #include <math.h>\r\n   #define STBTT_ifloor(x)   ((int) floor(x))\r\n   #define STBTT_iceil(x)    ((int) ceil(x))\r\n   #endif\r\n\r\n   // #define your own functions \"STBTT_malloc\" / \"STBTT_free\" to avoid malloc.h\r\n   #ifndef STBTT_malloc\r\n   //#include <malloc.h>\r\n   #define STBTT_malloc(x,u)  malloc(x)\r\n   #define STBTT_free(x,u)    free(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_assert\r\n   #include <assert.h>\r\n   #define STBTT_assert(x)    assert(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_strlen\r\n   #include <string.h>\r\n   #define STBTT_strlen(x)    strlen(x)\r\n   #endif\r\n\r\n   #ifndef STBTT_memcpy\r\n   #include <memory.h>\r\n   #define STBTT_memcpy       memcpy\r\n   #define STBTT_memset       memset\r\n   #endif\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   INTERFACE\r\n////\r\n////\r\n\r\n#ifndef __STB_INCLUDE_STB_TRUETYPE_H__\r\n#define __STB_INCLUDE_STB_TRUETYPE_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// TEXTURE BAKING API\r\n//\r\n// If you use this API, you only have to call two functions ever.\r\n//\r\n\r\ntypedef struct\r\n{\r\n   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap\r\n   float xoff,yoff,xadvance;   \r\n} stbtt_bakedchar;\r\n\r\nextern int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\r\n                                float pixel_height,                     // height of font in pixels\r\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\r\n                                int first_char, int num_chars,          // characters to bake\r\n                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long\r\n// if return is positive, the first unused row of the bitmap\r\n// if return is negative, returns the negative of the number of characters that fit\r\n// if return is 0, no characters fit and no rows were used\r\n// This uses a very crappy packing.\r\n\r\ntypedef struct\r\n{\r\n   float x0,y0,s0,t0; // top-left\r\n   float x1,y1,s1,t1; // bottom-right\r\n} stbtt_aligned_quad;\r\n\r\nextern void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph,  // same data as above\r\n                               int char_index,             // character to display\r\n                               float *xpos, float *ypos,   // pointers to current position in screen pixel space\r\n                               stbtt_aligned_quad *q,      // output: quad to draw\r\n                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier\r\n// Call GetBakedQuad with char_index = 'character - first_char', and it\r\n// creates the quad you need to draw and advances the current position.\r\n//\r\n// The coordinate system used assumes y increases downwards.\r\n//\r\n// Characters will extend both above and below the current position;\r\n// see discussion of \"BASELINE\" above.\r\n//\r\n// It's inefficient; you might want to c&p it and optimize it.\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// FONT LOADING\r\n//\r\n//\r\n\r\nextern int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);\r\n// Each .ttf/.ttc file may have more than one font. Each font has a sequential\r\n// index number starting from 0. Call this function to get the font offset for\r\n// a given index; it returns -1 if the index is out of range. A regular .ttf\r\n// file will only define one font and it always be at offset 0, so it will\r\n// return '0' for index 0, and -1 for all other indices. You can just skip\r\n// this step if you know it's that kind of font.\r\n\r\n\r\n// The following structure is defined publically so you can declare one on\r\n// the stack or as a global or etc, but you should treat it as opaque.\r\ntypedef struct stbtt_fontinfo\r\n{\r\n   void           * userdata;\r\n   unsigned char  * data;              // pointer to .ttf file\r\n   int              fontstart;         // offset of start of font\r\n\r\n   int numGlyphs;                     // number of glyphs, needed for range checking\r\n\r\n   int loca,head,glyf,hhea,hmtx,kern; // table locations as offset from start of .ttf\r\n   int index_map;                     // a cmap mapping for our chosen character encoding\r\n   int indexToLocFormat;              // format needed to map from glyph index to glyph\r\n} stbtt_fontinfo;\r\n\r\nextern int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);\r\n// Given an offset into the file that defines a font, this function builds\r\n// the necessary cached info for the rest of the system. You must allocate\r\n// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't\r\n// need to do anything special to free it, because the contents are pure\r\n// value data with no additional data structures. Returns 0 on failure.\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHARACTER TO GLYPH-INDEX CONVERSIOn\r\n\r\nint stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);\r\n// If you're going to perform multiple operations on the same character\r\n// and you want a speed-up, call this function with the character you're\r\n// going to process, then use glyph-based functions instead of the\r\n// codepoint-based functions.\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHARACTER PROPERTIES\r\n//\r\n\r\nextern float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);\r\n// computes a scale factor to produce a font whose \"height\" is 'pixels' tall.\r\n// Height is measured as the distance from the highest ascender to the lowest\r\n// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics\r\n// and computing:\r\n//       scale = pixels / (ascent - descent)\r\n// so if you prefer to measure height by the ascent only, use a similar calculation.\r\n\r\nextern float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);\r\n// computes a scale factor to produce a font whose EM size is mapped to\r\n// 'pixels' tall. This is probably what traditional APIs compute, but\r\n// I'm not positive.\r\n\r\nextern void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);\r\n// ascent is the coordinate above the baseline the font extends; descent\r\n// is the coordinate below the baseline the font extends (i.e. it is typically negative)\r\n// lineGap is the spacing between one row's descent and the next row's ascent...\r\n// so you should advance the vertical position by \"*ascent - *descent + *lineGap\"\r\n//   these are expressed in unscaled coordinates, so you must multiply by\r\n//   the scale factor for a given size\r\n\r\nextern void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);\r\n// the bounding box around all possible characters\r\n\r\nextern void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);\r\n// leftSideBearing is the offset from the current horizontal position to the left edge of the character\r\n// advanceWidth is the offset from the current horizontal position to the next horizontal position\r\n//   these are expressed in unscaled coordinates\r\n\r\nextern int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);\r\n// an additional amount to add to the 'advance' value between ch1 and ch2\r\n// @TODO; for now always returns 0!\r\n\r\nextern int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);\r\n// Gets the bounding box of the visible part of the glyph, in unscaled coordinates\r\n\r\nextern void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);\r\nextern int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);\r\nextern int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);\r\n// as above, but takes one or more glyph indices for greater efficiency\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// GLYPH SHAPES (you probably don't need these, but they have to go before\r\n// the bitmaps for C declaration-order reasons)\r\n//\r\n\r\n#ifndef STBTT_vmove // you can predefine these to use different values (but why?)\r\n   enum {\r\n      STBTT_vmove=1,\r\n      STBTT_vline,\r\n      STBTT_vcurve\r\n   };\r\n#endif\r\n\r\n#ifndef stbtt_vertex // you can predefine this to use different values\r\n                   // (we share this with other code at RAD)\r\n   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file\r\n   typedef struct\r\n   {\r\n      stbtt_vertex_type x,y,cx,cy;\r\n      unsigned char type,padding;\r\n   } stbtt_vertex;\r\n#endif\r\n\r\nextern int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);\r\n// returns non-zero if nothing is drawn for this glyph\r\n\r\nextern int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);\r\nextern int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);\r\n// returns # of vertices and fills *vertices with the pointer to them\r\n//   these are expressed in \"unscaled\" coordinates\r\n\r\nextern void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);\r\n// frees the data allocated above\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// BITMAP RENDERING\r\n//\r\n\r\nextern void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);\r\n// frees the bitmap allocated below\r\n\r\nextern unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\r\n// allocates a large-enough single-channel 8bpp bitmap and renders the\r\n// specified character/glyph at the specified scale into it, with\r\n// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).\r\n// *width & *height are filled out with the width & height of the bitmap,\r\n// which is stored left-to-right, top-to-bottom.\r\n//\r\n// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap\r\n\r\nextern unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);\r\n// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel\r\n// shift for the character\r\n\r\nextern void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);\r\n// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap\r\n// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap\r\n// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the\r\n// width and height and positioning info for it first.\r\n\r\nextern void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);\r\n// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel\r\n// shift for the character\r\n\r\nextern void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n// get the bbox of the bitmap centered around the glyph origin; so the\r\n// bitmap width is ix1-ix0, height is iy1-iy0, and location to place\r\n// the bitmap top left is (leftSideBearing*scale,iy0).\r\n// (Note that the bitmap uses y-increases-down, but the shape uses\r\n// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)\r\n\r\nextern void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel\r\n// shift for the character\r\n\r\n// the following functions are equivalent to the above functions, but operate\r\n// on glyph indices instead of Unicode codepoints (for efficiency)\r\nextern unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);\r\nextern unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);\r\nextern void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);\r\nextern void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);\r\nextern void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\nextern void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);\r\n\r\n\r\n// @TODO: don't expose this structure\r\ntypedef struct\r\n{\r\n   int w,h,stride;\r\n   unsigned char *pixels;\r\n} stbtt__bitmap;\r\n\r\nextern void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata);\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Finding the right font...\r\n//\r\n// You should really just solve this offline, keep your own tables\r\n// of what font is what, and don't try to get it out of the .ttf file.\r\n// That's because getting it out of the .ttf file is really hard, because\r\n// the names in the file can appear in many possible encodings, in many\r\n// possible languages, and e.g. if you need a case-insensitive comparison,\r\n// the details of that depend on the encoding & language in a complex way\r\n// (actually underspecified in truetype, but also gigantic).\r\n//\r\n// But you can use the provided functions in two possible ways:\r\n//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on\r\n//             unicode-encoded names to try to find the font you want;\r\n//             you can run this before calling stbtt_InitFont()\r\n//\r\n//     stbtt_GetFontNameString() lets you get any of the various strings\r\n//             from the file yourself and do your own comparisons on them.\r\n//             You have to have called stbtt_InitFont() first.\r\n\r\n\r\nextern int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);\r\n// returns the offset (not index) of the font that matches, or -1 if none\r\n//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like \"Arial Bold\".\r\n//   if you use any other flag, use a font name like \"Arial\"; this checks\r\n//     the 'macStyle' header field; i don't know if fonts set this consistently\r\n#define STBTT_MACSTYLE_DONTCARE     0\r\n#define STBTT_MACSTYLE_BOLD         1\r\n#define STBTT_MACSTYLE_ITALIC       2\r\n#define STBTT_MACSTYLE_UNDERSCORE   4\r\n#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0\r\n\r\nextern int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);\r\n// returns 1/0 whether the first string interpreted as utf8 is identical to\r\n// the second string interpreted as big-endian utf16... useful for strings from next func\r\n\r\nextern const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);\r\n// returns the string (which may be big-endian double byte, e.g. for unicode)\r\n// and puts the length in bytes in *length.\r\n//\r\n// some of the values for the IDs are below; for more see the truetype spec:\r\n//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html\r\n//     http://www.microsoft.com/typography/otspec/name.htm\r\n\r\nenum { // platformID\r\n   STBTT_PLATFORM_ID_UNICODE   =0,\r\n   STBTT_PLATFORM_ID_MAC       =1,\r\n   STBTT_PLATFORM_ID_ISO       =2,\r\n   STBTT_PLATFORM_ID_MICROSOFT =3\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_UNICODE\r\n   STBTT_UNICODE_EID_UNICODE_1_0    =0,\r\n   STBTT_UNICODE_EID_UNICODE_1_1    =1,\r\n   STBTT_UNICODE_EID_ISO_10646      =2,\r\n   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,\r\n   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT\r\n   STBTT_MS_EID_SYMBOL        =0,\r\n   STBTT_MS_EID_UNICODE_BMP   =1,\r\n   STBTT_MS_EID_SHIFTJIS      =2,\r\n   STBTT_MS_EID_UNICODE_FULL  =10\r\n};\r\n\r\nenum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes\r\n   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,\r\n   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,\r\n   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,\r\n   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7\r\n};\r\n\r\nenum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...\r\n       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs\r\n   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,\r\n   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,\r\n   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,\r\n   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,\r\n   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,\r\n   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D\r\n};\r\n\r\nenum { // languageID for STBTT_PLATFORM_ID_MAC\r\n   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,\r\n   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,\r\n   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,\r\n   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,\r\n   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,\r\n   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,\r\n   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19\r\n};\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif // __STB_INCLUDE_STB_TRUETYPE_H__\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////\r\n////\r\n////   IMPLEMENTATION\r\n////\r\n////\r\n\r\n#ifdef STB_TRUETYPE_IMPLEMENTATION\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//\r\n// accessors to parse data from file\r\n//\r\n\r\n// on platforms that don't allow misaligned reads, if we want to allow\r\n// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE\r\n\r\n#define ttBYTE(p)     (* (stbtt_uint8 *) (p))\r\n#define ttCHAR(p)     (* (stbtt_int8 *) (p))\r\n#define ttFixed(p)    ttLONG(p)\r\n\r\n#if defined(STB_TRUETYPE_BIGENDIAN) && !defined(ALLOW_UNALIGNED_TRUETYPE)\r\n\r\n   #define ttUSHORT(p)   (* (stbtt_uint16 *) (p))\r\n   #define ttSHORT(p)    (* (stbtt_int16 *) (p))\r\n   #define ttULONG(p)    (* (stbtt_uint32 *) (p))\r\n   #define ttLONG(p)     (* (stbtt_int32 *) (p))\r\n\r\n#else\r\n\r\n   stbtt_uint16 ttUSHORT(const stbtt_uint8 *p) { return p[0]*256 + p[1]; }\r\n   stbtt_int16 ttSHORT(const stbtt_uint8 *p)   { return p[0]*256 + p[1]; }\r\n   stbtt_uint32 ttULONG(const stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\r\n   stbtt_int32 ttLONG(const stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }\r\n\r\n#endif\r\n\r\n#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))\r\n#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])\r\n\r\nstatic int stbtt__isfont(const stbtt_uint8 *font)\r\n{\r\n   // check the version number\r\n   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1\r\n   if (stbtt_tag(font, \"typ1\"))   return 1; // TrueType with type 1 font -- we don't support this!\r\n   if (stbtt_tag(font, \"OTTO\"))   return 1; // OpenType with CFF\r\n   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0\r\n   return 0;\r\n}\r\n\r\n// @OPTIMIZE: binary search\r\nstatic stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)\r\n{\r\n   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);\r\n   stbtt_uint32 tabledir = fontstart + 12;\r\n   stbtt_int32 i;\r\n   for (i=0; i < num_tables; ++i) {\r\n      stbtt_uint32 loc = tabledir + 16*i;\r\n      if (stbtt_tag(data+loc+0, tag))\r\n         return ttULONG(data+loc+8);\r\n   }\r\n   return 0;\r\n}\r\n\r\nint stbtt_GetFontOffsetForIndex(const unsigned char *font_collection, int index)\r\n{\r\n   // if it's just a font, there's only one valid index\r\n   if (stbtt__isfont(font_collection))\r\n      return index == 0 ? 0 : -1;\r\n\r\n   // check if it's a TTC\r\n   if (stbtt_tag(font_collection, \"ttcf\")) {\r\n      // version 1?\r\n      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {\r\n         stbtt_int32 n = ttLONG(font_collection+8);\r\n         if (index >= n)\r\n            return -1;\r\n         return ttULONG(font_collection+12+index*14);\r\n      }\r\n   }\r\n   return -1;\r\n}\r\n\r\nint stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data2, int fontstart)\r\n{\r\n   stbtt_uint8 *data = (stbtt_uint8 *) data2;\r\n   stbtt_uint32 cmap, t;\r\n   stbtt_int32 i,numTables;\r\n\r\n   info->data = data;\r\n   info->fontstart = fontstart;\r\n\r\n   cmap = stbtt__find_table(data, fontstart, \"cmap\");       // required\r\n   info->loca = stbtt__find_table(data, fontstart, \"loca\"); // required\r\n   info->head = stbtt__find_table(data, fontstart, \"head\"); // required\r\n   info->glyf = stbtt__find_table(data, fontstart, \"glyf\"); // required\r\n   info->hhea = stbtt__find_table(data, fontstart, \"hhea\"); // required\r\n   info->hmtx = stbtt__find_table(data, fontstart, \"hmtx\"); // required\r\n   info->kern = stbtt__find_table(data, fontstart, \"kern\"); // not required\r\n   if (!cmap || !info->loca || !info->head || !info->glyf || !info->hhea || !info->hmtx)\r\n      return 0;\r\n\r\n   t = stbtt__find_table(data, fontstart, \"maxp\");\r\n   if (t)\r\n      info->numGlyphs = ttUSHORT(data+t+4);\r\n   else\r\n      info->numGlyphs = 0xffff;\r\n\r\n   // find a cmap encoding table we understand *now* to avoid searching\r\n   // later. (todo: could make this installable)\r\n   // the same regardless of glyph.\r\n   numTables = ttUSHORT(data + cmap + 2);\r\n   info->index_map = 0;\r\n   for (i=0; i < numTables; ++i) {\r\n      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;\r\n      // find an encoding we understand:\r\n      switch(ttUSHORT(data+encoding_record)) {\r\n         case STBTT_PLATFORM_ID_MICROSOFT:\r\n            switch (ttUSHORT(data+encoding_record+2)) {\r\n               case STBTT_MS_EID_UNICODE_BMP:\r\n               case STBTT_MS_EID_UNICODE_FULL:\r\n                  // MS/Unicode\r\n                  info->index_map = cmap + ttULONG(data+encoding_record+4);\r\n                  break;\r\n            }\r\n            break;\r\n      }\r\n   }\r\n   if (info->index_map == 0)\r\n      return 0;\r\n\r\n   info->indexToLocFormat = ttUSHORT(data+info->head + 50);\r\n   return 1;\r\n}\r\n\r\nint stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)\r\n{\r\n   stbtt_uint8 *data = info->data;\r\n   stbtt_uint32 index_map = info->index_map;\r\n\r\n   stbtt_uint16 format = ttUSHORT(data + index_map + 0);\r\n   if (format == 0) { // apple byte encoding\r\n      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);\r\n      if (unicode_codepoint < bytes-6)\r\n         return ttBYTE(data + index_map + 6 + unicode_codepoint);\r\n      return 0;\r\n   } else if (format == 6) {\r\n      stbtt_uint32 first = ttUSHORT(data + index_map + 6);\r\n      stbtt_uint32 count = ttUSHORT(data + index_map + 8);\r\n      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)\r\n         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);\r\n      return 0;\r\n   } else if (format == 2) {\r\n      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean\r\n      return 0;\r\n   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges\r\n      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;\r\n      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;\r\n      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);\r\n      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;\r\n      stbtt_uint16 item, offset, start/*, end*/;\r\n\r\n      // do a binary search of the segments\r\n      stbtt_uint32 endCount = index_map + 14;\r\n      stbtt_uint32 search = endCount;\r\n\r\n      if (unicode_codepoint > 0xffff)\r\n         return 0;\r\n\r\n      // they lie from endCount .. endCount + segCount\r\n      // but searchRange is the nearest power of two, so...\r\n      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))\r\n         search += rangeShift*2;\r\n\r\n      // now decrement to bias correctly to find smallest\r\n      search -= 2;\r\n      while (entrySelector) {\r\n         stbtt_uint16 /*start,*/ end;\r\n         searchRange >>= 1;\r\n         /*start = ttUSHORT(data + search + 2 + segcount*2 + 2);*/\r\n         end = ttUSHORT(data + search + 2);\r\n         /*start = ttUSHORT(data + search + searchRange*2 + segcount*2 + 2);*/\r\n         end = ttUSHORT(data + search + searchRange*2);\r\n         if (unicode_codepoint > end)\r\n            search += searchRange*2;\r\n         --entrySelector;\r\n      }\r\n      search += 2;\r\n\r\n      item = (stbtt_uint16) ((search - endCount) >> 1);\r\n\r\n      STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));\r\n      start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);\r\n      /*end = ttUSHORT(data + index_map + 14 + 2 + 2*item)*/;\r\n      if (unicode_codepoint < start)\r\n         return 0;\r\n\r\n      offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);\r\n      if (offset == 0)\r\n         return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));\r\n\r\n      return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);\r\n   } else if (format == 12 || format == 13) {\r\n      stbtt_uint32 ngroups = ttULONG(data+index_map+12);\r\n      stbtt_int32 low,high;\r\n      low = 0; high = (stbtt_int32)ngroups;\r\n      // Binary search the right group.\r\n      while (low < high) {\r\n         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high\r\n         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);\r\n         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);\r\n         if ((stbtt_uint32) unicode_codepoint < start_char)\r\n            high = mid;\r\n         else if ((stbtt_uint32) unicode_codepoint > end_char)\r\n            low = mid+1;\r\n         else {\r\n            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);\r\n            if (format == 12)\r\n               return start_glyph + unicode_codepoint-start_char;\r\n            else // format == 13\r\n               return start_glyph;\r\n         }\r\n      }\r\n      return 0; // not found\r\n   }\r\n   // @TODO\r\n   STBTT_assert(0);\r\n   return 0;\r\n}\r\n\r\nint stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)\r\n{\r\n   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);\r\n}\r\n\r\nstatic void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)\r\n{\r\n   v->type = type;\r\n   v->x = (stbtt_int16) x;\r\n   v->y = (stbtt_int16) y;\r\n   v->cx = (stbtt_int16) cx;\r\n   v->cy = (stbtt_int16) cy;\r\n}\r\n\r\nstatic int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)\r\n{\r\n   int g1,g2;\r\n\r\n   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range\r\n   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format\r\n\r\n   if (info->indexToLocFormat == 0) {\r\n      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;\r\n      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;\r\n   } else {\r\n      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);\r\n      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);\r\n   }\r\n\r\n   return g1==g2 ? -1 : g1; // if length is 0, return -1\r\n}\r\n\r\nint stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\r\n   if (g < 0) return 0;\r\n\r\n   if (x0) *x0 = ttSHORT(info->data + g + 2);\r\n   if (y0) *y0 = ttSHORT(info->data + g + 4);\r\n   if (x1) *x1 = ttSHORT(info->data + g + 6);\r\n   if (y1) *y1 = ttSHORT(info->data + g + 8);\r\n   return 1;\r\n}\r\n\r\nint stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);\r\n}\r\n\r\nint stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)\r\n{\r\n   stbtt_int16 numberOfContours;\r\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\r\n   if (g < 0) return 1;\r\n   numberOfContours = ttSHORT(info->data + g);\r\n   return numberOfContours == 0;\r\n}\r\n\r\nstatic int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,\r\n    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)\r\n{\r\n   if (start_off) {\r\n      if (was_off)\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);\r\n      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);\r\n   } else {\r\n      if (was_off)\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);\r\n      else\r\n         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);\r\n   }\r\n   return num_vertices;\r\n}\r\n\r\nint stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)\r\n{\r\n   stbtt_int16 numberOfContours;\r\n   stbtt_uint8 *endPtsOfContours;\r\n   stbtt_uint8 *data = info->data;\r\n   stbtt_vertex *vertices=0;\r\n   int num_vertices=0;\r\n   int g = stbtt__GetGlyfOffset(info, glyph_index);\r\n\r\n   *pvertices = NULL;\r\n\r\n   if (g < 0) return 0;\r\n\r\n   numberOfContours = ttSHORT(data + g);\r\n\r\n   if (numberOfContours > 0) {\r\n      stbtt_uint8 flags=0,flagcount;\r\n      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;\r\n      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;\r\n      stbtt_uint8 *points;\r\n      endPtsOfContours = (data + g + 10);\r\n      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);\r\n      points = data + g + 10 + numberOfContours * 2 + 2 + ins;\r\n\r\n      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);\r\n\r\n      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need\r\n      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);\r\n      if (vertices == 0)\r\n         return 0;\r\n\r\n      next_move = 0;\r\n      flagcount=0;\r\n\r\n      // in first pass, we load uninterpreted data into the allocated array\r\n      // above, shifted to the end of the array so we won't overwrite it when\r\n      // we create our final data starting from the front\r\n\r\n      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated\r\n\r\n      // first load flags\r\n\r\n      for (i=0; i < n; ++i) {\r\n         if (flagcount == 0) {\r\n            flags = *points++;\r\n            if (flags & 8)\r\n               flagcount = *points++;\r\n         } else\r\n            --flagcount;\r\n         vertices[off+i].type = flags;\r\n      }\r\n\r\n      // now load x coordinates\r\n      x=0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         if (flags & 2) {\r\n            stbtt_int16 dx = *points++;\r\n            x += (flags & 16) ? dx : -dx; // ???\r\n         } else {\r\n            if (!(flags & 16)) {\r\n               x = x + (stbtt_int16) (points[0]*256 + points[1]);\r\n               points += 2;\r\n            }\r\n         }\r\n         vertices[off+i].x = (stbtt_int16) x;\r\n      }\r\n\r\n      // now load y coordinates\r\n      y=0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         if (flags & 4) {\r\n            stbtt_int16 dy = *points++;\r\n            y += (flags & 32) ? dy : -dy; // ???\r\n         } else {\r\n            if (!(flags & 32)) {\r\n               y = y + (stbtt_int16) (points[0]*256 + points[1]);\r\n               points += 2;\r\n            }\r\n         }\r\n         vertices[off+i].y = (stbtt_int16) y;\r\n      }\r\n\r\n      // now convert them to our format\r\n      num_vertices=0;\r\n      sx = sy = cx = cy = scx = scy = 0;\r\n      for (i=0; i < n; ++i) {\r\n         flags = vertices[off+i].type;\r\n         x     = (stbtt_int16) vertices[off+i].x;\r\n         y     = (stbtt_int16) vertices[off+i].y;\r\n\r\n         if (next_move == i) {\r\n            if (i != 0)\r\n               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\r\n\r\n            // now start the new one               \r\n            start_off = !(flags & 1);\r\n            if (start_off) {\r\n               // if we start off with an off-curve point, then when we need to find a point on the curve\r\n               // where we can start, and we need to save some state for when we wraparound.\r\n               scx = x;\r\n               scy = y;\r\n               if (!(vertices[off+i+1].type & 1)) {\r\n                  // next point is also a curve point, so interpolate an on-point curve\r\n                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\r\n                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\r\n               } else {\r\n                  // otherwise just use the next point as our start point\r\n                  sx = (stbtt_int32) vertices[off+i+1].x;\r\n                  sy = (stbtt_int32) vertices[off+i+1].y;\r\n                  ++i; // we're using point i+1 as the starting point, so skip it\r\n               }\r\n            } else {\r\n               sx = x;\r\n               sy = y;\r\n            }\r\n            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);\r\n            was_off = 0;\r\n            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);\r\n            ++j;\r\n         } else {\r\n            if (!(flags & 1)) { // if it's a curve\r\n               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\r\n               cx = x;\r\n               cy = y;\r\n               was_off = 1;\r\n            } else {\r\n               if (was_off)\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);\r\n               else\r\n                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);\r\n               was_off = 0;\r\n            }\r\n         }\r\n      }\r\n      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);\r\n   } else if (numberOfContours == -1) {\r\n      // Compound shapes.\r\n      int more = 1;\r\n      stbtt_uint8 *comp = data + g + 10;\r\n      num_vertices = 0;\r\n      vertices = 0;\r\n      while (more) {\r\n         stbtt_uint16 flags, gidx;\r\n         int comp_num_verts = 0, i;\r\n         stbtt_vertex *comp_verts = 0, *tmp = 0;\r\n         float mtx[6] = {1,0,0,1,0,0}, m, n;\r\n         \r\n         flags = ttSHORT(comp); comp+=2;\r\n         gidx = ttSHORT(comp); comp+=2;\r\n\r\n         if (flags & 2) { // XY values\r\n            if (flags & 1) { // shorts\r\n               mtx[4] = ttSHORT(comp); comp+=2;\r\n               mtx[5] = ttSHORT(comp); comp+=2;\r\n            } else {\r\n               mtx[4] = ttCHAR(comp); comp+=1;\r\n               mtx[5] = ttCHAR(comp); comp+=1;\r\n            }\r\n         }\r\n         else {\r\n            // @TODO handle matching point\r\n            STBTT_assert(0);\r\n         }\r\n         if (flags & (1<<3)) { // WE_HAVE_A_SCALE\r\n            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = mtx[2] = 0;\r\n         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE\r\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = mtx[2] = 0;\r\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO\r\n            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;\r\n            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;\r\n         }\r\n         \r\n         // Find transformation scales.\r\n         m = (float) sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);\r\n         n = (float) sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);\r\n\r\n         // Get indexed glyph.\r\n         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);\r\n         if (comp_num_verts > 0) {\r\n            // Transform vertices.\r\n            for (i = 0; i < comp_num_verts; ++i) {\r\n               stbtt_vertex* v = &comp_verts[i];\r\n               stbtt_vertex_type x,y;\r\n               x=v->x; y=v->y;\r\n               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\r\n               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\r\n               x=v->cx; y=v->cy;\r\n               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));\r\n               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));\r\n            }\r\n            // Append vertices.\r\n            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);\r\n            if (!tmp) {\r\n               if (vertices) STBTT_free(vertices, info->userdata);\r\n               if (comp_verts) STBTT_free(comp_verts, info->userdata);\r\n               return 0;\r\n            }\r\n            if (num_vertices > 0) memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));\r\n            memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));\r\n            if (vertices) STBTT_free(vertices, info->userdata);\r\n            vertices = tmp;\r\n            STBTT_free(comp_verts, info->userdata);\r\n            num_vertices += comp_num_verts;\r\n         }\r\n         // More components ?\r\n         more = flags & (1<<5);\r\n      }\r\n   } else if (numberOfContours < 0) {\r\n      // @TODO other compound variations?\r\n      STBTT_assert(0);\r\n   } else {\r\n      // numberOfCounters == 0, do nothing\r\n   }\r\n\r\n   *pvertices = vertices;\r\n   return num_vertices;\r\n}\r\n\r\nvoid stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)\r\n{\r\n   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);\r\n   if (glyph_index < numOfLongHorMetrics) {\r\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);\r\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);\r\n   } else {\r\n      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));\r\n      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));\r\n   }\r\n}\r\n\r\nint  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)\r\n{\r\n   stbtt_uint8 *data = info->data + info->kern;\r\n   stbtt_uint32 needle, straw;\r\n   int l, r, m;\r\n\r\n   // we only look at the first table. it must be 'horizontal' and format 0.\r\n   if (!info->kern)\r\n      return 0;\r\n   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1\r\n      return 0;\r\n   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format\r\n      return 0;\r\n\r\n   l = 0;\r\n   r = ttUSHORT(data+10) - 1;\r\n   needle = glyph1 << 16 | glyph2;\r\n   while (l <= r) {\r\n      m = (l + r) >> 1;\r\n      straw = ttULONG(data+18+(m*6)); // note: unaligned read\r\n      if (needle < straw)\r\n         r = m - 1;\r\n      else if (needle > straw)\r\n         l = m + 1;\r\n      else\r\n         return ttSHORT(data+22+(m*6));\r\n   }\r\n   return 0;\r\n}\r\n\r\nint  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)\r\n{\r\n   if (!info->kern) // if no kerning table, don't waste time looking up both codepoint->glyphs\r\n      return 0;\r\n   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));\r\n}\r\n\r\nvoid stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)\r\n{\r\n   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);\r\n}\r\n\r\nvoid stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)\r\n{\r\n   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);\r\n   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);\r\n   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);\r\n}\r\n\r\nvoid stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)\r\n{\r\n   *x0 = ttSHORT(info->data + info->head + 36);\r\n   *y0 = ttSHORT(info->data + info->head + 38);\r\n   *x1 = ttSHORT(info->data + info->head + 40);\r\n   *y1 = ttSHORT(info->data + info->head + 42);\r\n}\r\n\r\nfloat stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)\r\n{\r\n   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);\r\n   return (float) height / fheight;\r\n}\r\n\r\nfloat stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)\r\n{\r\n   int unitsPerEm = ttUSHORT(info->data + info->head + 18);\r\n   return pixels / unitsPerEm;\r\n}\r\n\r\nvoid stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)\r\n{\r\n   STBTT_free(v, info->userdata);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// antialiasing software rasterizer\r\n//\r\n\r\nvoid stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   int x0,y0,x1,y1;\r\n   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1))\r\n      x0=y0=x1=y1=0; // e.g. space character\r\n   // now move to integral bboxes (treating pixels as little squares, what pixels get touched)?\r\n   if (ix0) *ix0 =  STBTT_ifloor(x0 * scale_x + shift_x);\r\n   if (iy0) *iy0 = -STBTT_iceil (y1 * scale_y + shift_y);\r\n   if (ix1) *ix1 =  STBTT_iceil (x1 * scale_x + shift_x);\r\n   if (iy1) *iy1 = -STBTT_ifloor(y0 * scale_y + shift_y);\r\n}\r\nvoid stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);\r\n}\r\n\r\nvoid stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);\r\n}\r\n\r\nvoid stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)\r\n{\r\n   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);\r\n}\r\n\r\ntypedef struct stbtt__edge {\r\n   float x0,y0, x1,y1;\r\n   int invert;\r\n} stbtt__edge;\r\n\r\ntypedef struct stbtt__active_edge\r\n{\r\n   int x,dx;\r\n   float ey;\r\n   struct stbtt__active_edge *next;\r\n   int valid;\r\n} stbtt__active_edge;\r\n\r\n#define FIXSHIFT   10\r\n#define FIX        (1 << FIXSHIFT)\r\n#define FIXMASK    (FIX-1)\r\n\r\nstatic stbtt__active_edge *new_active(stbtt__edge *e, int off_x, float start_point, void *userdata)\r\n{\r\n   stbtt__active_edge *z = (stbtt__active_edge *) STBTT_malloc(sizeof(*z), userdata); // @TODO: make a pool of these!!!\r\n   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);\r\n   STBTT_assert(e->y0 <= start_point);\r\n   if (!z) return z;\r\n   // round dx down to avoid going too far\r\n   if (dxdy < 0)\r\n      z->dx = -STBTT_ifloor(FIX * -dxdy);\r\n   else\r\n      z->dx = STBTT_ifloor(FIX * dxdy);\r\n   z->x = STBTT_ifloor(FIX * (e->x0 + dxdy * (start_point - e->y0)));\r\n   z->x -= off_x * FIX;\r\n   z->ey = e->y1;\r\n   z->next = 0;\r\n   z->valid = e->invert ? 1 : -1;\r\n   return z;\r\n}\r\n\r\n// note: this routine clips fills that extend off the edges... ideally this\r\n// wouldn't happen, but it could happen if the truetype glyph bounding boxes\r\n// are wrong, or if the user supplies a too-small bitmap\r\nstatic void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)\r\n{\r\n   // non-zero winding fill\r\n   int x0=0, w=0;\r\n\r\n   while (e) {\r\n      if (w == 0) {\r\n         // if we're currently at zero, we need to record the edge start point\r\n         x0 = e->x; w += e->valid;\r\n      } else {\r\n         int x1 = e->x; w += e->valid;\r\n         // if we went to zero, we need to draw\r\n         if (w == 0) {\r\n            int i = x0 >> FIXSHIFT;\r\n            int j = x1 >> FIXSHIFT;\r\n\r\n            if (i < len && j >= 0) {\r\n               if (i == j) {\r\n                  // x0,x1 are the same pixel, so compute combined coverage\r\n                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> FIXSHIFT);\r\n               } else {\r\n                  if (i >= 0) // add antialiasing for x0\r\n                     scanline[i] = scanline[i] + (stbtt_uint8) (((FIX - (x0 & FIXMASK)) * max_weight) >> FIXSHIFT);\r\n                  else\r\n                     i = -1; // clip\r\n\r\n                  if (j < len) // add antialiasing for x1\r\n                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & FIXMASK) * max_weight) >> FIXSHIFT);\r\n                  else\r\n                     j = len; // clip\r\n\r\n                  for (++i; i < j; ++i) // fill pixels between x0 and x1\r\n                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;\r\n               }\r\n            }\r\n         }\r\n      }\r\n      \r\n      e = e->next;\r\n   }\r\n}\r\n\r\nstatic void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)\r\n{\r\n   stbtt__active_edge *active = NULL;\r\n   int y,j=0;\r\n   int max_weight = (255 / vsubsample);  // weight per vertical scanline\r\n   int s; // vertical subsample index\r\n   unsigned char scanline_data[512], *scanline;\r\n\r\n   if (result->w > 512)\r\n      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);\r\n   else\r\n      scanline = scanline_data;\r\n\r\n   y = off_y * vsubsample;\r\n   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;\r\n\r\n   while (j < result->h) {\r\n      STBTT_memset(scanline, 0, result->w);\r\n      for (s=0; s < vsubsample; ++s) {\r\n         // find center of pixel for this scanline\r\n         float scan_y = y + 0.5f;\r\n         stbtt__active_edge **step = &active;\r\n\r\n         // update all active edges;\r\n         // remove all active edges that terminate before the center of this scanline\r\n         while (*step) {\r\n            stbtt__active_edge * z = *step;\r\n            if (z->ey <= scan_y) {\r\n               *step = z->next; // delete from list\r\n               STBTT_assert(z->valid);\r\n               z->valid = 0;\r\n               STBTT_free(z, userdata);\r\n            } else {\r\n               z->x += z->dx; // advance to position for current scanline\r\n               step = &((*step)->next); // advance through list\r\n            }\r\n         }\r\n\r\n         // resort the list if needed\r\n         for(;;) {\r\n            int changed=0;\r\n            step = &active;\r\n            while (*step && (*step)->next) {\r\n               if ((*step)->x > (*step)->next->x) {\r\n                  stbtt__active_edge *t = *step;\r\n                  stbtt__active_edge *q = t->next;\r\n\r\n                  t->next = q->next;\r\n                  q->next = t;\r\n                  *step = q;\r\n                  changed = 1;\r\n               }\r\n               step = &(*step)->next;\r\n            }\r\n            if (!changed) break;\r\n         }\r\n\r\n         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline\r\n         while (e->y0 <= scan_y) {\r\n            if (e->y1 > scan_y) {\r\n               stbtt__active_edge *z = new_active(e, off_x, scan_y, userdata);\r\n               // find insertion point\r\n               if (active == NULL)\r\n                  active = z;\r\n               else if (z->x < active->x) {\r\n                  // insert at front\r\n                  z->next = active;\r\n                  active = z;\r\n               } else {\r\n                  // find thing to insert AFTER\r\n                  stbtt__active_edge *p = active;\r\n                  while (p->next && p->next->x < z->x)\r\n                     p = p->next;\r\n                  // at this point, p->next->x is NOT < z->x\r\n                  z->next = p->next;\r\n                  p->next = z;\r\n               }\r\n            }\r\n            ++e;\r\n         }\r\n\r\n         // now process all active edges in XOR fashion\r\n         if (active)\r\n            stbtt__fill_active_edges(scanline, result->w, active, max_weight);\r\n\r\n         ++y;\r\n      }\r\n      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);\r\n      ++j;\r\n   }\r\n\r\n   while (active) {\r\n      stbtt__active_edge *z = active;\r\n      active = active->next;\r\n      STBTT_free(z, userdata);\r\n   }\r\n\r\n   if (scanline != scanline_data)\r\n      STBTT_free(scanline, userdata);\r\n}\r\n\r\nstatic int stbtt__edge_compare(const void *p, const void *q)\r\n{\r\n   stbtt__edge *a = (stbtt__edge *) p;\r\n   stbtt__edge *b = (stbtt__edge *) q;\r\n\r\n   if (a->y0 < b->y0) return -1;\r\n   if (a->y0 > b->y0) return  1;\r\n   return 0;\r\n}\r\n\r\ntypedef struct\r\n{\r\n   float x,y;\r\n} stbtt__point;\r\n\r\nstatic void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)\r\n{\r\n   float y_scale_inv = invert ? -scale_y : scale_y;\r\n   stbtt__edge *e;\r\n   int n,i,j,k,m;\r\n   int vsubsample = result->h < 8 ? 15 : 5;\r\n   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity\r\n\r\n   // now we have to blow out the windings into explicit edge lists\r\n   n = 0;\r\n   for (i=0; i < windings; ++i)\r\n      n += wcount[i];\r\n\r\n   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel\r\n   if (e == 0) return;\r\n   n = 0;\r\n\r\n   m=0;\r\n   for (i=0; i < windings; ++i) {\r\n      stbtt__point *p = pts + m;\r\n      m += wcount[i];\r\n      j = wcount[i]-1;\r\n      for (k=0; k < wcount[i]; j=k++) {\r\n         int a=k,b=j;\r\n         // skip the edge if horizontal\r\n         if (p[j].y == p[k].y)\r\n            continue;\r\n         // add edge from j to k to the list\r\n         e[n].invert = 0;\r\n         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {\r\n            e[n].invert = 1;\r\n            a=j,b=k;\r\n         }\r\n         e[n].x0 = p[a].x * scale_x + shift_x;\r\n         e[n].y0 = p[a].y * y_scale_inv * vsubsample + shift_y;\r\n         e[n].x1 = p[b].x * scale_x + shift_x;\r\n         e[n].y1 = p[b].y * y_scale_inv * vsubsample + shift_y;\r\n         ++n;\r\n      }\r\n   }\r\n\r\n   // now sort the edges by their highest point (should snap to integer, and then by x)\r\n   STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);\r\n\r\n   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule\r\n   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);\r\n\r\n   STBTT_free(e, userdata);\r\n}\r\n\r\nstatic void stbtt__add_point(stbtt__point *points, int n, float x, float y)\r\n{\r\n   if (!points) return; // during first pass, it's unallocated\r\n   points[n].x = x;\r\n   points[n].y = y;\r\n}\r\n\r\n// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching\r\nstatic int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)\r\n{\r\n   // midpoint\r\n   float mx = (x0 + 2*x1 + x2)/4;\r\n   float my = (y0 + 2*y1 + y2)/4;\r\n   // versus directly drawn line\r\n   float dx = (x0+x2)/2 - mx;\r\n   float dy = (y0+y2)/2 - my;\r\n   if (n > 16) // 65536 segments on one curve better be enough!\r\n      return 1;\r\n   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA\r\n      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);\r\n      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);\r\n   } else {\r\n      stbtt__add_point(points, *num_points,x2,y2);\r\n      *num_points = *num_points+1;\r\n   }\r\n   return 1;\r\n}\r\n\r\n// returns number of contours\r\nstbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)\r\n{\r\n   stbtt__point *points=0;\r\n   int num_points=0;\r\n\r\n   float objspace_flatness_squared = objspace_flatness * objspace_flatness;\r\n   int i,n=0,start=0, pass;\r\n\r\n   // count how many \"moves\" there are to get the contour count\r\n   for (i=0; i < num_verts; ++i)\r\n      if (vertices[i].type == STBTT_vmove)\r\n         ++n;\r\n\r\n   *num_contours = n;\r\n   if (n == 0) return 0;\r\n\r\n   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);\r\n\r\n   if (*contour_lengths == 0) {\r\n      *num_contours = 0;\r\n      return 0;\r\n   }\r\n\r\n   // make two passes through the points so we don't need to realloc\r\n   for (pass=0; pass < 2; ++pass) {\r\n      float x=0,y=0;\r\n      if (pass == 1) {\r\n         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);\r\n         if (points == NULL) goto error;\r\n      }\r\n      num_points = 0;\r\n      n= -1;\r\n      for (i=0; i < num_verts; ++i) {\r\n         switch (vertices[i].type) {\r\n            case STBTT_vmove:\r\n               // start the next contour\r\n               if (n >= 0)\r\n                  (*contour_lengths)[n] = num_points - start;\r\n               ++n;\r\n               start = num_points;\r\n\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               stbtt__add_point(points, num_points++, x,y);\r\n               break;\r\n            case STBTT_vline:\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               stbtt__add_point(points, num_points++, x, y);\r\n               break;\r\n            case STBTT_vcurve:\r\n               stbtt__tesselate_curve(points, &num_points, x,y,\r\n                                        vertices[i].cx, vertices[i].cy,\r\n                                        vertices[i].x,  vertices[i].y,\r\n                                        objspace_flatness_squared, 0);\r\n               x = vertices[i].x, y = vertices[i].y;\r\n               break;\r\n         }\r\n      }\r\n      (*contour_lengths)[n] = num_points - start;\r\n   }\r\n\r\n   return points;\r\nerror:\r\n   STBTT_free(points, userdata);\r\n   STBTT_free(*contour_lengths, userdata);\r\n   *contour_lengths = 0;\r\n   *num_contours = 0;\r\n   return NULL;\r\n}\r\n\r\nvoid stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)\r\n{\r\n   float scale = scale_x > scale_y ? scale_y : scale_x;\r\n   int winding_count, *winding_lengths;\r\n   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);\r\n   if (windings) {\r\n      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);\r\n      STBTT_free(winding_lengths, userdata);\r\n      STBTT_free(windings, userdata);\r\n   }\r\n}\r\n\r\nvoid stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)\r\n{\r\n   STBTT_free(bitmap, userdata);\r\n}\r\n\r\nunsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   int ix0,iy0,ix1,iy1;\r\n   stbtt__bitmap gbm;\r\n   stbtt_vertex *vertices;   \r\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\r\n\r\n   if (scale_x == 0) scale_x = scale_y;\r\n   if (scale_y == 0) {\r\n      if (scale_x == 0) return NULL;\r\n      scale_y = scale_x;\r\n   }\r\n\r\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);\r\n\r\n   // now we get the size\r\n   gbm.w = (ix1 - ix0);\r\n   gbm.h = (iy1 - iy0);\r\n   gbm.pixels = NULL; // in case we error\r\n\r\n   if (width ) *width  = gbm.w;\r\n   if (height) *height = gbm.h;\r\n   if (xoff  ) *xoff   = ix0;\r\n   if (yoff  ) *yoff   = iy0;\r\n   \r\n   if (gbm.w && gbm.h) {\r\n      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);\r\n      if (gbm.pixels) {\r\n         gbm.stride = gbm.w;\r\n\r\n         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);\r\n      }\r\n   }\r\n   STBTT_free(vertices, info->userdata);\r\n   return gbm.pixels;\r\n}   \r\n\r\nunsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);\r\n}\r\n\r\nvoid stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)\r\n{\r\n   int ix0,iy0;\r\n   stbtt_vertex *vertices;\r\n   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);\r\n   stbtt__bitmap gbm;   \r\n\r\n   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);\r\n   gbm.pixels = output;\r\n   gbm.w = out_w;\r\n   gbm.h = out_h;\r\n   gbm.stride = out_stride;\r\n\r\n   if (gbm.w && gbm.h)\r\n      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);\r\n\r\n   STBTT_free(vertices, info->userdata);\r\n}\r\n\r\nvoid stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);\r\n}\r\n\r\nunsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);\r\n}   \r\n\r\nvoid stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)\r\n{\r\n   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));\r\n}\r\n\r\nunsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)\r\n{\r\n   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);\r\n}   \r\n\r\nvoid stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)\r\n{\r\n   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// bitmap baking\r\n//\r\n// This is SUPER-CRAPPY packing to keep source code small\r\n\r\nextern int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)\r\n                                float pixel_height,                     // height of font in pixels\r\n                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in\r\n                                int first_char, int num_chars,          // characters to bake\r\n                                stbtt_bakedchar *chardata)\r\n{\r\n   float scale;\r\n   int x,y,bottom_y, i;\r\n   stbtt_fontinfo f;\r\n   stbtt_InitFont(&f, data, offset);\r\n   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels\r\n   x=y=1;\r\n   bottom_y = 1;\r\n\r\n   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);\r\n\r\n   for (i=0; i < num_chars; ++i) {\r\n      int advance, lsb, x0,y0,x1,y1,gw,gh;\r\n      int g = stbtt_FindGlyphIndex(&f, first_char + i);\r\n      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);\r\n      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);\r\n      gw = x1-x0;\r\n      gh = y1-y0;\r\n      if (x + gw + 1 >= pw)\r\n         y = bottom_y, x = 1; // advance to next row\r\n      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row\r\n         return -i;\r\n      STBTT_assert(x+gw < pw);\r\n      STBTT_assert(y+gh < ph);\r\n      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);\r\n      chardata[i].x0 = (stbtt_int16) x;\r\n      chardata[i].y0 = (stbtt_int16) y;\r\n      chardata[i].x1 = (stbtt_int16) (x + gw);\r\n      chardata[i].y1 = (stbtt_int16) (y + gh);\r\n      chardata[i].xadvance = scale * advance;\r\n      chardata[i].xoff     = (float) x0;\r\n      chardata[i].yoff     = (float) y0;\r\n      x = x + gw + 2;\r\n      if (y+gh+2 > bottom_y)\r\n         bottom_y = y+gh+2;\r\n   }\r\n   return bottom_y;\r\n}\r\n\r\nvoid stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)\r\n{\r\n   float d3d_bias = opengl_fillrule ? 0 : -0.5f;\r\n   float ipw = 1.0f / pw, iph = 1.0f / ph;\r\n   stbtt_bakedchar *b = chardata + char_index;\r\n   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5);\r\n   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5);\r\n\r\n   q->x0 = round_x + d3d_bias;\r\n   q->y0 = round_y + d3d_bias;\r\n   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;\r\n   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;\r\n\r\n   q->s0 = b->x0 * ipw;\r\n   q->t0 = b->y0 * iph;\r\n   q->s1 = b->x1 * ipw;\r\n   q->t1 = b->y1 * iph;\r\n\r\n   *xpos += b->xadvance;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n//\r\n// font name matching -- recommended not to use this\r\n//\r\n\r\n// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string\r\nstatic stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(const stbtt_uint8 *s1, stbtt_int32 len1, const stbtt_uint8 *s2, stbtt_int32 len2) \r\n{\r\n   stbtt_int32 i=0;\r\n\r\n   // convert utf16 to utf8 and compare the results while converting\r\n   while (len2) {\r\n      stbtt_uint16 ch = s2[0]*256 + s2[1];\r\n      if (ch < 0x80) {\r\n         if (i >= len1) return -1;\r\n         if (s1[i++] != ch) return -1;\r\n      } else if (ch < 0x800) {\r\n         if (i+1 >= len1) return -1;\r\n         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;\r\n         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;\r\n      } else if (ch >= 0xd800 && ch < 0xdc00) {\r\n         stbtt_uint32 c;\r\n         stbtt_uint16 ch2 = s2[2]*256 + s2[3];\r\n         if (i+3 >= len1) return -1;\r\n         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;\r\n         if (s1[i++] != 0xf0 + (c >> 18)) return -1;\r\n         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;\r\n         s2 += 2; // plus another 2 below\r\n         len2 -= 2;\r\n      } else if (ch >= 0xdc00 && ch < 0xe000) {\r\n         return -1;\r\n      } else {\r\n         if (i+2 >= len1) return -1;\r\n         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;\r\n         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;\r\n         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;\r\n      }\r\n      s2 += 2;\r\n      len2 -= 2;\r\n   }\r\n   return i;\r\n}\r\n\r\nint stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2) \r\n{\r\n   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((const stbtt_uint8*) s1, len1, (const stbtt_uint8*) s2, len2);\r\n}\r\n\r\n// returns results in whatever encoding you request... but note that 2-byte encodings\r\n// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare\r\nconst char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)\r\n{\r\n   stbtt_int32 i,count,stringOffset;\r\n   stbtt_uint8 *fc = font->data;\r\n   stbtt_uint32 offset = font->fontstart;\r\n   stbtt_uint32 nm = stbtt__find_table(fc, offset, \"name\");\r\n   if (!nm) return NULL;\r\n\r\n   count = ttUSHORT(fc+nm+2);\r\n   stringOffset = nm + ttUSHORT(fc+nm+4);\r\n   for (i=0; i < count; ++i) {\r\n      stbtt_uint32 loc = nm + 6 + 12 * i;\r\n      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)\r\n          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {\r\n         *length = ttUSHORT(fc+loc+8);\r\n         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));\r\n      }\r\n   }\r\n   return NULL;\r\n}\r\n\r\nstatic int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)\r\n{\r\n   stbtt_int32 i;\r\n   stbtt_int32 count = ttUSHORT(fc+nm+2);\r\n   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);\r\n\r\n   for (i=0; i < count; ++i) {\r\n      stbtt_uint32 loc = nm + 6 + 12 * i;\r\n      stbtt_int32 id = ttUSHORT(fc+loc+6);\r\n      if (id == target_id) {\r\n         // find the encoding\r\n         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);\r\n\r\n         // is this a Unicode encoding?\r\n         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {\r\n            stbtt_int32 slen = ttUSHORT(fc+loc+8), off = ttUSHORT(fc+loc+10);\r\n\r\n            // check if there's a prefix match\r\n            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);\r\n            if (matchlen >= 0) {\r\n               // check for target_id+1 immediately following, with same encoding & language\r\n               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {\r\n                  stbtt_int32 slen = ttUSHORT(fc+loc+12+8), off = ttUSHORT(fc+loc+12+10);\r\n                  if (slen == 0) {\r\n                     if (matchlen == nlen)\r\n                        return 1;\r\n                  } else if (matchlen < nlen && name[matchlen] == ' ') {\r\n                     ++matchlen;\r\n                     if (stbtt_CompareUTF8toUTF16_bigendian((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))\r\n                        return 1;\r\n                  }\r\n               } else {\r\n                  // if nothing immediately following\r\n                  if (matchlen == nlen)\r\n                     return 1;\r\n               }\r\n            }\r\n         }\r\n\r\n         // @TODO handle other encodings\r\n      }\r\n   }\r\n   return 0;\r\n}\r\n\r\nstatic int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)\r\n{\r\n   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);\r\n   stbtt_uint32 nm,hd;\r\n   if (!stbtt__isfont(fc+offset)) return 0;\r\n\r\n   // check italics/bold/underline flags in macStyle...\r\n   if (flags) {\r\n      hd = stbtt__find_table(fc, offset, \"head\");\r\n      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;\r\n   }\r\n\r\n   nm = stbtt__find_table(fc, offset, \"name\");\r\n   if (!nm) return 0;\r\n\r\n   if (flags) {\r\n      // if we checked the macStyle flags, then just check the family and ignore the subfamily\r\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\r\n   } else {\r\n      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;\r\n      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;\r\n   }\r\n\r\n   return 0;\r\n}\r\n\r\nint stbtt_FindMatchingFont(const unsigned char *font_collection, const char *name_utf8, stbtt_int32 flags)\r\n{\r\n   stbtt_int32 i;\r\n   for (i=0;;++i) {\r\n      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);\r\n      if (off < 0) return off;\r\n      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))\r\n         return off;\r\n   }\r\n}\r\n\r\n#endif // STB_TRUETYPE_IMPLEMENTATION\r\n","/*\n *  Copyright (c) 2009 Public Software Group e. V., Berlin, Germany\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a\n *  copy of this software and associated documentation files (the \"Software\"),\n *  to deal in the Software without restriction, including without limitation\n *  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n *  and/or sell copies of the Software, and to permit persons to whom the\n *  Software is furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n *  DEALINGS IN THE SOFTWARE.\n */\n\n/*\n *  This library contains derived data from a modified version of the\n *  Unicode data files.\n *\n *  The original data files are available at\n *  http://www.unicode.org/Public/UNIDATA/\n *\n *  Please notice the copyright statement in the file \"utf8proc_data.c\".\n */\n\n\n/*\n *  File name:    utf8proc.c\n *\n *  Description:\n *  Implementation of libutf8proc.\n */\n\n\n#include \"utf8proc.h\"\n#include \"utf8proc_data.h\"\n\n\nconst int8_t utf8proc_utf8class[256] = {\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n#define UTF8PROC_HANGUL_SBASE 0xAC00\n#define UTF8PROC_HANGUL_LBASE 0x1100\n#define UTF8PROC_HANGUL_VBASE 0x1161\n#define UTF8PROC_HANGUL_TBASE 0x11A7\n#define UTF8PROC_HANGUL_LCOUNT 19\n#define UTF8PROC_HANGUL_VCOUNT 21\n#define UTF8PROC_HANGUL_TCOUNT 28\n#define UTF8PROC_HANGUL_NCOUNT 588\n#define UTF8PROC_HANGUL_SCOUNT 11172\n/* END is exclusive */\n#define UTF8PROC_HANGUL_L_START  0x1100\n#define UTF8PROC_HANGUL_L_END    0x115A\n#define UTF8PROC_HANGUL_L_FILLER 0x115F\n#define UTF8PROC_HANGUL_V_START  0x1160\n#define UTF8PROC_HANGUL_V_END    0x11A3\n#define UTF8PROC_HANGUL_T_START  0x11A8\n#define UTF8PROC_HANGUL_T_END    0x11FA\n#define UTF8PROC_HANGUL_S_START  0xAC00\n#define UTF8PROC_HANGUL_S_END    0xD7A4\n\n\n#define UTF8PROC_BOUNDCLASS_START    0\n#define UTF8PROC_BOUNDCLASS_OTHER    1\n#define UTF8PROC_BOUNDCLASS_CR       2\n#define UTF8PROC_BOUNDCLASS_LF       3\n#define UTF8PROC_BOUNDCLASS_CONTROL  4\n#define UTF8PROC_BOUNDCLASS_EXTEND   5\n#define UTF8PROC_BOUNDCLASS_L        6\n#define UTF8PROC_BOUNDCLASS_V        7\n#define UTF8PROC_BOUNDCLASS_T        8\n#define UTF8PROC_BOUNDCLASS_LV       9\n#define UTF8PROC_BOUNDCLASS_LVT     10\n\n\nconst char *utf8proc_version(void) {\n  return \"1.1.6\";\n}\n\nconst char *utf8proc_errmsg(ssize_t errcode) {\n  switch (errcode) {\n    case UTF8PROC_ERROR_NOMEM:\n    return \"Memory for processing UTF-8 data could not be allocated.\";\n    case UTF8PROC_ERROR_OVERFLOW:\n    return \"UTF-8 string is too long to be processed.\";\n    case UTF8PROC_ERROR_INVALIDUTF8:\n    return \"Invalid UTF-8 string\";\n    case UTF8PROC_ERROR_NOTASSIGNED:\n    return \"Unassigned Unicode code point found in UTF-8 string.\";\n    case UTF8PROC_ERROR_INVALIDOPTS:\n    return \"Invalid options for UTF-8 processing chosen.\";\n    default:\n    return \"An unknown error occured while processing UTF-8 data.\";\n  }\n}\n\nssize_t utf8proc_iterate(\n  const uint8_t *str, ssize_t strlen, int32_t *dst\n) {\n  int length;\n  int i;\n  int32_t uc = -1;\n  *dst = -1;\n  if (!strlen) return 0;\n  length = utf8proc_utf8class[str[0]];\n  if (!length) return UTF8PROC_ERROR_INVALIDUTF8;\n  if (strlen >= 0 && length > strlen) return UTF8PROC_ERROR_INVALIDUTF8;\n  for (i=1; i<length; i++) {\n    if ((str[i] & 0xC0) != 0x80) return UTF8PROC_ERROR_INVALIDUTF8;\n  }\n  switch (length) {\n    case 1:\n    uc = str[0];\n    break;\n    case 2:\n    uc = ((str[0] & 0x1F) <<  6) + (str[1] & 0x3F);\n    if (uc < 0x80) uc = -1;\n    break;\n    case 3:\n    uc = ((str[0] & 0x0F) << 12) + ((str[1] & 0x3F) <<  6)\n      + (str[2] & 0x3F);\n    if (uc < 0x800 || (uc >= 0xD800 && uc < 0xE000) ||\n      (uc >= 0xFDD0 && uc < 0xFDF0)) uc = -1;\n    break;\n    case 4:\n    uc = ((str[0] & 0x07) << 18) + ((str[1] & 0x3F) << 12)\n      + ((str[2] & 0x3F) <<  6) + (str[3] & 0x3F);\n    if (uc < 0x10000 || uc >= 0x110000) uc = -1;\n    break;\n  }\n  if (uc < 0 || ((uc & 0xFFFF) >= 0xFFFE))\n    return UTF8PROC_ERROR_INVALIDUTF8;\n  *dst = uc;\n  return length;\n}\n\nbool utf8proc_codepoint_valid(int32_t uc) {\n  if (uc < 0 || uc >= 0x110000 ||\n    ((uc & 0xFFFF) >= 0xFFFE) || (uc >= 0xD800 && uc < 0xE000) ||\n    (uc >= 0xFDD0 && uc < 0xFDF0)) return false;\n  else return true;\n}\n\nssize_t utf8proc_encode_char(int32_t uc, uint8_t *dst) {\n  if (uc < 0x00) {\n    return 0;\n  } else if (uc < 0x80) {\n    dst[0] = uc;\n    return 1;\n  } else if (uc < 0x800) {\n    dst[0] = 0xC0 + (uc >> 6);\n    dst[1] = 0x80 + (uc & 0x3F);\n    return 2;\n  } else if (uc == 0xFFFF) {\n    dst[0] = 0xFF;\n    return 1;\n  } else if (uc == 0xFFFE) {\n    dst[0] = 0xFE;\n    return 1;\n  } else if (uc < 0x10000) {\n    dst[0] = 0xE0 + (uc >> 12);\n    dst[1] = 0x80 + ((uc >> 6) & 0x3F);\n    dst[2] = 0x80 + (uc & 0x3F);\n    return 3;\n  } else if (uc < 0x110000) {\n    dst[0] = 0xF0 + (uc >> 18);\n    dst[1] = 0x80 + ((uc >> 12) & 0x3F);\n    dst[2] = 0x80 + ((uc >> 6) & 0x3F);\n    dst[3] = 0x80 + (uc & 0x3F);\n    return 4;\n  } else return 0;\n}\n\nconst utf8proc_property_t *utf8proc_get_property(int32_t uc) {\n  /* ASSERT: uc >= 0 && uc < 0x110000 */\n  return utf8proc_properties + (\n    utf8proc_stage2table[\n      utf8proc_stage1table[uc >> 8] + (uc & 0xFF)\n    ]\n  );\n}\n\n#define utf8proc_decompose_lump(replacement_uc) \\\n  return utf8proc_decompose_char((replacement_uc), dst, bufsize, \\\n  options & ~UTF8PROC_LUMP, last_boundclass)\n\nssize_t utf8proc_decompose_char(int32_t uc, int32_t *dst, ssize_t bufsize,\n    int options, int *last_boundclass) {\n  /* ASSERT: uc >= 0 && uc < 0x110000 */\n  const utf8proc_property_t *property;\n  utf8proc_propval_t category;\n  int32_t hangul_sindex;\n  property = utf8proc_get_property(uc);\n  category = property->category;\n  hangul_sindex = uc - UTF8PROC_HANGUL_SBASE;\n  if (options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) {\n    if (hangul_sindex >= 0 && hangul_sindex < UTF8PROC_HANGUL_SCOUNT) {\n      int32_t hangul_tindex;\n      if (bufsize >= 1) {\n        dst[0] = UTF8PROC_HANGUL_LBASE +\n          hangul_sindex / UTF8PROC_HANGUL_NCOUNT;\n        if (bufsize >= 2) dst[1] = UTF8PROC_HANGUL_VBASE +\n          (hangul_sindex % UTF8PROC_HANGUL_NCOUNT) / UTF8PROC_HANGUL_TCOUNT;\n      }\n      hangul_tindex = hangul_sindex % UTF8PROC_HANGUL_TCOUNT;\n      if (!hangul_tindex) return 2;\n      if (bufsize >= 3) dst[2] = UTF8PROC_HANGUL_TBASE + hangul_tindex;\n      return 3;\n    }\n  }\n  if (options & UTF8PROC_REJECTNA) {\n    if (!category) return UTF8PROC_ERROR_NOTASSIGNED;\n  }\n  if (options & UTF8PROC_IGNORE) {\n    if (property->ignorable) return 0;\n  }\n  if (options & UTF8PROC_LUMP) {\n    if (category == UTF8PROC_CATEGORY_ZS) utf8proc_decompose_lump(0x0020);\n    if (uc == 0x2018 || uc == 0x2019 || uc == 0x02BC || uc == 0x02C8)\n      utf8proc_decompose_lump(0x0027);\n    if (category == UTF8PROC_CATEGORY_PD || uc == 0x2212)\n      utf8proc_decompose_lump(0x002D);\n    if (uc == 0x2044 || uc == 0x2215) utf8proc_decompose_lump(0x002F);\n    if (uc == 0x2236) utf8proc_decompose_lump(0x003A);\n    if (uc == 0x2039 || uc == 0x2329 || uc == 0x3008)\n      utf8proc_decompose_lump(0x003C);\n    if (uc == 0x203A || uc == 0x232A || uc == 0x3009)\n      utf8proc_decompose_lump(0x003E);\n    if (uc == 0x2216) utf8proc_decompose_lump(0x005C);\n    if (uc == 0x02C4 || uc == 0x02C6 || uc == 0x2038 || uc == 0x2303)\n      utf8proc_decompose_lump(0x005E);\n    if (category == UTF8PROC_CATEGORY_PC || uc == 0x02CD)\n      utf8proc_decompose_lump(0x005F);\n    if (uc == 0x02CB) utf8proc_decompose_lump(0x0060);\n    if (uc == 0x2223) utf8proc_decompose_lump(0x007C);\n    if (uc == 0x223C) utf8proc_decompose_lump(0x007E);\n    if ((options & UTF8PROC_NLF2LS) && (options & UTF8PROC_NLF2PS)) {\n      if (category == UTF8PROC_CATEGORY_ZL ||\n          category == UTF8PROC_CATEGORY_ZP)\n        utf8proc_decompose_lump(0x000A);\n    }\n  }\n  if (options & UTF8PROC_STRIPMARK) {\n    if (category == UTF8PROC_CATEGORY_MN ||\n      category == UTF8PROC_CATEGORY_MC ||\n      category == UTF8PROC_CATEGORY_ME) return 0;\n  }\n  if (options & UTF8PROC_CASEFOLD) {\n    if (property->casefold_mapping) {\n      const int32_t *casefold_entry;\n      ssize_t written = 0;\n      for (casefold_entry = property->casefold_mapping;\n          *casefold_entry >= 0; casefold_entry++) {\n        written += utf8proc_decompose_char(*casefold_entry, dst+written,\n          (bufsize > written) ? (bufsize - written) : 0, options,\n          last_boundclass);\n        if (written < 0) return UTF8PROC_ERROR_OVERFLOW;\n      }\n      return written;\n    }\n  }\n  if (options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) {\n    if (property->decomp_mapping &&\n        (!property->decomp_type || (options & UTF8PROC_COMPAT))) {\n      const int32_t *decomp_entry;\n      ssize_t written = 0;\n      for (decomp_entry = property->decomp_mapping;\n          *decomp_entry >= 0; decomp_entry++) {\n        written += utf8proc_decompose_char(*decomp_entry, dst+written,\n          (bufsize > written) ? (bufsize - written) : 0, options,\n        last_boundclass);\n        if (written < 0) return UTF8PROC_ERROR_OVERFLOW;\n      }\n      return written;\n    }\n  }\n  if (options & UTF8PROC_CHARBOUND) {\n    bool boundary;\n    int tbc, lbc;\n    tbc =\n      (uc == 0x000D) ? UTF8PROC_BOUNDCLASS_CR :\n      (uc == 0x000A) ? UTF8PROC_BOUNDCLASS_LF :\n      ((category == UTF8PROC_CATEGORY_ZL ||\n        category == UTF8PROC_CATEGORY_ZP ||\n        category == UTF8PROC_CATEGORY_CC ||\n        category == UTF8PROC_CATEGORY_CF) &&\n        !(uc == 0x200C || uc == 0x200D)) ? UTF8PROC_BOUNDCLASS_CONTROL :\n      property->extend ? UTF8PROC_BOUNDCLASS_EXTEND :\n      ((uc >= UTF8PROC_HANGUL_L_START && uc < UTF8PROC_HANGUL_L_END) ||\n        uc == UTF8PROC_HANGUL_L_FILLER) ? UTF8PROC_BOUNDCLASS_L :\n      (uc >= UTF8PROC_HANGUL_V_START && uc < UTF8PROC_HANGUL_V_END) ?\n        UTF8PROC_BOUNDCLASS_V :\n      (uc >= UTF8PROC_HANGUL_T_START && uc < UTF8PROC_HANGUL_T_END) ?\n        UTF8PROC_BOUNDCLASS_T :\n      (uc >= UTF8PROC_HANGUL_S_START && uc < UTF8PROC_HANGUL_S_END) ? (\n        ((uc-UTF8PROC_HANGUL_SBASE) % UTF8PROC_HANGUL_TCOUNT == 0) ?\n          UTF8PROC_BOUNDCLASS_LV : UTF8PROC_BOUNDCLASS_LVT\n      ) :\n      UTF8PROC_BOUNDCLASS_OTHER;\n    lbc = *last_boundclass;\n    boundary =\n      (tbc == UTF8PROC_BOUNDCLASS_EXTEND) ? false :\n      (lbc == UTF8PROC_BOUNDCLASS_START) ? true :\n      (lbc == UTF8PROC_BOUNDCLASS_CR &&\n       tbc == UTF8PROC_BOUNDCLASS_LF) ? false :\n      (lbc == UTF8PROC_BOUNDCLASS_CONTROL) ? true :\n      (tbc == UTF8PROC_BOUNDCLASS_CONTROL) ? true :\n      (lbc == UTF8PROC_BOUNDCLASS_L &&\n       (tbc == UTF8PROC_BOUNDCLASS_L ||\n        tbc == UTF8PROC_BOUNDCLASS_V ||\n        tbc == UTF8PROC_BOUNDCLASS_LV ||\n        tbc == UTF8PROC_BOUNDCLASS_LVT)) ? false :\n      ((lbc == UTF8PROC_BOUNDCLASS_LV ||\n        lbc == UTF8PROC_BOUNDCLASS_V) &&\n       (tbc == UTF8PROC_BOUNDCLASS_V ||\n        tbc == UTF8PROC_BOUNDCLASS_T)) ? false :\n      ((lbc == UTF8PROC_BOUNDCLASS_LVT ||\n        lbc == UTF8PROC_BOUNDCLASS_T) &&\n       tbc == UTF8PROC_BOUNDCLASS_T) ? false :\n       true;\n    *last_boundclass = tbc;\n    if (boundary) {\n      if (bufsize >= 1) dst[0] = 0xFFFF;\n      if (bufsize >= 2) dst[1] = uc;\n      return 2;\n    }\n  }\n  if (bufsize >= 1) *dst = uc;\n  return 1;\n}\n\nssize_t utf8proc_decompose(\n  const uint8_t *str, ssize_t strlen,\n  int32_t *buffer, ssize_t bufsize, int options\n) {\n  /* strlen will be ignored, if UTF8PROC_NULLTERM is set in options */\n  ssize_t wpos = 0;\n  if ((options & UTF8PROC_COMPOSE) && (options & UTF8PROC_DECOMPOSE))\n    return UTF8PROC_ERROR_INVALIDOPTS;\n  if ((options & UTF8PROC_STRIPMARK) &&\n      !(options & UTF8PROC_COMPOSE) && !(options & UTF8PROC_DECOMPOSE))\n    return UTF8PROC_ERROR_INVALIDOPTS;\n  {\n    int32_t uc;\n    ssize_t rpos = 0;\n    ssize_t decomp_result;\n    int boundclass = UTF8PROC_BOUNDCLASS_START;\n    while (1) {\n      if (options & UTF8PROC_NULLTERM) {\n        rpos += utf8proc_iterate(str + rpos, -1, &uc);\n        /* checking of return value is not neccessary,\n           as 'uc' is < 0 in case of error */\n        if (uc < 0) return UTF8PROC_ERROR_INVALIDUTF8;\n        if (rpos < 0) return UTF8PROC_ERROR_OVERFLOW;\n        if (uc == 0) break;\n      } else {\n        if (rpos >= strlen) break;\n        rpos += utf8proc_iterate(str + rpos, strlen - rpos, &uc);\n        if (uc < 0) return UTF8PROC_ERROR_INVALIDUTF8;\n      }\n      decomp_result = utf8proc_decompose_char(\n        uc, buffer + wpos, (bufsize > wpos) ? (bufsize - wpos) : 0, options,\n        &boundclass\n      );\n      if (decomp_result < 0) return decomp_result;\n      wpos += decomp_result;\n      /* prohibiting integer overflows due to too long strings: */\n      if (wpos < 0 || wpos > SSIZE_MAX/sizeof(int32_t)/2)\n        return UTF8PROC_ERROR_OVERFLOW;\n    }\n  }\n  if ((options & (UTF8PROC_COMPOSE|UTF8PROC_DECOMPOSE)) && bufsize >= wpos) {\n    ssize_t pos = 0;\n    while (pos < wpos-1) {\n      int32_t uc1, uc2;\n      const utf8proc_property_t *property1, *property2;\n      uc1 = buffer[pos];\n      uc2 = buffer[pos+1];\n      property1 = utf8proc_get_property(uc1);\n      property2 = utf8proc_get_property(uc2);\n      if (property1->combining_class > property2->combining_class &&\n          property2->combining_class > 0) {\n        buffer[pos] = uc2;\n        buffer[pos+1] = uc1;\n        if (pos > 0) pos--; else pos++;\n      } else {\n        pos++;\n      }\n    }\n  }\n  return wpos;\n}\n\nssize_t utf8proc_reencode(int32_t *buffer, ssize_t length, int options) {\n  /* UTF8PROC_NULLTERM option will be ignored, 'length' is never ignored\n     ASSERT: 'buffer' has one spare byte of free space at the end! */\n  if (options & (UTF8PROC_NLF2LS | UTF8PROC_NLF2PS | UTF8PROC_STRIPCC)) {\n    ssize_t rpos;\n    ssize_t wpos = 0;\n    int32_t uc;\n    for (rpos = 0; rpos < length; rpos++) {\n      uc = buffer[rpos];\n      if (uc == 0x000D && rpos < length-1 && buffer[rpos+1] == 0x000A) rpos++;\n      if (uc == 0x000A || uc == 0x000D || uc == 0x0085 ||\n          ((options & UTF8PROC_STRIPCC) && (uc == 0x000B || uc == 0x000C))) {\n        if (options & UTF8PROC_NLF2LS) {\n          if (options & UTF8PROC_NLF2PS) {\n            buffer[wpos++] = 0x000A;\n          } else {\n            buffer[wpos++] = 0x2028;\n          }\n        } else {\n          if (options & UTF8PROC_NLF2PS) {\n            buffer[wpos++] = 0x2029;\n          } else {\n            buffer[wpos++] = 0x0020;\n          }\n        }\n      } else if ((options & UTF8PROC_STRIPCC) &&\n          (uc < 0x0020 || (uc >= 0x007F && uc < 0x00A0))) {\n        if (uc == 0x0009) buffer[wpos++] = 0x0020;\n      } else {\n        buffer[wpos++] = uc;\n      }\n    }\n    length = wpos;\n  }\n  if (options & UTF8PROC_COMPOSE) {\n    int32_t *starter = NULL;\n    int32_t current_char;\n    const utf8proc_property_t *starter_property = NULL, *current_property;\n    utf8proc_propval_t max_combining_class = -1;\n    ssize_t rpos;\n    ssize_t wpos = 0;\n    int32_t composition;\n    for (rpos = 0; rpos < length; rpos++) {\n      current_char = buffer[rpos];\n      current_property = utf8proc_get_property(current_char);\n      if (starter && current_property->combining_class > max_combining_class) {\n        /* combination perhaps possible */\n        int32_t hangul_lindex;\n        int32_t hangul_sindex;\n        hangul_lindex = *starter - UTF8PROC_HANGUL_LBASE;\n        if (hangul_lindex >= 0 && hangul_lindex < UTF8PROC_HANGUL_LCOUNT) {\n          int32_t hangul_vindex;\n          hangul_vindex = current_char - UTF8PROC_HANGUL_VBASE;\n          if (hangul_vindex >= 0 && hangul_vindex < UTF8PROC_HANGUL_VCOUNT) {\n            *starter = UTF8PROC_HANGUL_SBASE +\n              (hangul_lindex * UTF8PROC_HANGUL_VCOUNT + hangul_vindex) *\n              UTF8PROC_HANGUL_TCOUNT;\n            starter_property = NULL;\n            continue;\n          }\n        }\n        hangul_sindex = *starter - UTF8PROC_HANGUL_SBASE;\n        if (hangul_sindex >= 0 && hangul_sindex < UTF8PROC_HANGUL_SCOUNT &&\n            (hangul_sindex % UTF8PROC_HANGUL_TCOUNT) == 0) {\n          int32_t hangul_tindex;\n          hangul_tindex = current_char - UTF8PROC_HANGUL_TBASE;\n          if (hangul_tindex >= 0 && hangul_tindex < UTF8PROC_HANGUL_TCOUNT) {\n            *starter += hangul_tindex;\n            starter_property = NULL;\n            continue;\n          }\n        }\n        if (!starter_property) {\n          starter_property = utf8proc_get_property(*starter);\n        }\n        if (starter_property->comb1st_index >= 0 &&\n            current_property->comb2nd_index >= 0) {\n          composition = utf8proc_combinations[\n            starter_property->comb1st_index +\n            current_property->comb2nd_index\n          ];\n          if (composition >= 0 && (!(options & UTF8PROC_STABLE) ||\n              !(utf8proc_get_property(composition)->comp_exclusion))) {\n            *starter = composition;\n            starter_property = NULL;\n            continue;\n          }\n        }\n      }\n      buffer[wpos] = current_char;\n      if (current_property->combining_class) {\n        if (current_property->combining_class > max_combining_class) {\n          max_combining_class = current_property->combining_class;\n        }\n      } else {\n        starter = buffer + wpos;\n        starter_property = NULL;\n        max_combining_class = -1;\n      }\n      wpos++;\n    }\n    length = wpos;\n  }\n  {\n    ssize_t rpos, wpos = 0;\n    int32_t uc;\n    for (rpos = 0; rpos < length; rpos++) {\n      uc = buffer[rpos];\n      wpos += utf8proc_encode_char(uc, ((uint8_t *)buffer) + wpos);\n    }\n    ((uint8_t *)buffer)[wpos] = 0;\n    return wpos;\n  }\n}\n\nssize_t utf8proc_map(\n  const uint8_t *str, ssize_t strlen, uint8_t **dstptr, int options\n) {\n  int32_t *buffer;\n  ssize_t result;\n  *dstptr = NULL;\n  result = utf8proc_decompose(str, strlen, NULL, 0, options);\n  if (result < 0) return result;\n  buffer = malloc(result * sizeof(int32_t) + 1);\n  if (!buffer) return UTF8PROC_ERROR_NOMEM;\n  result = utf8proc_decompose(str, strlen, buffer, result, options);\n  if (result < 0) {\n    free(buffer);\n    return result;\n  }\n  result = utf8proc_reencode(buffer, result, options);\n  if (result < 0) {\n    free(buffer);\n    return result;\n  }\n  {\n    int32_t *newptr;\n    newptr = realloc(buffer, (size_t)result+1);\n    if (newptr) buffer = newptr;\n  }\n  *dstptr = (uint8_t *)buffer;\n  return result;\n}\n\nuint8_t *utf8proc_NFD(const uint8_t *str) {\n  uint8_t *retval;\n  utf8proc_map(str, 0, &retval, UTF8PROC_NULLTERM | UTF8PROC_STABLE |\n    UTF8PROC_DECOMPOSE);\n  return retval;\n}\n\nuint8_t *utf8proc_NFC(const uint8_t *str) {\n  uint8_t *retval;\n  utf8proc_map(str, 0, &retval, UTF8PROC_NULLTERM | UTF8PROC_STABLE |\n    UTF8PROC_COMPOSE);\n  return retval;\n}\n\nuint8_t *utf8proc_NFKD(const uint8_t *str) {\n  uint8_t *retval;\n  utf8proc_map(str, 0, &retval, UTF8PROC_NULLTERM | UTF8PROC_STABLE |\n    UTF8PROC_DECOMPOSE | UTF8PROC_COMPAT);\n  return retval;\n}\n\nuint8_t *utf8proc_NFKC(const uint8_t *str) {\n  uint8_t *retval;\n  utf8proc_map(str, 0, &retval, UTF8PROC_NULLTERM | UTF8PROC_STABLE |\n    UTF8PROC_COMPOSE | UTF8PROC_COMPAT);\n  return retval;\n}\n\n"]}